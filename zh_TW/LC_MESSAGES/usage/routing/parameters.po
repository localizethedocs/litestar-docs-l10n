# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/routing/parameters.rst:2
msgid "Parameters"
msgstr "參數"

#: ../../../usage/routing/parameters.rst:5
msgid "Path Parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:7
msgid ""
"Path :term:`parameters <parameter>` are parameters declared as part of the "
"``path`` component of the URL. They are declared using a simple syntax "
"``{param_name:param_type}`` :"
msgstr ""

#: ../../../usage/routing/parameters.rst:11
msgid "Defining a path parameter in a route handler"
msgstr ""

#: ../../../usage/routing/parameters.rst:11
msgid ""
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"USER_DB = {1: {\"id\": 1, \"name\": \"John Doe\"}}\n"
"\n"
"\n"
"class User(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/user/{user_id:int}\", sync_to_thread=False)\n"
"def get_user(user_id: int) -> User:\n"
"    return User.model_validate(USER_DB[user_id])\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_user])"
msgstr ""

#: ../../../usage/routing/parameters.rst:14
msgid "In the above there are two components:"
msgstr ""

#: ../../../usage/routing/parameters.rst:16
msgid ""
"The path :term:`parameter` is defined in the :class:`@get() <.handlers."
"get>` :term:`decorator`, which declares both the parameter's name "
"(``user_id``) and type (:class:`int`)."
msgstr ""

#: ../../../usage/routing/parameters.rst:18
msgid ""
"The :term:`decorated <decorator>` function ``get_user`` defines a parameter "
"with the same name as the parameter defined in the ``path`` :term:`kwarg "
"<argument>`."
msgstr ""

#: ../../../usage/routing/parameters.rst:21
msgid ""
"The correlation of parameter name ensures that the value of the path "
"parameter will be injected into the function when it is called."
msgstr ""

#: ../../../usage/routing/parameters.rst:25
msgid "Supported Path Parameter Types"
msgstr ""

#: ../../../usage/routing/parameters.rst:27
msgid "Currently, the following types are supported:"
msgstr ""

#: ../../../usage/routing/parameters.rst:29
msgid "``date``: Accepts date strings and time stamps."
msgstr ""

#: ../../../usage/routing/parameters.rst:30
msgid "``datetime``: Accepts date-time strings and time stamps."
msgstr ""

#: ../../../usage/routing/parameters.rst:31
msgid "``decimal``: Accepts decimal values and floats."
msgstr ""

#: ../../../usage/routing/parameters.rst:32
msgid ":class:`float`: Accepts ints and floats."
msgstr ""

#: ../../../usage/routing/parameters.rst:33
msgid ":class:`int`: Accepts ints and floats."
msgstr ""

#: ../../../usage/routing/parameters.rst:34
msgid ":class:`path`: Accepts valid POSIX paths."
msgstr ""

#: ../../../usage/routing/parameters.rst:35
msgid ":class:`str`: Accepts all string values."
msgstr ""

#: ../../../usage/routing/parameters.rst:36
msgid ""
"``time``: Accepts time strings with optional timezone compatible with "
"standard (Pydantic/Msgspec) datetime formats."
msgstr ""

#: ../../../usage/routing/parameters.rst:37
msgid ""
"``timedelta``: Accepts duration strings compatible with the standard "
"(Pydantic/Msgspec) timedelta formats."
msgstr ""

#: ../../../usage/routing/parameters.rst:38
msgid "``uuid``: Accepts all uuid values."
msgstr ""

#: ../../../usage/routing/parameters.rst:40
msgid ""
"The types declared in the path :term:`parameter` and the function do not "
"need to match 1:1 - as long as parameter inside the function declaration is "
"typed with a \"higher\" type to which the lower type can be coerced, this is "
"fine. For example, consider this:"
msgstr ""

#: ../../../usage/routing/parameters.rst:0
msgid "Python 3.8+"
msgstr "Python 3.8+"

#: ../../../usage/routing/parameters.rst:45
msgid "Coercing path parameters into different types"
msgstr ""

#: ../../../usage/routing/parameters.rst:45
msgid ""
"from datetime import datetime, timezone\n"
"from typing import List\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"class Order(BaseModel):\n"
"    id: int\n"
"    customer_id: int\n"
"\n"
"\n"
"ORDERS_BY_DATETIME = {\n"
"    datetime.fromtimestamp(1667924386, tz=timezone.utc): [\n"
"        Order(id=1, customer_id=2),\n"
"        Order(id=2, customer_id=2),\n"
"    ]\n"
"}\n"
"\n"
"\n"
"@get(path=\"/orders/{from_date:int}\", sync_to_thread=False)\n"
"def get_orders(from_date: datetime) -> List[Order]:\n"
"    return ORDERS_BY_DATETIME[from_date]\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_orders])"
msgstr ""

#: ../../../usage/routing/parameters.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/routing/parameters.rst:45
msgid ""
"from datetime import datetime, timezone\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"class Order(BaseModel):\n"
"    id: int\n"
"    customer_id: int\n"
"\n"
"\n"
"ORDERS_BY_DATETIME = {\n"
"    datetime.fromtimestamp(1667924386, tz=timezone.utc): [\n"
"        Order(id=1, customer_id=2),\n"
"        Order(id=2, customer_id=2),\n"
"    ]\n"
"}\n"
"\n"
"\n"
"@get(path=\"/orders/{from_date:int}\", sync_to_thread=False)\n"
"def get_orders(from_date: datetime) -> list[Order]:\n"
"    return ORDERS_BY_DATETIME[from_date]\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_orders])"
msgstr ""

#: ../../../usage/routing/parameters.rst:0
msgid "Python 3.11+"
msgstr ""

#: ../../../usage/routing/parameters.rst:45
msgid ""
"from datetime import datetime, UTC\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"class Order(BaseModel):\n"
"    id: int\n"
"    customer_id: int\n"
"\n"
"\n"
"ORDERS_BY_DATETIME = {\n"
"    datetime.fromtimestamp(1667924386, tz=UTC): [\n"
"        Order(id=1, customer_id=2),\n"
"        Order(id=2, customer_id=2),\n"
"    ]\n"
"}\n"
"\n"
"\n"
"@get(path=\"/orders/{from_date:int}\", sync_to_thread=False)\n"
"def get_orders(from_date: datetime) -> list[Order]:\n"
"    return ORDERS_BY_DATETIME[from_date]\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_orders])"
msgstr ""

#: ../../../usage/routing/parameters.rst:48
msgid ""
"The :term:`parameter` defined inside the ``path`` :term:`kwarg <argument>` "
"is typed as :class:`int` , because the value passed as part of the request "
"will be a timestamp in milliseconds without any decimals. The parameter in "
"the function declaration though is typed as :class:`datetime.datetime`."
msgstr ""

#: ../../../usage/routing/parameters.rst:52
msgid ""
"This works because the int value will be automatically coerced from an :"
"class:`int` into a :class:`~datetime.datetime`."
msgstr ""

#: ../../../usage/routing/parameters.rst:54
msgid ""
"Thus, when the function is called it will be called with a :class:`~datetime."
"datetime`-typed parameter."
msgstr ""

#: ../../../usage/routing/parameters.rst:56
msgid ""
"You only need to define the :term:`parameter` in the function declaration if "
"it is actually used inside the function. If the path parameter is part of "
"the path, but the function does not use it, it is fine to omit it. It will "
"still be validated and added to the OpenAPI schema correctly."
msgstr ""

#: ../../../usage/routing/parameters.rst:61
msgid "The Parameter function"
msgstr ""

#: ../../../usage/routing/parameters.rst:63
msgid ""
":func:`~.params.Parameter` is a helper function wrapping a :term:`parameter` "
"with extra information to be added to the OpenAPI schema."
msgstr ""

#: ../../../usage/routing/parameters.rst:67
msgid "Extra validation and documentation for path params"
msgstr ""

#: ../../../usage/routing/parameters.rst:69
msgid ""
"If you want to add validation or enhance the OpenAPI documentation generated "
"for a given path :term:`parameter`, you can do so using the `the parameter "
"function`_:"
msgstr ""

#: ../../../usage/routing/parameters.rst:73
msgid "Adding extra validation and documentation to a path parameter"
msgstr ""

#: ../../../usage/routing/parameters.rst:73
msgid ""
"from pydantic import BaseModel, Json, conint\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.openapi.spec.example import Example\n"
"from litestar.openapi.spec.external_documentation import "
"ExternalDocumentation\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class Version(BaseModel):\n"
"    id: conint(ge=1, le=10)  # type: ignore[valid-type]\n"
"    specs: Json\n"
"\n"
"\n"
"VERSIONS = {1: Version(id=1, specs='{\"some\": \"value\"}')}\n"
"\n"
"\n"
"@get(path=\"/versions/{version:int}\", sync_to_thread=False)\n"
"def get_product_version(\n"
"    version: Annotated[\n"
"        int,\n"
"        Parameter(\n"
"            ge=1,\n"
"            le=10,\n"
"            title=\"Available Product Versions\",\n"
"            description=\"Get a specific version spec from the available "
"specs\",\n"
"            examples=[Example(value=1)],\n"
"            external_docs=ExternalDocumentation(\n"
"                url=\"https://mywebsite.com/documentation/"
"product#versions\",  # type: ignore[arg-type]\n"
"            ),\n"
"        ),\n"
"    ],\n"
") -> Version:\n"
"    return VERSIONS[version]\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_product_version])"
msgstr ""

#: ../../../usage/routing/parameters.rst:73
msgid ""
"from pydantic import BaseModel, Json, conint\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.openapi.spec.example import Example\n"
"from litestar.openapi.spec.external_documentation import "
"ExternalDocumentation\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class Version(BaseModel):\n"
"    id: conint(ge=1, le=10)  # type: ignore[valid-type]\n"
"    specs: Json\n"
"\n"
"\n"
"VERSIONS = {1: Version(id=1, specs='{\"some\": \"value\"}')}\n"
"\n"
"\n"
"@get(path=\"/versions/{version:int}\", sync_to_thread=False)\n"
"def get_product_version(\n"
"    version: Annotated[\n"
"        int,\n"
"        Parameter(\n"
"            ge=1,\n"
"            le=10,\n"
"            title=\"Available Product Versions\",\n"
"            description=\"Get a specific version spec from the available "
"specs\",\n"
"            examples=[Example(value=1)],\n"
"            external_docs=ExternalDocumentation(\n"
"                url=\"https://mywebsite.com/documentation/"
"product#versions\",  # type: ignore[arg-type]\n"
"            ),\n"
"        ),\n"
"    ],\n"
") -> Version:\n"
"    return VERSIONS[version]\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_product_version])"
msgstr ""

#: ../../../usage/routing/parameters.rst:76
msgid ""
"In the above example, :func:`~.params.Parameter` is used to restrict the "
"value of :paramref:`~.params.Parameter.version` to a range between 1 and 10, "
"and then set the :paramref:`~.params.Parameter.title`, :paramref:`~.params."
"Parameter.description`, :paramref:`~.params.Parameter.examples`, and :"
"paramref:`externalDocs <.params.Parameter.external_docs>` sections of the "
"OpenAPI schema."
msgstr ""

#: ../../../usage/routing/parameters.rst:82
msgid "Query Parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:84
msgid ""
"Query :term:`parameters <parameter>` are defined as :term:`keyword arguments "
"<argument>` to handler functions. Every :term:`keyword argument <argument>` "
"that is not otherwise specified (for example as a :ref:`path parameter "
"<usage/routing/parameters:path parameters>`) will be interpreted as a query "
"parameter."
msgstr ""

#: ../../../usage/routing/parameters.rst:89
msgid "Defining query parameters in a route handler"
msgstr ""

#: ../../../usage/routing/parameters.rst:89
msgid ""
"from typing import Dict\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: str) -> Dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:89
msgid ""
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: str) -> dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/?param=foo\n"
"{\"param\":\"foo\"}\n"
"> curl http://127.0.0.1:8000/?param=bar\n"
"{\"param\":\"bar\"}"
msgstr ""

#: ../../../usage/routing/parameters.rst:92
msgid "Technical details"
msgstr ""

#: ../../../usage/routing/parameters.rst:95
msgid ""
"These :term:`parameters <parameter>` will be parsed from the function "
"signature and used to generate an internal data model. This model in turn "
"will be used to validate the parameters and generate the OpenAPI schema."
msgstr ""

#: ../../../usage/routing/parameters.rst:98
msgid ""
"This ability allows you to use any number of schema/modelling libraries, "
"including Pydantic, Msgspec, Attrs, and Dataclasses, and it will follow the "
"same kind of validation and parsing as you would get from these libraries."
msgstr ""

#: ../../../usage/routing/parameters.rst:101
msgid "Query :term:`parameters <parameter>` come in three basic types:"
msgstr ""

#: ../../../usage/routing/parameters.rst:103
msgid "Required"
msgstr ""

#: ../../../usage/routing/parameters.rst:104
msgid "Required with a default value"
msgstr ""

#: ../../../usage/routing/parameters.rst:105
msgid "Optional with a default value"
msgstr ""

#: ../../../usage/routing/parameters.rst:107
msgid ""
"Query parameters are **required** by default. If one such a parameter has no "
"value, a :exc:`~.exceptions.http_exceptions.ValidationException` will be "
"raised."
msgstr ""

#: ../../../usage/routing/parameters.rst:111
msgid "Default values"
msgstr ""

#: ../../../usage/routing/parameters.rst:113
msgid ""
"In this example, ``param`` will have the value ``\"hello\"`` if it is not "
"specified in the request. If it is passed as a query :term:`parameter` "
"however, it will be overwritten:"
msgstr ""

#: ../../../usage/routing/parameters.rst:117
msgid "Defining a default value for a query parameter"
msgstr ""

#: ../../../usage/routing/parameters.rst:117
msgid ""
"from typing import Dict\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: str = \"hello\") -> Dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:117
msgid ""
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: str = \"hello\") -> dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"{\"param\":\"hello\"}\n"
"> curl http://127.0.0.1:8000/?param=john\n"
"{\"param\":\"john\"}"
msgstr ""

#: ../../../usage/routing/parameters.rst:121
msgid "Optional :term:`parameters <parameter>`"
msgstr ""

#: ../../../usage/routing/parameters.rst:123
msgid ""
"Instead of only setting a default value, it is also possible to make a query "
"parameter entirely optional."
msgstr ""

#: ../../../usage/routing/parameters.rst:125
msgid ""
"Here, we give a default value of ``None`` , but still declare the type of "
"the query parameter to be a :class:`string <str>`. This means that this "
"parameter is not required."
msgstr ""

#: ../../../usage/routing/parameters.rst:128
msgid ""
"If it is given, it has to be a :class:`string <str>`. If it is not given, it "
"will have a default value of ``None``"
msgstr ""

#: ../../../usage/routing/parameters.rst:132
msgid "Defining an optional query parameter"
msgstr ""

#: ../../../usage/routing/parameters.rst:132
msgid ""
"from typing import Dict, Optional\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: Optional[str] = None) -> Dict[str, Optional[str]]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:132
msgid ""
"from typing import Optional\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: Optional[str] = None) -> dict[str, Optional[str]]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:0
msgid "Python 3.10+"
msgstr "Python 3.10+"

#: ../../../usage/routing/parameters.rst:132
msgid ""
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: str | None = None) -> dict[str, str | None]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"{\"param\":null}\n"
"> curl http://127.0.0.1:8000/?param=goodbye\n"
"{\"param\":\"goodbye\"}"
msgstr ""

#: ../../../usage/routing/parameters.rst:136
msgid "Type coercion"
msgstr ""

#: ../../../usage/routing/parameters.rst:138
msgid ""
"It is possible to coerce query :term:`parameters <parameter>` into different "
"types. A query starts out as a :class:`string <str>`, but its values can be "
"parsed into all kinds of types."
msgstr ""

#: ../../../usage/routing/parameters.rst:142
msgid "Coercing query parameters into different types"
msgstr ""

#: ../../../usage/routing/parameters.rst:142
msgid ""
"from datetime import datetime, timedelta\n"
"from typing import Any, Dict, List\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(date: datetime, number: int, floating_number: float, strings: "
"List[str]) -> Dict[str, Any]:\n"
"    return {\n"
"        \"datetime\": date + timedelta(days=1),\n"
"        \"int\": number,\n"
"        \"float\": floating_number,\n"
"        \"list\": strings,\n"
"    }\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:142
msgid ""
"from datetime import datetime, timedelta\n"
"from typing import Any\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(date: datetime, number: int, floating_number: float, strings: "
"list[str]) -> dict[str, Any]:\n"
"    return {\n"
"        \"datetime\": date + timedelta(days=1),\n"
"        \"int\": number,\n"
"        \"float\": floating_number,\n"
"        \"list\": strings,\n"
"    }\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/?"
"date=2022-11-28T13:22:06.916540&floating_number=0.1&number=42&strings=1&strings=2\n"
"{\"datetime\":\"2022-11-29T13:22:06.916540\",\"int\":42,\"float\":0.1,"
"\"list\":[\"1\",\"2\"]}"
msgstr ""

#: ../../../usage/routing/parameters.rst:146
msgid "Alternative names and constraints"
msgstr ""

#: ../../../usage/routing/parameters.rst:148
msgid ""
"Sometimes you might want to \"remap\" query :term:`parameters <parameter>` "
"to allow a different name in the URL than what is being used in the handler "
"function. This can be done by making use of :func:`~.params.Parameter`."
msgstr ""

#: ../../../usage/routing/parameters.rst:152
msgid "Remapping query parameters to different names"
msgstr ""

#: ../../../usage/routing/parameters.rst:152
msgid ""
"from typing import Dict\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(snake_case: Annotated[str, Parameter(query=\"camelCase\")]) -> "
"Dict[str, str]:\n"
"    return {\"param\": snake_case}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:152
msgid ""
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(snake_case: Annotated[str, Parameter(query=\"camelCase\")]) -> "
"dict[str, str]:\n"
"    return {\"param\": snake_case}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/?camelCase=foo\n"
"{\"param\":\"foo\"}"
msgstr ""

#: ../../../usage/routing/parameters.rst:155
msgid ""
"Here, we remap from ``snake_case`` in the handler function to ``camelCase`` "
"in the URL. This means that for the URL ``http://127.0.0.1:8000?"
"camelCase=foo`` , the value of ``camelCase`` will be used for the value of "
"the ``snake_case`` parameter."
msgstr ""

#: ../../../usage/routing/parameters.rst:159
msgid ""
":func:`~.params.Parameter` also allows us to define additional constraints:"
msgstr ""

#: ../../../usage/routing/parameters.rst:162
msgid "Constraints on query parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:162
msgid ""
"from typing import Dict\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: Annotated[int, Parameter(gt=5)]) -> Dict[str, int]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:162
msgid ""
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def index(param: Annotated[int, Parameter(gt=5)]) -> dict[str, int]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:165
msgid "In this case, ``param`` is validated to be an *integer larger than 5*."
msgstr ""

#: ../../../usage/routing/parameters.rst:168
msgid "Documenting enum query parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:170
msgid ""
"By default, the OpenAPI schema generated for enum query :term:`parameters "
"<parameter>` uses the enum's docstring for the description section of the "
"schema. The description can be changed with the :paramref:`~.params."
"Parameter.description` parameter of the `the parameter function`_, but doing "
"so can overwrite the descriptions of other query parameters of the same enum "
"because only one schema is generated per enum. This can be avoided by using "
"the :paramref:`~.params.Parameter.schema_component_key` parameter so that "
"separate schemas are generated:"
msgstr ""

#: ../../../usage/routing/parameters.rst:177
msgid "Query parameters with the same enum type and different descriptions"
msgstr ""

#: ../../../usage/routing/parameters.rst:177
msgid ""
"from enum import Enum\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class MyEnum(str, Enum):\n"
"    \"\"\"My enum accepts two values\"\"\"\n"
"\n"
"    A = \"a\"\n"
"    B = \"b\"\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def index(\n"
"    q1: Annotated[MyEnum, Parameter(description=\"This is q1\", "
"schema_component_key=\"q1\")],\n"
"    q2: MyEnum,\n"
"    q3: Annotated[MyEnum, Parameter(description=\"This is q3\", "
"schema_component_key=\"q3\")],\n"
") -> None: ...\n"
"\n"
"\n"
"app = Litestar([index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:177
msgid ""
"from enum import StrEnum\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class MyEnum(StrEnum):\n"
"    \"\"\"My enum accepts two values\"\"\"\n"
"\n"
"    A = \"a\"\n"
"    B = \"b\"\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def index(\n"
"    q1: Annotated[MyEnum, Parameter(description=\"This is q1\", "
"schema_component_key=\"q1\")],\n"
"    q2: MyEnum,\n"
"    q3: Annotated[MyEnum, Parameter(description=\"This is q3\", "
"schema_component_key=\"q3\")],\n"
") -> None: ...\n"
"\n"
"\n"
"app = Litestar([index])"
msgstr ""

#: ../../../usage/routing/parameters.rst:180
msgid ""
"In the above example, the schema for the ``q1`` query parameter references a "
"\"q1\" schema component with a description of \"This is q1\". The schema for "
"the ``q2`` query parameter references a \"MyEnum\" schema component with a "
"description of \"My enum accepts two values\". The schema for the ``q3`` "
"query parameter references a \"q3\" schema component with a description of "
"\"This is q3\"."
msgstr ""

#: ../../../usage/routing/parameters.rst:185
msgid ""
"If we did not pass :paramref:`~.params.Parameter.schema_component_key` "
"arguments for :func:`~.params.Parameter` for ``q1`` and ``q3``, then the "
"schemas for all three query parameters would reference the same \"MyEnum\" "
"schema component with the description \"This is q1\"."
msgstr ""

#: ../../../usage/routing/parameters.rst:190
msgid "Header and Cookie Parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:192
msgid ""
"Unlike *Query* :term:`parameters <parameter>`, *Header* and *Cookie* "
"parameters have to be declared using `the parameter function`_ , for example:"
msgstr ""

#: ../../../usage/routing/parameters.rst:196
msgid "Defining header and cookie parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:196
msgid ""
"from pydantic import BaseModel\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.params import Parameter\n"
"\n"
"USER_DB = {\n"
"    1: {\n"
"        \"id\": 1,\n"
"        \"name\": \"John Doe\",\n"
"    },\n"
"}\n"
"\n"
"VALID_TOKEN = \"super-secret-secret\"\n"
"VALID_COOKIE_VALUE = \"cookie-secret\"\n"
"\n"
"\n"
"class User(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(path=\"/users/{user_id:int}/\")\n"
"async def get_user(\n"
"    user_id: int,\n"
"    token: Annotated[str, Parameter(header=\"X-API-KEY\")],\n"
"    cookie: Annotated[str, Parameter(cookie=\"my-cookie-param\")],\n"
") -> User:\n"
"    if token != VALID_TOKEN or cookie != VALID_COOKIE_VALUE:\n"
"        raise NotAuthorizedException\n"
"    return User.model_validate(USER_DB[user_id])\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_user])"
msgstr ""

#: ../../../usage/routing/parameters.rst:196
msgid ""
"from pydantic import BaseModel\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.params import Parameter\n"
"\n"
"USER_DB = {\n"
"    1: {\n"
"        \"id\": 1,\n"
"        \"name\": \"John Doe\",\n"
"    },\n"
"}\n"
"\n"
"VALID_TOKEN = \"super-secret-secret\"\n"
"VALID_COOKIE_VALUE = \"cookie-secret\"\n"
"\n"
"\n"
"class User(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(path=\"/users/{user_id:int}/\")\n"
"async def get_user(\n"
"    user_id: int,\n"
"    token: Annotated[str, Parameter(header=\"X-API-KEY\")],\n"
"    cookie: Annotated[str, Parameter(cookie=\"my-cookie-param\")],\n"
") -> User:\n"
"    if token != VALID_TOKEN or cookie != VALID_COOKIE_VALUE:\n"
"        raise NotAuthorizedException\n"
"    return User.model_validate(USER_DB[user_id])\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_user])"
msgstr ""

#: ../../../usage/routing/parameters.rst:199
msgid ""
"As you can see in the above, header parameters are declared using the "
"``header`` :term:`kwargs <argument>` and cookie parameters using the "
"``cookie`` :term:`kwarg <argument>`. Aside form this difference they work "
"the same as query parameters."
msgstr ""

#: ../../../usage/routing/parameters.rst:204
msgid "Layered Parameters"
msgstr ""

#: ../../../usage/routing/parameters.rst:206
msgid ""
"As part of Litestar's :ref:`layered architecture <usage/applications:layered "
"architecture>`, you can declare :term:`parameters <parameter>` not only as "
"part of individual route handler functions, but also on other layers of the "
"application:"
msgstr ""

#: ../../../usage/routing/parameters.rst:211
msgid "Declaring parameters on different layers of the application"
msgstr ""

#: ../../../usage/routing/parameters.rst:211
msgid ""
"from typing import Dict, Union\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Controller, Litestar, Router, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    parameters = {\n"
"        \"controller_param\": Parameter(int, lt=100),\n"
"    }\n"
"\n"
"    @get(\"/{path_param:int}\", sync_to_thread=False)\n"
"    def my_handler(\n"
"        self,\n"
"        path_param: int,\n"
"        local_param: str,\n"
"        router_param: str,\n"
"        controller_param: Annotated[int, Parameter(int, lt=50)],\n"
"    ) -> Dict[str, Union[str, int]]:\n"
"        return {\n"
"            \"path_param\": path_param,\n"
"            \"local_param\": local_param,\n"
"            \"router_param\": router_param,\n"
"            \"controller_param\": controller_param,\n"
"        }\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    parameters={\n"
"        \"router_param\": Parameter(str, pattern=\"^[a-zA-Z]$\", "
"header=\"MyHeader\", required=False),\n"
"    },\n"
")\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[router],\n"
"    parameters={\n"
"        \"app_param\": Parameter(str, cookie=\"special-cookie\", "
"required=False),\n"
"    },\n"
")"
msgstr ""

#: ../../../usage/routing/parameters.rst:211
msgid ""
"from typing import Union\n"
"\n"
"from typing import Annotated\n"
"\n"
"from litestar import Controller, Litestar, Router, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    parameters = {\n"
"        \"controller_param\": Parameter(int, lt=100),\n"
"    }\n"
"\n"
"    @get(\"/{path_param:int}\", sync_to_thread=False)\n"
"    def my_handler(\n"
"        self,\n"
"        path_param: int,\n"
"        local_param: str,\n"
"        router_param: str,\n"
"        controller_param: Annotated[int, Parameter(int, lt=50)],\n"
"    ) -> dict[str, Union[str, int]]:\n"
"        return {\n"
"            \"path_param\": path_param,\n"
"            \"local_param\": local_param,\n"
"            \"router_param\": router_param,\n"
"            \"controller_param\": controller_param,\n"
"        }\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    parameters={\n"
"        \"router_param\": Parameter(str, pattern=\"^[a-zA-Z]$\", "
"header=\"MyHeader\", required=False),\n"
"    },\n"
")\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[router],\n"
"    parameters={\n"
"        \"app_param\": Parameter(str, cookie=\"special-cookie\", "
"required=False),\n"
"    },\n"
")"
msgstr ""

#: ../../../usage/routing/parameters.rst:211
msgid ""
"from typing import Annotated\n"
"\n"
"from litestar import Controller, Litestar, Router, get\n"
"from litestar.params import Parameter\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    parameters = {\n"
"        \"controller_param\": Parameter(int, lt=100),\n"
"    }\n"
"\n"
"    @get(\"/{path_param:int}\", sync_to_thread=False)\n"
"    def my_handler(\n"
"        self,\n"
"        path_param: int,\n"
"        local_param: str,\n"
"        router_param: str,\n"
"        controller_param: Annotated[int, Parameter(int, lt=50)],\n"
"    ) -> dict[str, str | int]:\n"
"        return {\n"
"            \"path_param\": path_param,\n"
"            \"local_param\": local_param,\n"
"            \"router_param\": router_param,\n"
"            \"controller_param\": controller_param,\n"
"        }\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    parameters={\n"
"        \"router_param\": Parameter(str, pattern=\"^[a-zA-Z]$\", "
"header=\"MyHeader\", required=False),\n"
"    },\n"
")\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[router],\n"
"    parameters={\n"
"        \"app_param\": Parameter(str, cookie=\"special-cookie\", "
"required=False),\n"
"    },\n"
")"
msgstr ""

#: ../../../usage/routing/parameters.rst:214
msgid ""
"In the above we declare :term:`parameters <parameter>` on the :class:"
"`Litestar app <.app.Litestar>`, :class:`router <.router.Router>`, and :class:"
"`controller <.controller.Controller>` layers in addition to those declared "
"in the route handler. Now, examine these more closely."
msgstr ""

#: ../../../usage/routing/parameters.rst:218
msgid ""
"``app_param`` is a cookie parameter with the key ``special-cookie``. We type "
"it as :class:`str` by passing this as an arg to the :func:`~.params."
"Parameter` function. This is required for us to get typing in the OpenAPI "
"doc. Additionally, this parameter is assumed to be required because it is "
"not explicitly set as ``False`` on :paramref:`~.params.Parameter.required`."
msgstr ""

#: ../../../usage/routing/parameters.rst:223
msgid ""
"This is important because the route handler function does not declare a "
"parameter called ``app_param`` at all, but it will still require this param "
"to be sent as part of the request of validation will fail."
msgstr ""

#: ../../../usage/routing/parameters.rst:226
msgid ""
"``router_param`` is a header parameter with the key ``MyHeader``. Because it "
"is set as ``False`` on :paramref:`~.params.Parameter.required`, it will not "
"fail validation if not present unless explicitly declared by a route handler "
"- and in this case it is."
msgstr ""

#: ../../../usage/routing/parameters.rst:230
msgid ""
"Thus, it is actually required for the router handler function that declares "
"it as an :class:`str` and not an ``str | None``. If a :class:`string <str>` "
"value is provided, it will be tested against the provided regex."
msgstr ""

#: ../../../usage/routing/parameters.rst:232
msgid ""
"``controller_param`` is a query param with the key ``controller_param``. It "
"has an :paramref:`~.params.Parameter.lt` set to ``100`` defined on the "
"controller, which means the provided value must be less than 100."
msgstr ""

#: ../../../usage/routing/parameters.rst:235
msgid ""
"Yet the route handler redeclares it with an :paramref:`~.params.Parameter."
"lt` set to ``50``, which means for the route handler this value must be less "
"than 50."
msgstr ""

#: ../../../usage/routing/parameters.rst:237
msgid ""
"``local_param`` is a route handler local :ref:`query parameter <usage/"
"routing/parameters:query parameters>`, and ``path_param`` is a :ref:`path "
"parameter <usage/routing/parameters:path parameters>`."
msgstr ""

#: ../../../usage/routing/parameters.rst:240
msgid ""
"You cannot declare path :term:`parameters <parameter>` in different "
"application layers. The reason for this is to ensure simplicity - otherwise "
"parameter resolution becomes very difficult to do correctly."
msgstr ""
