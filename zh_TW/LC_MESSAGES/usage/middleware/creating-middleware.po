# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/middleware/creating-middleware.rst:2
msgid "Creating Middleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:4
msgid ""
"As mentioned in :ref:`using middleware <using-middleware>`, a middleware in "
"Litestar is **any callable** that takes a kwarg called ``app``, which is the "
"next ASGI handler, i.e. an :class:`~litestar.types.ASGIApp`, and returns an "
"``ASGIApp``."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:8
msgid "The example previously given was using a factory function, i.e.:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:11
msgid ""
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:25
msgid "Extending ``ASGIMiddleware``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:27
msgid ""
"While using functions is a perfectly viable approach, the recommended way to "
"handle this is by using the :class:`~litestar.middleware.ASGIMiddleware` "
"abstract base class, which also includes functionality to dynamically skip "
"the middleware based on ASGI ``scope[\"type\"]``, handler ``opt`` keys or "
"path patterns and a simple way to pass configuration to middlewares; It does "
"not implement an ``__init__`` method, so subclasses are free to use it to "
"customize the middleware's configuration."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:36
msgid "Modifying Requests and Responses"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:38
msgid ""
"Middlewares can not only be used to execute *around* other ASGI callable, "
"they can also intercept and modify both incoming and outgoing data in a "
"request / response cycle by \"wrapping\" the respective ``receive`` and "
"``send`` ASGI callables."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:42
msgid ""
"The following demonstrates how to add a request timing header with a "
"timestamp to all outgoing responses:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:46
msgid ""
"import time\n"
"\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Message, Receive, Scope, Send\n"
"\n"
"\n"
"class ProcessTimeHeader(ASGIMiddleware):\n"
"    scopes = (ScopeType.HTTP, ScopeType.ASGI)\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: Message) -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await next_app(scope, receive, send_wrapper)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:50
msgid "Configuration constraints"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:52
msgid ""
"While it's good practice to keep middlewares decoupled from another, there "
"are times where implicit coupling is unavoidable due to the nature of the "
"functionality provided by the middlewares."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:56
msgid ""
"For example a caching middleware and an authentication middleware can "
"produce very different results depending on the order they are applied in; "
"Assuming a naive caching middleware that does not take authentication state "
"into account, if it's applied *before* the authentication middleware, it "
"might cache an authenticated response and serve it to the next, "
"unauthenticated request."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:62
msgid ""
"Especially when applications grow larger and more complex, it can become "
"difficult to keep track of all these implicit couplings and dependencies, or "
"downright impossible if the middleware is implemented in a separate package "
"and has no knowledge about how it is being applied."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:67
msgid ""
"To help with this, :class:`~litestar.middleware.ASGIMiddleware` allows to "
"specify a set of :class:`~litestar.middleware.constraints."
"MiddlewareConstraints` - Once configured, these will be validated on "
"application startup."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:71
msgid "Using constraints, the example given above might be solved like this:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:74
msgid ""
"from litestar.middleware.authentication import "
"AbstractAuthenticationMiddleware\n"
"from litestar.middleware.base import ASGIMiddleware\n"
"from litestar.middleware.constraints import MiddlewareConstraints\n"
"\n"
"\n"
"class CachingMiddleware(ASGIMiddleware):\n"
"    constraints = "
"MiddlewareConstraints(after=(AbstractAuthenticationMiddleware,))"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:76
msgid ""
"Here, we specify that every instance of ``CachingMiddleware`` must come "
"after any instance of :class:`~litestar.middleware.authentication."
"AbstractAuthenticationMiddleware`."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:83
msgid ""
"When referencing classes, the constraints always apply to all instances and "
"subclasses of the type"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:88
msgid "Forward references"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:90
msgid ""
"Constraints that reference other middleware can use strings as forward "
"references, to handle situations like circular imports or middlewares from "
"packages that may not be available:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:95
msgid ""
"from litestar.middleware.base import ASGIMiddleware\n"
"from litestar.middleware.constraints import MiddlewareConstraints\n"
"\n"
"\n"
"class SomeMiddleware(ASGIMiddleware):\n"
"    constraints = MiddlewareConstraints().apply_after(\n"
"        \"some_package.some_module.SomeMiddleware\",\n"
"        ignore_import_error=True,\n"
"    )"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:97
msgid ""
"This forward reference will try to import ``SomeMiddleware`` from "
"``some_package.some_module``. With ``ignore_import_error=True``, if the "
"import is not successful, the constraint will be ignored."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:103
msgid "Middleware order"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:105
msgid ""
"For order constraints (``before``, ``after``, ``first``, ``last``), it is "
"important to note that the order is defined in terms of proximity to the "
"location. In practice, this means that a middleware that has set "
"``first=True`` must be the *first* middleware on the *first* layer (i.e. the "
"application), and a middleware setting ``last=True`` must be the *last* "
"middleware on the *last* layer (i.e. the route handler)."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:112
msgid ""
"@get(\"/\", middleware=[FifthMiddleware, SixthMiddleware])\n"
"async def handler() -> None:\n"
"    pass\n"
"\n"
"router = Router(\n"
"    \"/\",\n"
"    [handler],\n"
"    middleware=[\n"
"        ThirdMiddleware(),\n"
"        FourthMiddleware()\n"
"    ]\n"
")\n"
"\n"
"app = Litestar(\n"
"    middleware=[\n"
"        FirstMiddleware(),\n"
"        SecondMiddleware()\n"
"    ]\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:134
msgid "Constraints and plugins"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:136
msgid ""
"When using plugins that add middleware(s), it is important to understand "
"that these middleware(s) are added *after* middlewares defined on the "
"application and *before* middlewares defined on the other layers."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:139
msgid ""
"Constraints are evaluated after all middlewares have been added though, so "
"an order constraint on a middleware added by a plugin has to take into "
"account the position it is being added to."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:142
msgid ""
"Most of the time in a plugin you would do ``app_config.middleware."
"append(MyCustomMiddleware)`` which will be ok if it has no constraints "
"attached."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:145
msgid ""
"Now suppose that ``MyCustomMiddleware`` has the constraint ``first=True`` "
"then the correct way to add it is to do ``app_config.middleware.insert(0, "
"MyCustomMiddleware())`` so that it is the first middleware in the stack."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:150
msgid "Migrating from ``MiddlewareProtocol`` / ``AbstractMiddleware``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:152
msgid ""
":class:`~litestar.middleware.ASGIMiddleware` was introduced in Litestar "
"2.15. If you've been using ``MiddlewareProtocol`` / ``AbstractMiddleware`` "
"to implement your middlewares before, there's a simple migration path to "
"using ``ASGIMiddleware``."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:156
msgid "**From MiddlewareProtocol**"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:163
msgid ""
"from litestar.middleware import MiddlewareProtocol\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do stuff\n"
"        await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "ASGIMiddleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:168
msgid ""
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(ASGIMiddleware):\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        # do stuff\n"
"        await next_app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:172
msgid "**From AbstractMiddleware**"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:179
msgid ""
"import anyio\n"
"\n"
"from litestar import Litestar\n"
"from litestar.middleware import AbstractMiddleware, DefineMiddleware\n"
"from litestar.types import ASGIApp, Receive, Scope, Scopes, Send\n"
"\n"
"\n"
"class TimeoutMiddleware(AbstractMiddleware):\n"
"    def __init__(\n"
"        self,\n"
"        app: ASGIApp,\n"
"        timeout: float,\n"
"        exclude: str | list[str] | None = None,\n"
"        exclude_opt_key: str | None = None,\n"
"        scopes: Scopes | None = None,\n"
"    ):\n"
"        self.timeout = timeout\n"
"        super().__init__(app=app, exclude=exclude, "
"exclude_opt_key=exclude_opt_key, scopes=scopes)\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        with anyio.move_on_after(self.timeout):\n"
"            await self.app(scope, receive, send)\n"
"\n"
"\n"
"app = Litestar(\n"
"    middleware=[\n"
"        DefineMiddleware(\n"
"            TimeoutMiddleware,\n"
"            timeout=5,\n"
"        )\n"
"    ]\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:184
msgid ""
"import anyio\n"
"\n"
"from litestar import Litestar\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"class TimeoutMiddleware(ASGIMiddleware):\n"
"    def __init__(self, timeout: float):\n"
"        self.timeout = timeout\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        with anyio.move_on_after(self.timeout):\n"
"            await next_app(scope, receive, send)\n"
"\n"
"\n"
"app = Litestar(middleware=[TimeoutMiddleware(timeout=5)])"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:192
msgid "Using MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:194
msgid ""
"The :class:`~litestar.middleware.base.MiddlewareProtocol` class is a `PEP "
"544 Protocol <https://peps.python.org/pep-0544/>`_ that specifies the "
"minimal implementation of a middleware as follows:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:199
msgid ""
"from typing import Protocol, Any\n"
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"class MiddlewareProtocol(Protocol):\n"
"    def __init__(self, app: ASGIApp, **kwargs: Any) -> None: ...\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None: ..."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:209
msgid ""
"The ``__init__`` method receives and sets \"app\". *It's important to "
"understand* that app is not an instance of Litestar in this case, but rather "
"the next middleware in the stack, which is also an ASGI app."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:212
msgid ""
"The ``__call__`` method makes this class into a ``callable``, i.e. once "
"instantiated this class acts like a function, that has the signature of an "
"ASGI app: The three parameters, ``scope, receive, send`` are specified by "
"`the ASGI specification <https://asgi.readthedocs.io/en/latest/index."
"html>`_, and their values originate with the ASGI server (e.g. "
"``uvicorn``\\ ) used to run Litestar."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:217
msgid ""
"To use this protocol as a basis, simply subclass it - as you would any other "
"class, and implement the two methods it specifies:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:221
msgid ""
"import logging\n"
"\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"from litestar import Request\n"
"from litestar.middleware.base import MiddlewareProtocol\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"class MyRequestLoggingMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:  # can have other parameters "
"as well\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if scope[\"type\"] == \"http\":\n"
"            request = Request(scope)\n"
"            logger.info(\"Got request: %s - %s\", request.method, request."
"url)\n"
"        await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:243
msgid ""
"Although ``scope`` is used to create an instance of request by passing it to "
"the :class:`~litestar.connection.Request` constructor, which makes it "
"simpler to access because it does some parsing for you already, the actual "
"source of truth remains ``scope`` - not the request. If you need to modify "
"the data of the request you must modify the scope object, not any ephemeral "
"request objects created as in the above."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:250
msgid "Responding using the MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:252
msgid ""
"Once a middleware finishes doing whatever its doing, it should pass "
"``scope``, ``receive``, and ``send`` to an ASGI app and await it. This is "
"what's happening in the above example with: ``await self.app(scope, receive, "
"send)``. Let's explore another example - redirecting the request to a "
"different url from a middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:257
msgid ""
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"from litestar.response.redirect import ASGIRedirectResponse\n"
"from litestar import Request\n"
"from litestar.middleware.base import MiddlewareProtocol\n"
"\n"
"\n"
"class RedirectMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if Request(scope).session is None:\n"
"            response = ASGIRedirectResponse(path=\"/login\")\n"
"            await response(scope, receive, send)\n"
"        else:\n"
"            await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:276
msgid ""
"As you can see in the above, given some condition (``request.session`` being "
"``None``) we create a :class:`~litestar.response.redirect."
"ASGIRedirectResponse` and then await it. Otherwise, we await ``self.app``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:280
msgid "Modifying ASGI Requests and Responses using the MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:284
msgid ""
"If you'd like to modify a :class:`~litestar.response.Response` object after "
"it was created for a route handler function but before the actual response "
"message is transmitted, the correct place to do this is using the special "
"life-cycle hook called :ref:`after_request <after_request>`. The "
"instructions in this section are for how to modify the ASGI response message "
"itself, which is a step further in the response process."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:289
msgid ""
"Using the :class:`~litestar.middleware.base.MiddlewareProtocol` you can "
"intercept and modifying both the incoming and outgoing data in a request / "
"response cycle by \"wrapping\" that respective ``receive`` and ``send`` ASGI "
"functions."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:293
msgid ""
"To demonstrate this, let's say we want to append a header with a timestamp "
"to all outgoing responses. We could achieve this by doing the following:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:297
msgid ""
"import time\n"
"\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.types import Message, Receive, Scope, Send\n"
"from litestar.middleware.base import MiddlewareProtocol\n"
"from litestar.types import ASGIApp\n"
"\n"
"\n"
"class ProcessTimeHeader(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        super().__init__(app)\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if scope[\"type\"] == \"http\":\n"
"            start_time = time.monotonic()\n"
"\n"
"            async def send_wrapper(message: Message) -> None:\n"
"                if message[\"type\"] == \"http.response.start\":\n"
"                    process_time = time.monotonic() - start_time\n"
"                    headers = MutableScopeHeaders."
"from_message(message=message)\n"
"                    headers[\"X-Process-Time\"] = str(process_time)\n"
"                await send(message)\n"
"\n"
"            await self.app(scope, receive, send_wrapper)\n"
"        else:\n"
"            await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:327
msgid "Inheriting AbstractMiddleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:329
msgid ""
"Litestar offers an :class:`~litestar.middleware.base.AbstractMiddleware` "
"class that can be extended to create middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:333
msgid ""
"import time\n"
"\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import AbstractMiddleware\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.types import Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(AbstractMiddleware):\n"
"    scopes = {ScopeType.HTTP}\n"
"    exclude = [\"first_path\", \"second_path\"]\n"
"    exclude_opt_key = \"exclude_from_middleware\"\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await self.app(scope, receive, send_wrapper)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:359
msgid ""
"The three class variables defined in the above example ``scopes``, "
"``exclude``, and ``exclude_opt_key`` can be used to fine-tune for which "
"routes and request types the middleware is called:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:363
msgid ""
"The scopes variable is a set that can include either or both : ``ScopeType."
"HTTP`` and ``ScopeType.WEBSOCKET`` , with the default being both."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:364
msgid ""
"``exclude`` accepts either a single string or list of strings that are "
"compiled into a regex against which the request's ``path`` is checked."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:365
msgid ""
"``exclude_opt_key`` is the key to use for in a route handler's :class:"
"`Router.opt <litestar.router.Router>` dict for a boolean, whether to omit "
"from the middleware."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:367
msgid ""
"Thus, in the following example, the middleware will only run against the "
"handler called ``not_excluded_handler`` for ``/greet`` route:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:370
msgid ""
"import time\n"
"\n"
"from litestar import Litestar, WebSocket, get, websocket\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(ASGIMiddleware):\n"
"    scopes = (ScopeType.HTTP,)\n"
"    exclude_path_pattern = (\"first_path\", \"second_path\")\n"
"    exclude_opt_key = \"exclude_from_my_middleware\"\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await next_app(scope, receive, send_wrapper)\n"
"\n"
"\n"
"@websocket(\"/my-websocket\")\n"
"async def websocket_handler(socket: WebSocket) -> None:\n"
"    \"\"\"\n"
"    Websocket handler - is excluded because the middleware scopes includes "
"'ScopeType.HTTP'\n"
"    \"\"\"\n"
"    await socket.accept()\n"
"    await socket.send_json({\"hello\": \"websocket\"})\n"
"    await socket.close()\n"
"\n"
"\n"
"@get(\"/first_path\", sync_to_thread=False)\n"
"def first_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"first_path\"."
"\"\"\"\n"
"    return {\"hello\": \"first\"}\n"
"\n"
"\n"
"@get(\"/second_path\", sync_to_thread=False)\n"
"def second_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"second_path\"."
"\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/third_path\", exclude_from_my_middleware=True, "
"sync_to_thread=False)\n"
"def third_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to the opt key "
"'exclude_from_my_middleware' matching the middleware 'exclude_opt_key'."
"\"\"\"\n"
"    return {\"hello\": \"third\"}\n"
"\n"
"\n"
"@get(\"/greet\", sync_to_thread=False)\n"
"def not_excluded_handler() -> dict[str, str]:\n"
"    \"\"\"This handler is not excluded, and thus the middleware will execute "
"on every incoming request to it.\"\"\"\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[\n"
"        websocket_handler,\n"
"        first_handler,\n"
"        second_handler,\n"
"        third_handler,\n"
"        not_excluded_handler,\n"
"    ],\n"
"    middleware=[MyMiddleware()],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:374
msgid ""
"Using ``/`` as an exclude pattern, will disable this middleware for all "
"routes, since, as a regex, it matches *every* path"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:379
msgid "Using DefineMiddleware to pass arguments"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:381
msgid ""
"Litestar offers a simple way to pass positional arguments (``*args``) and "
"keyword arguments (``**kwargs``) to middleware using the :class:`~litestar."
"middleware.base.DefineMiddleware` class. Let's extend the factory function "
"used in the examples above to take some args and kwargs and then use "
"``DefineMiddleware`` to pass these values to our middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:387
msgid ""
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"from litestar import Litestar\n"
"from litestar.middleware import DefineMiddleware\n"
"\n"
"\n"
"def middleware_factory(my_arg: int, *, app: ASGIApp, my_kwarg: str) -> "
"ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # here we can use my_arg and my_kwarg for some purpose\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[...],\n"
"    middleware=[DefineMiddleware(middleware_factory, 1, my_kwarg=\"abc\")],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:407
msgid ""
"The ``DefineMiddleware`` is a simple container - it takes a middleware "
"callable as a first parameter, and then any positional arguments, followed "
"by key word arguments. The middleware callable will be called with these "
"values as well as the kwarg ``app`` as mentioned above."
msgstr ""
