# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/security/abstract-authentication-middleware.rst:2
msgid "AbstractAuthenticationMiddleware"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:4
msgid ""
"Starlite exports :class:`AbstractAuthenticationMiddleware <.middleware."
"authentication.AbstractAuthenticationMiddleware>`, which is an Abstract Base "
"Class (ABC) that implements the :class:`MiddlewareProtocol <.middleware.base."
"MiddlewareProtocol>`. To add authentication to your app using this class as "
"a basis, subclass it and implement the abstract method :meth:"
"`authenticate_request <.middleware.authentication."
"AbstractAuthenticationMiddleware.authenticate_request>`:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:10
msgid ""
"from starlite import (\n"
"    AbstractAuthenticationMiddleware,\n"
"    AuthenticationResult,\n"
"    ASGIConnection,\n"
")\n"
"\n"
"\n"
"class MyAuthenticationMiddleware(AbstractAuthenticationMiddleware):\n"
"    async def authenticate_request(\n"
"        self, connection: ASGIConnection\n"
"    ) -> AuthenticationResult:\n"
"        # do something here.\n"
"        ..."
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:25
msgid ""
"As you can see, ``authenticate_request`` is an async function that receives "
"a connection instance and is supposed to return an :class:"
"`AuthenticationResult <.middleware.authentication.AuthenticationResult>` "
"instance, which is a pydantic model that has two attributes:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:29
msgid ""
"``user``: a non-optional value representing a user. It's typed as ``Any`` so "
"it receives any value, including ``None``."
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:30
msgid ""
"``auth``: an optional value representing the authentication scheme. Defaults "
"to ``None``."
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:32
msgid ""
"These values are then set as part of the \"scope\" dictionary, and they are "
"made available as :attr:`Request.user <.connection.request.Request.user>` "
"and :attr:`Request.auth <.connection.request.Request.auth>` respectively, "
"for HTTP route handlers, and :attr:`WebSocket.user <.connection.websocket."
"WebSocket.user>` and :attr:`WebSocket.auth <.connection.websocket.WebSocket."
"auth>` for websocket route handlers."
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:39
msgid "Example: Implementing a JWTAuthenticationMiddleware"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:41
msgid ""
"Since the above is quite hard to grasp in the abstract, lets see an example."
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:43
msgid ""
"We start off by creating a user model. It can be implemented using pydantic, "
"and ODM, ORM etc. For the sake of the example here lets say it's a pydantic "
"model:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:47
msgid "my_app/db/models.py"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:47
msgid ""
"import uuid\n"
"\n"
"from sqlalchemy import Column\n"
"from sqlalchemy.dialects.postgresql import UUID\n"
"from sqlalchemy.orm import declarative_base\n"
"\n"
"Base = declarative_base()\n"
"\n"
"\n"
"class User(Base):\n"
"    id: uuid.UUID | None = Column(\n"
"        UUID(as_uuid=True), default=uuid.uuid4, primary_key=True\n"
"    )\n"
"    # ... other fields follow, but we only require id for this example"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:66
msgid ""
"We will also need some utility methods to encode and decode tokens. To this "
"end we will use the `python-jose <https://github.com/mpdavis/python-jose>`_ "
"library. We will also create a pydantic model representing a JWT Token:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:71
msgid "my_app/security/jwt.py"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:71
msgid ""
"from datetime import datetime, timedelta\n"
"from uuid import UUID\n"
"\n"
"from jose import JWTError, jwt\n"
"from pydantic import BaseModel, UUID4\n"
"from starlite.exceptions import NotAuthorizedException\n"
"\n"
"from app.config import settings\n"
"\n"
"DEFAULT_TIME_DELTA = timedelta(days=1)\n"
"ALGORITHM = \"HS256\"\n"
"\n"
"\n"
"class Token(BaseModel):\n"
"    exp: datetime\n"
"    iat: datetime\n"
"    sub: UUID4\n"
"\n"
"\n"
"def decode_jwt_token(encoded_token: str) -> Token:\n"
"    \"\"\"\n"
"    Helper function that decodes a jwt token and returns the value stored "
"under the ``sub`` key\n"
"\n"
"    If the token is invalid or expired (i.e. the value stored under the exp "
"key is in the past) an exception is raised\n"
"    \"\"\"\n"
"    try:\n"
"        payload = jwt.decode(\n"
"            token=encoded_token, key=settings.JWT_SECRET, "
"algorithms=[ALGORITHM]\n"
"        )\n"
"        return Token(**payload)\n"
"    except JWTError as e:\n"
"        raise NotAuthorizedException(\"Invalid token\") from e\n"
"\n"
"\n"
"def encode_jwt_token(user_id: UUID, expiration: timedelta = "
"DEFAULT_TIME_DELTA) -> str:\n"
"    \"\"\"Helper function that encodes a JWT token with expiration and a "
"given user_id\"\"\"\n"
"    token = Token(\n"
"        exp=datetime.now() + expiration,\n"
"        iat=datetime.now(),\n"
"        sub=user_id,\n"
"    )\n"
"    return jwt.encode(token.dict(), settings.JWT_SECRET, algorithm=ALGORITHM)"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:116
msgid "We can now create our authentication middleware:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:119
msgid "my_app/security/authentication_middleware.py"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:119
msgid ""
"from typing import cast, TYPE_CHECKING\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from starlite import (\n"
"    AbstractAuthenticationMiddleware,\n"
"    AuthenticationResult,\n"
"    NotAuthorizedException,\n"
"    ASGIConnection,\n"
")\n"
"\n"
"from app.db.models import User\n"
"from app.security.jwt import decode_jwt_token\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.ext.asyncio import AsyncEngine\n"
"\n"
"API_KEY_HEADER = \"X-API-KEY\"\n"
"\n"
"\n"
"class JWTAuthenticationMiddleware(AbstractAuthenticationMiddleware):\n"
"    async def authenticate_request(\n"
"        self, connection: ASGIConnection\n"
"    ) -> AuthenticationResult:\n"
"        \"\"\"\n"
"        Given a request, parse the request api key stored in the header and "
"retrieve the user correlating to the token from the DB\n"
"        \"\"\"\n"
"\n"
"        # retrieve the auth header\n"
"\n"
"    auth_header = connection.headers.get(API_KEY_HEADER)\n"
"    if not auth_header:\n"
"        raise NotAuthorizedException()\n"
"\n"
"    # decode the token, the result is a ``Token`` model instance\n"
"    token = decode_jwt_token(encoded_token=auth_header)\n"
"\n"
"    engine = cast(\"AsyncEngine\", connection.app.state."
"postgres_connection)\n"
"    async with AsyncSession(engine) as async_session:\n"
"        async with async_session.begin():\n"
"            user = await async_session.execute(select(User).where(User.id == "
"token.sub))\n"
"    if not user:\n"
"        raise NotAuthorizedException()\n"
"    return AuthenticationResult(user=user, auth=token)"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:167
msgid "Finally, we need to pass our middleware to the Starlite constructor:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:170
msgid "my_app/main.py"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:170
msgid ""
"from starlite import Starlite\n"
"from starlite.middleware.base import DefineMiddleware\n"
"\n"
"from my_app.security.authentication_middleware import "
"JWTAuthenticationMiddleware\n"
"\n"
"# you can optionally exclude certain paths from authentication.\n"
"# the following excludes all routes mounted at or under `/schema*`\n"
"auth_mw = DefineMiddleware(JWTAuthenticationMiddleware, exclude=\"schema\")\n"
"\n"
"app = Starlite(request_handlers=[...], middleware=[auth_mw])"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:183
msgid ""
"That's it. The ``JWTAuthenticationMiddleware`` will now run for every "
"request, and we would be able to access these in a http route handler in the "
"following way:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:187
msgid ""
"from starlite import Request, get\n"
"\n"
"from my_app.db.models import User\n"
"from my_app.security.jwt import Token\n"
"\n"
"\n"
"@get(\"/\")\n"
"def my_route_handler(request: Request[User, Token]) -> None:\n"
"    user = request.user  # correctly typed as User\n"
"    auth = request.auth  # correctly typed as Token\n"
"    assert isinstance(user, User)\n"
"    assert isinstance(auth, Token)"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:201
msgid "Or for a websocket route:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:204
msgid ""
"from starlite import WebSocket, websocket\n"
"\n"
"from my_app.db.models import User\n"
"from my_app.security.jwt import Token\n"
"\n"
"\n"
"@websocket(\"/\")\n"
"async def my_route_handler(socket: WebSocket[User, Token]) -> None:\n"
"    user = socket.user  # correctly typed as User\n"
"    auth = socket.auth  # correctly typed as Token\n"
"    assert isinstance(user, User)\n"
"    assert isinstance(auth, Token)"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:218
msgid ""
"And if you'd like to exclude individual routes outside those configured:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:221
msgid ""
"import anyio\n"
"from starlite import Starlite, MediaType, NotFoundException, Response, get\n"
"from starlite.middleware.base import DefineMiddleware\n"
"\n"
"from my_app.security.authentication_middleware import "
"JWTAuthenticationMiddleware\n"
"\n"
"# you can optionally exclude certain paths from authentication.\n"
"# the following excludes all routes mounted at or under `/schema*`\n"
"# additionally,\n"
"# you can modify the default exclude key of \"exclude_from_auth\", by "
"overriding the `exclude_from_auth_key` parameter on the Authentication "
"Middleware\n"
"auth_mw = DefineMiddleware(JWTAuthenticationMiddleware, exclude=\"schema\")\n"
"\n"
"\n"
"@get(path=\"/\", exclude_from_auth=True)\n"
"async def site_index() -> Response:\n"
"    \"\"\"Site index\"\"\"\n"
"    exists = await anyio.Path(\"index.html\").exists()\n"
"    if exists:\n"
"        async with await anyio.open_file(anyio.Path(\"index.html\")) as "
"file:\n"
"            content = await file.read()\n"
"            return Response(content=content, status_code=200, "
"media_type=MediaType.HTML)\n"
"    raise NotFoundException(\"Site index was not found\")\n"
"\n"
"\n"
"app = Starlite(route_handlers=[site_index], middleware=[auth_mw])"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:248
msgid "And of course use the same kind of mechanism for dependencies:"
msgstr ""

#: ../../../usage/security/abstract-authentication-middleware.rst:251
msgid ""
"from typing import Any\n"
"\n"
"from starlite import Request, Provide, Router\n"
"\n"
"from my_app.db.models import User\n"
"from my_app.security.jwt import Token\n"
"\n"
"\n"
"async def my_dependency(request: Request[User, Token]) -> Any:\n"
"    user = request.user  # correctly typed as User\n"
"    auth = request.auth  # correctly typed as Token\n"
"    assert isinstance(user, User)\n"
"    assert isinstance(auth, Token)\n"
"\n"
"\n"
"my_router = Router(\n"
"    path=\"sub-path/\", dependencies={\"some_dependency\": "
"Provide(my_dependency)}\n"
")"
msgstr ""
