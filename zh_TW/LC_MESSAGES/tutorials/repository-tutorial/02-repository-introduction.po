# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:2
msgid "Interacting with repositories"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:3
msgid ""
"Now that we've covered the modelling basics, we are able to create our first "
"repository class.  The repository classes include all of the standard CRUD "
"operations as well as a few advanced features such as pagination, filtering "
"and bulk operations."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:7
msgid ""
"The full code for this tutorial can be found below in the :ref:`Full Code "
"<02-repo-full-code>` section."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:9
msgid ""
"Before we jump in to the code, let's take a look at the available functions "
"available in the the synchronous and asynchronous repositories."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:0
msgid "Available Functions in the Repositories"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:15
msgid "Function"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:15
msgid "Category"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:15
msgid "Description"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:17
msgid "``get``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:17
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:19
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:21
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:23
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:25
msgid "Selecting Data"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:17
msgid ""
"Select a single record by primary key. Raises an exception when no record is "
"found."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:19
msgid "``get_one``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:19
msgid ""
"Select a single record specified by the ``kwargs`` parameters. Raises an "
"exception when no record is found."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:21
msgid "``get_one_or_none``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:21
msgid ""
"Select a single record specified by the ``kwargs`` parameters. Returns "
"``None`` when no record is found."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:23
msgid "``list``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:23
msgid ""
"Select a list of records specified by the ``kwargs`` parameters. Optionally "
"it can be filtered by the included ``FilterTypes`` args."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:25
msgid "``list_and_count``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:25
msgid ""
"Select a list of records specified by the ``kwargs`` parameters. Optionally "
"it can be filtered by the included ``FilterTypes`` args. Results are "
"returned as a 2 value tuple that includes the rows selected and the total "
"count of records."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:27
msgid "``get_or_create``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:27
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:29
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:31
msgid "Creating Data"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:27
msgid ""
"Select a single record specified by the the ``kwargs`` parameters.  If no "
"record is found, one is created with the given values.  There's an optional "
"attribute to filter on a subset of the supplied parameters and to merge "
"updates."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:29
msgid "``create``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:29
msgid "Create a new record in the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:31
msgid "``create_many``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:31
msgid "Create one or more rows in the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:33
msgid "``update``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:33
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:35
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:37
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:39
msgid "Updating Data"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:33
msgid "Update an existing record in the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:35
msgid "``update_many``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:35
msgid "Update one or more rows in the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:37
msgid "``upsert``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:37
msgid ""
"A single operation that updates or inserts a record based whether or not the "
"primary key value on the model object is populated."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:39
msgid "``upsert_many``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:39
msgid ""
"Updates or inserts multiple records based whether or not the primary key "
"value on the model object is populated."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:41
msgid "``delete``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:41
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:43
msgid "Removing Data"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:41
msgid "Remove a single record from the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:43
msgid "``delete_many``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:43
msgid "Remove one or more records from the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:48
msgid ""
"All three of the bulk DML operations will leverage dialect-specific "
"enhancements to be as efficient as possible. In addition to using efficient "
"bulk inserts binds, the repository will optionally leverage the multi-row "
"``RETURNING`` support where possible. The repository will automatically "
"detect this support from the SQLAlchemy driver, so no additional interaction "
"is required to enable this."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:54
msgid ""
"SQL engines generally have a limit to the number of elements that can be "
"appended into an `IN` clause. The repository operations will automatically "
"break lists that exceed this limit into multiple queries that are "
"concatenated together before return. You do not need to account for this in "
"your own code."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:59
msgid ""
"In the following examples, we'll cover a few ways that you can use the "
"repository within your applications."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:63
msgid "Model Repository"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:65
msgid ""
"Here we import the :class:`SQLAlchemyAsyncRepository <advanced_alchemy."
"repository.SQLAlchemyAsyncRepository>` class and create an "
"``AuthorRepository`` repository class. This is all that's required to "
"include all of the integrated repository features."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:71
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:90
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:105
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:113
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:121
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:147
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:172
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:186
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:199
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:210
#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:227
msgid "``app.py``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:71
msgid ""
"from rich import get_console\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar.plugins.sqlalchemy import base, repository\n"
"\n"
"console = get_console()\n"
"\n"
"\n"
"# the SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `Base` class includes a `UUID` based primary key (`id`)\n"
"class Author(base.UUIDBase):\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date]\n"
"    dod: Mapped[date | None]\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemyAsyncRepository[Author]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = Author"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:77
msgid "Repository Context Manager"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:79
msgid ""
"Since we'll be using the repository outside of a Litestar application in "
"this script, we'll make a simple context manager to automatically handle the "
"creation (and cleanup) of our Author repository."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:83
msgid "The ``repository_factory`` method will do the following for us:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:84
msgid ""
"Automatically create a new DB session from the SQLAlchemy configuration."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:85
msgid "Rollback session when any exception occurs."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:86
msgid "Automatically commit after function call completes."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:90
msgid ""
"# let's make a simple context manager as an example here.\n"
"@asynccontextmanager\n"
"async def repository_factory() -> AsyncIterator[AuthorRepository]:\n"
"    async with session_factory() as db_session:\n"
"        try:\n"
"            yield AuthorRepository(session=db_session)\n"
"        except Exception:  # noqa: BLE001\n"
"            await db_session.rollback()\n"
"        else:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:97
msgid "Creating, Updating and Removing Data"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:99
msgid ""
"To illustrate a few ways you can manipulate data in your database, we'll go "
"through the various CRUD operations:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:102
msgid ""
"Creating Data: Here's a simple insert operation to populate our new Author "
"table:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:105
msgid ""
"    async with repository_factory() as repo:\n"
"        obj = await repo.add(\n"
"            Author(\n"
"                name=\"F. Scott Fitzgerald\",\n"
"                dob=datetime.strptime(\"1896-09-24\", \"%Y-%m-%d\").date(),\n"
"            )\n"
"        )\n"
"        console.print(f\"Created Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:110
msgid ""
"Updating Data: The ``update`` method will ensure any updates made to the "
"model object are executed on the database:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:113
msgid ""
"    async with repository_factory() as repo:\n"
"        obj = await repo.update(obj)\n"
"        console.print(f\"Updated Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:118
msgid ""
"Removing Data: The ``delete`` method accepts the primary key of the row you "
"want to delete:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:121
msgid ""
"    async with repository_factory() as repo:\n"
"        obj = await repo.delete(id)\n"
"        console.print(f\"Deleted Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:126
msgid ""
"Now that we've seen how to do single-row operations, let's look at the bulk "
"methods we can use."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:131
msgid "Working with Bulk Data Operations"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:132
msgid ""
"In this section, we delve into the powerful capabilities of the repository "
"classes for handling bulk data operations. Our example illustrates how we "
"can efficiently manage data in our database. Specifically, we'll use a JSON "
"file containing information about US states and their abbreviations."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:137
msgid "Here's what we're going to cover:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:140
msgid "Fixture Data Loading"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:142
msgid ""
"We will introduce a method for loading fixture data. Fixture data is sample "
"data that populates your database and helps test the behavior of your "
"application under realistic conditions. This pattern can be extended and "
"adjusted to meet your needs."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:147
msgid ""
"import json\n"
"from pathlib import Path\n"
"from typing import Any\n"
"\n"
"\n"
"def open_fixture(fixtures_path: Path, fixture_name: str) -> Any:\n"
"    \"\"\"Loads JSON file with the specified fixture name\n"
"\n"
"    Args:\n"
"        fixtures_path (Path): The path to look for fixtures\n"
"        fixture_name (str): The fixture name to load.\n"
"\n"
"    Raises:\n"
"        FileNotFoundError: Fixtures not found.\n"
"\n"
"    Returns:\n"
"        Any: The parsed JSON data\n"
"    \"\"\"\n"
"    fixture = Path(fixtures_path / f\"{fixture_name}.json\")\n"
"    if fixture.exists():\n"
"        with fixture.open(mode=\"r\", encoding=\"utf-8\") as f:\n"
"            f_data = f.read()\n"
"        return json.loads(f_data)\n"
"    raise FileNotFoundError(f\"Could not find the {fixture_name} fixture\")"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:152
msgid "You can review the JSON source file here:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:0
msgid "US State Lookup JSON"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:156
msgid ""
"You can download it: :download:`/examples/contrib/sqlalchemy/us_state_lookup."
"json` or view below:"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:159
msgid "``us_state_lookup.json``"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:159
msgid ""
"[\n"
"  {\n"
"    \"name\": \"Alabama\",\n"
"    \"abbreviation\": \"AL\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Alaska\",\n"
"    \"abbreviation\": \"AK\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Arizona\",\n"
"    \"abbreviation\": \"AZ\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Arkansas\",\n"
"    \"abbreviation\": \"AR\"\n"
"  },\n"
"  {\n"
"    \"name\": \"California\",\n"
"    \"abbreviation\": \"CA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Colorado\",\n"
"    \"abbreviation\": \"CO\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Connecticut\",\n"
"    \"abbreviation\": \"CT\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Delaware\",\n"
"    \"abbreviation\": \"DE\"\n"
"  },\n"
"  {\n"
"    \"name\": \"District Of Columbia\",\n"
"    \"abbreviation\": \"DC\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Florida\",\n"
"    \"abbreviation\": \"FL\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Georgia\",\n"
"    \"abbreviation\": \"GA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Guam\",\n"
"    \"abbreviation\": \"GU\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Hawaii\",\n"
"    \"abbreviation\": \"HI\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Idaho\",\n"
"    \"abbreviation\": \"ID\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Illinois\",\n"
"    \"abbreviation\": \"IL\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Indiana\",\n"
"    \"abbreviation\": \"IN\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Iowa\",\n"
"    \"abbreviation\": \"IA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Kansas\",\n"
"    \"abbreviation\": \"KS\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Kentucky\",\n"
"    \"abbreviation\": \"KY\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Louisiana\",\n"
"    \"abbreviation\": \"LA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Maine\",\n"
"    \"abbreviation\": \"ME\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Maryland\",\n"
"    \"abbreviation\": \"MD\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Massachusetts\",\n"
"    \"abbreviation\": \"MA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Michigan\",\n"
"    \"abbreviation\": \"MI\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Minnesota\",\n"
"    \"abbreviation\": \"MN\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Mississippi\",\n"
"    \"abbreviation\": \"MS\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Missouri\",\n"
"    \"abbreviation\": \"MO\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Montana\",\n"
"    \"abbreviation\": \"MT\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Nebraska\",\n"
"    \"abbreviation\": \"NE\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Nevada\",\n"
"    \"abbreviation\": \"NV\"\n"
"  },\n"
"  {\n"
"    \"name\": \"New Hampshire\",\n"
"    \"abbreviation\": \"NH\"\n"
"  },\n"
"  {\n"
"    \"name\": \"New Jersey\",\n"
"    \"abbreviation\": \"NJ\"\n"
"  },\n"
"  {\n"
"    \"name\": \"New Mexico\",\n"
"    \"abbreviation\": \"NM\"\n"
"  },\n"
"  {\n"
"    \"name\": \"New York\",\n"
"    \"abbreviation\": \"NY\"\n"
"  },\n"
"  {\n"
"    \"name\": \"North Carolina\",\n"
"    \"abbreviation\": \"NC\"\n"
"  },\n"
"  {\n"
"    \"name\": \"North Dakota\",\n"
"    \"abbreviation\": \"ND\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Ohio\",\n"
"    \"abbreviation\": \"OH\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Oklahoma\",\n"
"    \"abbreviation\": \"OK\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Oregon\",\n"
"    \"abbreviation\": \"OR\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Palau\",\n"
"    \"abbreviation\": \"PW\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Pennsylvania\",\n"
"    \"abbreviation\": \"PA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Puerto Rico\",\n"
"    \"abbreviation\": \"PR\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Rhode Island\",\n"
"    \"abbreviation\": \"RI\"\n"
"  },\n"
"  {\n"
"    \"name\": \"South Carolina\",\n"
"    \"abbreviation\": \"SC\"\n"
"  },\n"
"  {\n"
"    \"name\": \"South Dakota\",\n"
"    \"abbreviation\": \"SD\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Tennessee\",\n"
"    \"abbreviation\": \"TN\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Texas\",\n"
"    \"abbreviation\": \"TX\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Utah\",\n"
"    \"abbreviation\": \"UT\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Vermont\",\n"
"    \"abbreviation\": \"VT\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Virginia\",\n"
"    \"abbreviation\": \"VA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Washington\",\n"
"    \"abbreviation\": \"WA\"\n"
"  },\n"
"  {\n"
"    \"name\": \"West Virginia\",\n"
"    \"abbreviation\": \"WV\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Wisconsin\",\n"
"    \"abbreviation\": \"WI\"\n"
"  },\n"
"  {\n"
"    \"name\": \"Wyoming\",\n"
"    \"abbreviation\": \"WY\"\n"
"  }\n"
"]\n"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:165
msgid "Bulk Insert"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:167
msgid ""
"We'll use our fixture data to demonstrate a bulk insert operation. This "
"operation allows you to add multiple records to your database in a single "
"transaction, improving performance when working with larger data sets."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:172
msgid ""
"from rich import get_console\n"
"from sqlalchemy import create_engine\n"
"from sqlalchemy.orm import Mapped, Session, sessionmaker\n"
"\n"
"from litestar.plugins.sqlalchemy import base, repository\n"
"\n"
"console = get_console()\n"
"\n"
"\n"
"class USState(base.UUIDBase):\n"
"    __tablename__ = \"us_state_lookup\"  # type: ignore[assignment]\n"
"    abbreviation: Mapped[str]\n"
"    name: Mapped[str]\n"
"\n"
"\n"
"class USStateRepository(repository.SQLAlchemySyncRepository[USState]):\n"
"    \"\"\"US State repository.\"\"\"\n"
"\n"
"    model_type = USState\n"
"\n"
"\n"
"engine = create_engine(\n"
"    \"duckdb:///:memory:\",\n"
"    future=True,\n"
")\n"
"session_factory: sessionmaker[Session] = sessionmaker(engine, "
"expire_on_commit=False)\n"
"\n"
"\n"
"def run_script() -> None:\n"
"    \"\"\"Load data from a fixture.\"\"\"\n"
"\n"
"    # Initializes the database.\n"
"    with engine.begin() as conn:\n"
"        USState.metadata.create_all(conn)\n"
"\n"
"    with session_factory() as db_session:\n"
"        # 1) Load the JSON data into the US States table.\n"
"        repo = USStateRepository(session=db_session)\n"
"        fixture = open_fixture(here, USStateRepository.model_type."
"__tablename__)  # type: ignore\n"
"        objs = repo.add_many([USStateRepository.model_type(**raw_obj) for "
"raw_obj in fixture])\n"
"        db_session.commit()\n"
"        console.print(f\"Created {len(objs)} new objects.\")"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:178
msgid "Paginated Data Selection"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:180
msgid ""
"Next, let's explore how to select multiple records with pagination. This "
"functionality is useful for handling large amounts of data by breaking the "
"data into manageable 'pages' or subsets.  ``LimitOffset`` is one of several "
"filter types you can use with the repository."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:186
msgid ""
"from litestar.repository.filters import LimitOffset\n"
"\n"
"\n"
"        # 2) Select paginated data and total row count.\n"
"        created_objs, total_objs = repo.list_and_count(LimitOffset(limit=10, "
"offset=0))\n"
"        console.print(f\"Selected {len(created_objs)} records out of a total "
"of {total_objs}.\")"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:192
msgid "Bulk Delete"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:194
msgid ""
"Here we demonstrate how to perform a bulk delete operation. Just as with the "
"bulk insert, deleting multiple records with the batch record methods is more "
"efficient than executing row-by-row."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:199
msgid ""
"        # 3) Let's remove the batch of records selected.\n"
"        deleted_objs = repo.delete_many([new_obj.id for new_obj in "
"created_objs])\n"
"        console.print(f\"Removed {len(deleted_objs)} records out of a total "
"of {total_objs}.\")"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:205
msgid "Counts"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:207
msgid ""
"Finally, we'll demonstrate how to count the number of records remaining in "
"the database."
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:210
msgid ""
"        # 4) Let's count the remaining rows\n"
"        remaining_count = repo.count()\n"
"        console.print(f\"Found {remaining_count} remaining records after "
"delete.\")"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:215
msgid ""
"Now that we have demonstrated how to interact with the repository objects "
"outside of a Litestar application, our next example will use dependency "
"injection to add this functionality to a :class:`~litestar.controller."
"Controller`!"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:222
msgid "Full Code"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:0
msgid "Full Code (click to toggle)"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:227
msgid ""
"from __future__ import annotations\n"
"\n"
"from contextlib import asynccontextmanager\n"
"from datetime import date, datetime\n"
"from typing import AsyncIterator\n"
"from uuid import UUID\n"
"\n"
"import anyio\n"
"from rich import get_console\n"
"from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar.plugins.sqlalchemy import base, repository\n"
"\n"
"console = get_console()\n"
"\n"
"\n"
"# the SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `Base` class includes a `UUID` based primary key (`id`)\n"
"class Author(base.UUIDBase):\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date]\n"
"    dod: Mapped[date | None]\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemyAsyncRepository[Author]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = Author\n"
"\n"
"\n"
"engine = create_async_engine(\n"
"    \"sqlite+aiosqlite:///test.sqlite\",\n"
"    future=True,\n"
")\n"
"session_factory = async_sessionmaker(engine, expire_on_commit=False)\n"
"\n"
"\n"
"# let's make a simple context manager as an example here.\n"
"@asynccontextmanager\n"
"async def repository_factory() -> AsyncIterator[AuthorRepository]:\n"
"    async with session_factory() as db_session:\n"
"        try:\n"
"            yield AuthorRepository(session=db_session)\n"
"        except Exception:  # noqa: BLE001\n"
"            await db_session.rollback()\n"
"        else:\n"
"            await db_session.commit()\n"
"\n"
"\n"
"async def create_author() -> Author:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.add(\n"
"            Author(\n"
"                name=\"F. Scott Fitzgerald\",\n"
"                dob=datetime.strptime(\"1896-09-24\", \"%Y-%m-%d\").date(),\n"
"            )\n"
"        )\n"
"        console.print(f\"Created Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj\n"
"\n"
"\n"
"async def update_author(obj: Author) -> Author:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.update(obj)\n"
"        console.print(f\"Updated Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj\n"
"\n"
"\n"
"async def remove_author(id: UUID) -> Author:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.delete(id)\n"
"        console.print(f\"Deleted Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj\n"
"\n"
"\n"
"async def get_author_if_exists(id: UUID) -> Author | None:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.get_one_or_none(id=id)\n"
"        if obj is not None:\n"
"            console.print(f\"Found Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        else:\n"
"            console.print(f\"Could not find Author with primary key {id}."
"\")\n"
"        return obj\n"
"\n"
"\n"
"async def run_script() -> None:\n"
"    \"\"\"Load data from a fixture.\"\"\"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(base.UUIDBase.metadata.create_all)\n"
"\n"
"    # 1) create a new Author record.\n"
"    console.print(\"1) Adding a new record\")\n"
"    author = await create_author()\n"
"    author_id = author.id\n"
"\n"
"    # 2) Let's update the Author record.\n"
"    console.print(\"2) Updating a record.\")\n"
"    author.dod = datetime.strptime(\"1940-12-21\", \"%Y-%m-%d\").date()\n"
"    await update_author(author)\n"
"\n"
"    # 3) Let's delete the record we just created.\n"
"    console.print(\"3) Removing a record.\")\n"
"    await remove_author(author_id)\n"
"\n"
"    # 4) Let's verify the record no longer exists.\n"
"    console.print(\"4) Select one or none.\")\n"
"    _should_be_none = await get_author_if_exists(author_id)\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    anyio.run(run_script)"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/repository-tutorial/02-repository-introduction.rst:227
msgid ""
"from __future__ import annotations\n"
"\n"
"from contextlib import asynccontextmanager\n"
"from datetime import date, datetime\n"
"from collections.abc import AsyncIterator\n"
"from uuid import UUID\n"
"\n"
"import anyio\n"
"from rich import get_console\n"
"from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar.plugins.sqlalchemy import base, repository\n"
"\n"
"console = get_console()\n"
"\n"
"\n"
"# the SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `Base` class includes a `UUID` based primary key (`id`)\n"
"class Author(base.UUIDBase):\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date]\n"
"    dod: Mapped[date | None]\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemyAsyncRepository[Author]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = Author\n"
"\n"
"\n"
"engine = create_async_engine(\n"
"    \"sqlite+aiosqlite:///test.sqlite\",\n"
"    future=True,\n"
")\n"
"session_factory = async_sessionmaker(engine, expire_on_commit=False)\n"
"\n"
"\n"
"# let's make a simple context manager as an example here.\n"
"@asynccontextmanager\n"
"async def repository_factory() -> AsyncIterator[AuthorRepository]:\n"
"    async with session_factory() as db_session:\n"
"        try:\n"
"            yield AuthorRepository(session=db_session)\n"
"        except Exception:  # noqa: BLE001\n"
"            await db_session.rollback()\n"
"        else:\n"
"            await db_session.commit()\n"
"\n"
"\n"
"async def create_author() -> Author:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.add(\n"
"            Author(\n"
"                name=\"F. Scott Fitzgerald\",\n"
"                dob=datetime.strptime(\"1896-09-24\", \"%Y-%m-%d\").date(),\n"
"            )\n"
"        )\n"
"        console.print(f\"Created Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj\n"
"\n"
"\n"
"async def update_author(obj: Author) -> Author:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.update(obj)\n"
"        console.print(f\"Updated Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj\n"
"\n"
"\n"
"async def remove_author(id: UUID) -> Author:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.delete(id)\n"
"        console.print(f\"Deleted Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        return obj\n"
"\n"
"\n"
"async def get_author_if_exists(id: UUID) -> Author | None:\n"
"    async with repository_factory() as repo:\n"
"        obj = await repo.get_one_or_none(id=id)\n"
"        if obj is not None:\n"
"            console.print(f\"Found Author record for {obj.name} with primary "
"key {obj.id}.\")\n"
"        else:\n"
"            console.print(f\"Could not find Author with primary key {id}."
"\")\n"
"        return obj\n"
"\n"
"\n"
"async def run_script() -> None:\n"
"    \"\"\"Load data from a fixture.\"\"\"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(base.UUIDBase.metadata.create_all)\n"
"\n"
"    # 1) create a new Author record.\n"
"    console.print(\"1) Adding a new record\")\n"
"    author = await create_author()\n"
"    author_id = author.id\n"
"\n"
"    # 2) Let's update the Author record.\n"
"    console.print(\"2) Updating a record.\")\n"
"    author.dod = datetime.strptime(\"1940-12-21\", \"%Y-%m-%d\").date()\n"
"    await update_author(author)\n"
"\n"
"    # 3) Let's delete the record we just created.\n"
"    console.print(\"3) Removing a record.\")\n"
"    await remove_author(author_id)\n"
"\n"
"    # 4) Let's verify the record no longer exists.\n"
"    console.print(\"4) Select one or none.\")\n"
"    _should_be_none = await get_author_if_exists(author_id)\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    anyio.run(run_script)"
msgstr ""
