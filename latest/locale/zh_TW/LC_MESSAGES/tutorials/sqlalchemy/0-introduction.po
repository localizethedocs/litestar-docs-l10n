# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/sqlalchemy/0-introduction.rst:2
msgid "Introduction"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:4
msgid ""
"We start with a full script that shows how you can use SQLAlchemy with "
"Litestar. In this app, we interact with SQLAlchemy in the manner described "
"by the `SQLAlchemy documentation <https://docs.sqlalchemy.org/en/20/orm/"
"extensions/asyncio.html#synopsis-orm>`_, and so if you are looking for more "
"information about any of the SQLAlchemy code, this will be a great place to "
"start."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:9
msgid ""
"You'll notice that we use a couple of Litestar features that you may not "
"have encountered yet:"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:11
msgid ""
"Management and injection of :ref:`application state <application-state>`"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:12
msgid "Use of a :ref:`Lifespan context manager <lifespan-context-managers>`"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:14
msgid ""
"And we will continue to learn about other Litestar features as we work "
"through the tutorial, such as:"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:16
msgid "Dependency injection"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:17
msgid "Plugins"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:20
msgid "The full app"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:22
msgid ""
"While it may look imposing, this app only has minor behavioral differences "
"to the previous example. It is still an app that maintains a TODO list, that "
"allows for adding, updating and viewing the collection of TODO items."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:25
msgid ""
"Don't worry if there are things in this example that you don't understand. "
"We will cover all of the components in detail in the following sections."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:29
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Any, AsyncGenerator, Dict, List, Optional, Sequence\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"TodoType = Dict[str, Any]\n"
"TodoCollectionType = List[TodoType]\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"Sequence[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return result.scalars().all()\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(state: State, done: Optional[bool] = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, state: State) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                session.add(new_todo)\n"
"        except IntegrityError as e:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=f\"TODO {new_todo.title!r} already exists\",\n"
"            ) from e\n"
"\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:29
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Any, Optional\n"
"from collections.abc import AsyncGenerator, Sequence\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"TodoType = dict[str, Any]\n"
"TodoCollectionType = list[TodoType]\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"Sequence[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return result.scalars().all()\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(state: State, done: Optional[bool] = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, state: State) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                session.add(new_todo)\n"
"        except IntegrityError as e:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=f\"TODO {new_todo.title!r} already exists\",\n"
"            ) from e\n"
"\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:29
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Any\n"
"from collections.abc import AsyncGenerator, Sequence\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"TodoType = dict[str, Any]\n"
"TodoCollectionType = list[TodoType]\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: bool | None, session: AsyncSession) -> "
"Sequence[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return result.scalars().all()\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(state: State, done: bool | None = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, state: State) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                session.add(new_todo)\n"
"        except IntegrityError as e:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=f\"TODO {new_todo.title!r} already exists\",\n"
"            ) from e\n"
"\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:34
msgid "The differences"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:36
msgid ""
"Apart from the obvious differences due to the SQLAlchemy code, there are a "
"few things worth mentioning from the outset."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:39
msgid "Complexity"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:41
msgid ""
"This code is undoubtedly more complex than the code we have seen so far - "
"although a crude measure of complexity, we can see that there are more than "
"double the lines of code to the previous example."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:45
msgid "Lifespan context manager"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:47
msgid ""
"When using a database, we need to ensure that we clean up our resources "
"correctly. To do this, we create a context manager called "
"``db_connection()`` that creates a new :class:`engine <sqlalchemy.ext."
"asyncio.AsyncEngine>` and disposes of it when we are done. This context "
"manager is added to the application's ``lifespan`` argument."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:52
msgid ""
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:58
msgid "Database creation"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:59
msgid ""
"Before we can use the database we need to make sure it exists and the tables "
"are created as defined by the ``TodoItem`` class. This can be done by a "
"synchronous call to ``Base.metadata.create_all`` which is invoked by "
"``run_sync``. If the tables are already setup according to the model, the "
"call does nothing."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:64
#: ../../../tutorials/sqlalchemy/0-introduction.rst:77
msgid ""
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:71
msgid "Application state"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:73
msgid ""
"We see two examples of access and use of application state. The first is in "
"the ``db_connection()`` context manager, where we use the ``app.state`` "
"object to store the engine."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:83
msgid ""
"The second is by using the ``state`` keyword argument in our handler "
"functions, so that we can access the engine in our handlers."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:87
msgid ""
"@get(\"/\")\n"
"async def get_list(state: State, done: Optional[bool] = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:94
msgid "Serialization"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:96
msgid ""
"Now that we are using SQLAlchemy models, Litestar cannot automatically "
"handle (de)serialization of our data. We have to convert the SQLAlchemy "
"models to a type that Litestar can serialize. This example introduces two "
"type aliases, ``TodoType`` and ``TodoCollectionType`` to help us represent "
"this data at the boundaries of our handlers. It also introduces the "
"``serialize_todo()`` to help us convert our data from the ``TodoItem`` type "
"to a type that is serializable by Litestar."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:103
msgid ""
"from typing import Any, Dict, List\n"
"\n"
"TodoType = Dict[str, Any]\n"
"TodoCollectionType = List[TodoType]\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:103
msgid ""
"from typing import Any\n"
"\n"
"TodoType = dict[str, Any]\n"
"TodoCollectionType = list[TodoType]\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:110
msgid "Behavior"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:112
msgid ""
"The ``add_item()`` and ``update_item()`` routes no longer return the full "
"collection, instead they return the item that was added or updated. This is "
"a minor detail change, but it is worth noting as it brings the behavior of "
"the app closer to what we would expect from a conventional API."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:117
msgid "Next steps"
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:119
msgid "Lets start cleaning this app up a little."
msgstr ""

#: ../../../tutorials/sqlalchemy/0-introduction.rst:121
msgid ""
"One of the standout issues is that we repeat the logic to create a database "
"session in every handler. This is something that we can fix with dependency "
"injection."
msgstr ""
