# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:2
msgid "Providing the session with DI"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:5
msgid ""
"In our original script, we had to repeat the logic to construct a session "
"instance for every request type. This is not very `DRY <https://en.wikipedia."
"org/wiki/Don%27t_repeat_yourself>`_."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:8
msgid ""
"In this section, we'll use dependency injection to centralize the session "
"creation logic and make it available to all handlers."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:12
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Any, AsyncGenerator, Dict, List, Optional\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"TodoType = Dict[str, Any]\n"
"TodoCollectionType = List[TodoType]\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\")\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc\n"
"\n"
"\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name, session: AsyncSession) -> TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"List[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return result.scalars().all()\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> TodoCollectionType:\n"
"    return [serialize_todo(todo) for todo in await get_todo_list(done, "
"transaction)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, transaction: AsyncSession) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    transaction.add(new_todo)\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, transaction: "
"AsyncSession) -> TodoType:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data[\"title\"]\n"
"    todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:12
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Any, Optional\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"TodoType = dict[str, Any]\n"
"TodoCollectionType = list[TodoType]\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\")\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc\n"
"\n"
"\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name, session: AsyncSession) -> TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return result.scalars().all()\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> TodoCollectionType:\n"
"    return [serialize_todo(todo) for todo in await get_todo_list(done, "
"transaction)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, transaction: AsyncSession) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    transaction.add(new_todo)\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, transaction: "
"AsyncSession) -> TodoType:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data[\"title\"]\n"
"    todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:12
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Any\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"TodoType = dict[str, Any]\n"
"TodoCollectionType = list[TodoType]\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\")\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc\n"
"\n"
"\n"
"def serialize_todo(todo: TodoItem) -> TodoType:\n"
"    return {\"title\": todo.title, \"done\": todo.done}\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name, session: AsyncSession) -> TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: bool | None, session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return result.scalars().all()\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: bool | None = None) -> "
"TodoCollectionType:\n"
"    return [serialize_todo(todo) for todo in await get_todo_list(done, "
"transaction)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, transaction: AsyncSession) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    transaction.add(new_todo)\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, transaction: "
"AsyncSession) -> TodoType:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data[\"title\"]\n"
"    todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:16
msgid ""
"In the previous example, the database session is created within each HTTP "
"route handler function. In this script we use dependency injection to "
"decouple creation of the session from the route handlers."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:19
msgid ""
"This script introduces a new async generator function called "
"``provide_transaction()`` that creates a new SQLAlchemy session, begins a "
"transaction, and handles any integrity errors that might raise from within "
"the transaction."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:23
msgid ""
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:27
msgid ""
"That function is declared as a dependency to the Litestar application, using "
"the name ``transaction``."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:30
msgid ""
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:35
msgid ""
"In the route handlers, the database session is injected by declaring the "
"``transaction`` name as a function argument. This is automatically provided "
"by Litestar's dependency injection system at runtime."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:40
msgid ""
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> TodoCollectionType:\n"
"    return [serialize_todo(todo) for todo in await get_todo_list(done, "
"transaction)]"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:45
msgid ""
"One final improvement in this script is exception handling. In the previous "
"version, a :class:`litestar.exceptions.ClientException` is raised inside the "
"``add_item()`` handler if there's an integrity error raised during the "
"insertion of the new TODO item. In our latest revision, we've been able to "
"centralize this handling to occur inside the ``provide_transaction()`` "
"function."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:51
msgid ""
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:56
msgid ""
"This change broadens the scope of exception handling to any operation that "
"uses the database session, not just the insertion of new items."
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:60
msgid "Compare handlers before and after DI"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:62
msgid ""
"Just for fun, lets compare the sets of application handlers before and after "
"we introduced dependency injection for our session object:"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:0
msgid "After"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:70
msgid ""
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> TodoCollectionType:\n"
"    return [serialize_todo(todo) for todo in await get_todo_list(done, "
"transaction)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, transaction: AsyncSession) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    transaction.add(new_todo)\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, transaction: "
"AsyncSession) -> TodoType:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data[\"title\"]\n"
"    todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:0
msgid "Before"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:77
msgid ""
"@get(\"/\")\n"
"async def get_list(state: State, done: Optional[bool] = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, state: State) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                session.add(new_todo)\n"
"        except IntegrityError as e:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=f\"TODO {new_todo.title!r} already exists\",\n"
"            ) from e\n"
"\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:81
msgid "Much better!"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:84
msgid "Next steps"
msgstr ""

#: ../../../tutorials/sqlalchemy/1-provide-session-with-di.rst:86
msgid ""
"One of the niceties that we've lost is the ability to receive and return "
"data to/from our handlers as instances of our data model. In the original "
"TODO application, we modelled with Python dataclasses which are natively "
"supported for (de)serialization by Litestar. In the next section, we will "
"look at how we can get this functionality back!"
msgstr ""
