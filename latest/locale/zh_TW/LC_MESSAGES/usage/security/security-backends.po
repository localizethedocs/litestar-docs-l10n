# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/security/security-backends.rst:3
msgid "Security Backends"
msgstr ""

#: ../../../usage/security/security-backends.rst:6
msgid ":class:`~.security.base.AbstractSecurityConfig`"
msgstr ""

#: ../../../usage/security/security-backends.rst:8
msgid ""
":doc:`litestar.security </reference/security/index>` includes an :class:`~."
"security.base.AbstractSecurityConfig` class that serves as a basis for all "
"the security backends offered by Litestar, and is also meant to be used as a "
"basis for custom security backends created by users which you can read more "
"about here: :doc:`/usage/security/abstract-authentication-middleware`"
msgstr ""

#: ../../../usage/security/security-backends.rst:14
msgid "Session Auth Backend"
msgstr ""

#: ../../../usage/security/security-backends.rst:16
msgid ""
"Litestar offers a builtin session auth backend that can be used out of the "
"box with any of the :ref:`session backends <usage/middleware/builtin-"
"middleware:session middleware>` supported by the Litestar session middleware."
msgstr ""

#: ../../../usage/security/security-backends.rst:0
msgid "Click to see an example of using the session auth backend"
msgstr ""

#: ../../../usage/security/security-backends.rst:0
msgid "Python 3.8+"
msgstr "Python 3.8+"

#: ../../../usage/security/security-backends.rst:23
msgid "Using Session Auth"
msgstr ""

#: ../../../usage/security/security-backends.rst:23
msgid ""
"from typing import Any, Dict, Literal, Optional\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr, SecretStr\n"
"\n"
"from litestar import Litestar, Request, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.middleware.session.server_side import "
"ServerSideSessionBackend, ServerSideSessionConfig\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.session_auth import SessionAuth\n"
"from litestar.stores.memory import MemoryStore\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n"
"# a representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# we also have pydantic types for two different\n"
"# kinds of POST request bodies: one for creating\n"
"# a user, e.g. \"sign-up\", and the other for logging\n"
"# an existing user in.\n"
"class UserCreatePayload(BaseModel):\n"
"    name: str\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"class UserLoginPayload(BaseModel):\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"MOCK_DB: Dict[str, User] = {}\n"
"memory_store = MemoryStore()\n"
"\n"
"\n"
"# The SessionAuth class requires a handler callable\n"
"# that takes the session dictionary, and returns the\n"
"# 'User' instance correlating to it.\n"
"#\n"
"# The session dictionary itself is a value the user decides\n"
"# upon. So for example, it might be a simple dictionary\n"
"# that holds a user id, for example: { \"id\": \"abcd123\" }\n"
"#\n"
"# Note: The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(\n"
"    session: Dict[str, Any], connection: \"ASGIConnection[Any, Any, Any, "
"Any]\"\n"
") -> Optional[User]:\n"
"    return MOCK_DB.get(user_id) if (user_id := session.get(\"user_id\")) "
"else None\n"
"\n"
"\n"
"@post(\"/login\")\n"
"async def login(data: UserLoginPayload, request: \"Request[Any, Any, Any]\") "
"-> User:\n"
"    # we received log-in data via post.\n"
"    # our login handler should retrieve from persistence (a db etc.)\n"
"    # the user data and verify that the login details\n"
"    # are correct. If we are using passwords, we should check that\n"
"    # the password hashes match etc. We will simply assume that we\n"
"    # have done all of that we now have a user value:\n"
"    user_id = await memory_store.get(data.email)\n"
"\n"
"    if not user_id:\n"
"        raise NotAuthorizedException\n"
"    user_id = user_id.decode(\"utf-8\")\n"
"\n"
"    # once verified we can create a session.\n"
"    # to do this we simply need to call the Litestar\n"
"    # 'Request.set_session' method, which accepts either dictionaries\n"
"    # or pydantic models. In our case, we can simply record a\n"
"    # simple dictionary with the user ID value:\n"
"    request.set_session({\"user_id\": user_id})\n"
"\n"
"    # you can do whatever we want here. In this case, we will simply return "
"the user data:\n"
"    return MOCK_DB[user_id]\n"
"\n"
"\n"
"@post(\"/signup\")\n"
"async def signup(data: UserCreatePayload, request: Request[Any, Any, Any]) -"
"> User:\n"
"    # this is similar to the login handler, except here we should\n"
"    # insert into persistence - after doing whatever extra\n"
"    # validation we might require. We will assume that this is done,\n"
"    # and we now have a user instance with an assigned ID value:\n"
"    user = User(name=data.name, email=data.email, id=uuid4())\n"
"\n"
"    await memory_store.set(data.email, str(user.id))\n"
"    MOCK_DB[str(user.id)] = user\n"
"    # we are creating a session the same as we do in the\n"
"    # 'login_handler' above:\n"
"    request.set_session({\"user_id\": str(user.id)})\n"
"\n"
"    # and again, you can add whatever logic is required here, we\n"
"    # will simply return the user:\n"
"    return user\n"
"\n"
"\n"
"# the endpoint below requires the user to be already authenticated\n"
"# to be able to access it.\n"
"@get(\"/user\", sync_to_thread=False)\n"
"def get_user(request: Request[User, Dict[Literal[\"user_id\"], str], Any]) -"
"> Any:\n"
"    # because this route requires authentication, we can access\n"
"    # `request.user`, which is the authenticated user returned\n"
"    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n"
"    return request.user\n"
"\n"
"\n"
"# We add the session security schema to the OpenAPI config.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"session_auth = SessionAuth[User, ServerSideSessionBackend](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    # we must pass a config for a session backend.\n"
"    # all session backends are supported\n"
"    session_backend_config=ServerSideSessionConfig(),\n"
"    # exclude any URLs that should not have authentication.\n"
"    # We exclude the documentation URLs, signup and login.\n"
"    exclude=[\"/login\", \"/signup\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# We initialize the app instance, passing to it the 'session_auth."
"on_app_init' and the 'openapi_config'.\n"
"app = Litestar(\n"
"    route_handlers=[login, signup, get_user],\n"
"    on_app_init=[session_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/security-backends.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/security/security-backends.rst:23
msgid ""
"from typing import Any, Literal, Optional\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr, SecretStr\n"
"\n"
"from litestar import Litestar, Request, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.middleware.session.server_side import "
"ServerSideSessionBackend, ServerSideSessionConfig\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.session_auth import SessionAuth\n"
"from litestar.stores.memory import MemoryStore\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n"
"# a representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# we also have pydantic types for two different\n"
"# kinds of POST request bodies: one for creating\n"
"# a user, e.g. \"sign-up\", and the other for logging\n"
"# an existing user in.\n"
"class UserCreatePayload(BaseModel):\n"
"    name: str\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"class UserLoginPayload(BaseModel):\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"memory_store = MemoryStore()\n"
"\n"
"\n"
"# The SessionAuth class requires a handler callable\n"
"# that takes the session dictionary, and returns the\n"
"# 'User' instance correlating to it.\n"
"#\n"
"# The session dictionary itself is a value the user decides\n"
"# upon. So for example, it might be a simple dictionary\n"
"# that holds a user id, for example: { \"id\": \"abcd123\" }\n"
"#\n"
"# Note: The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(\n"
"    session: dict[str, Any], connection: \"ASGIConnection[Any, Any, Any, "
"Any]\"\n"
") -> Optional[User]:\n"
"    return MOCK_DB.get(user_id) if (user_id := session.get(\"user_id\")) "
"else None\n"
"\n"
"\n"
"@post(\"/login\")\n"
"async def login(data: UserLoginPayload, request: \"Request[Any, Any, Any]\") "
"-> User:\n"
"    # we received log-in data via post.\n"
"    # our login handler should retrieve from persistence (a db etc.)\n"
"    # the user data and verify that the login details\n"
"    # are correct. If we are using passwords, we should check that\n"
"    # the password hashes match etc. We will simply assume that we\n"
"    # have done all of that we now have a user value:\n"
"    user_id = await memory_store.get(data.email)\n"
"\n"
"    if not user_id:\n"
"        raise NotAuthorizedException\n"
"    user_id = user_id.decode(\"utf-8\")\n"
"\n"
"    # once verified we can create a session.\n"
"    # to do this we simply need to call the Litestar\n"
"    # 'Request.set_session' method, which accepts either dictionaries\n"
"    # or pydantic models. In our case, we can simply record a\n"
"    # simple dictionary with the user ID value:\n"
"    request.set_session({\"user_id\": user_id})\n"
"\n"
"    # you can do whatever we want here. In this case, we will simply return "
"the user data:\n"
"    return MOCK_DB[user_id]\n"
"\n"
"\n"
"@post(\"/signup\")\n"
"async def signup(data: UserCreatePayload, request: Request[Any, Any, Any]) -"
"> User:\n"
"    # this is similar to the login handler, except here we should\n"
"    # insert into persistence - after doing whatever extra\n"
"    # validation we might require. We will assume that this is done,\n"
"    # and we now have a user instance with an assigned ID value:\n"
"    user = User(name=data.name, email=data.email, id=uuid4())\n"
"\n"
"    await memory_store.set(data.email, str(user.id))\n"
"    MOCK_DB[str(user.id)] = user\n"
"    # we are creating a session the same as we do in the\n"
"    # 'login_handler' above:\n"
"    request.set_session({\"user_id\": str(user.id)})\n"
"\n"
"    # and again, you can add whatever logic is required here, we\n"
"    # will simply return the user:\n"
"    return user\n"
"\n"
"\n"
"# the endpoint below requires the user to be already authenticated\n"
"# to be able to access it.\n"
"@get(\"/user\", sync_to_thread=False)\n"
"def get_user(request: Request[User, dict[Literal[\"user_id\"], str], Any]) -"
"> Any:\n"
"    # because this route requires authentication, we can access\n"
"    # `request.user`, which is the authenticated user returned\n"
"    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n"
"    return request.user\n"
"\n"
"\n"
"# We add the session security schema to the OpenAPI config.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"session_auth = SessionAuth[User, ServerSideSessionBackend](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    # we must pass a config for a session backend.\n"
"    # all session backends are supported\n"
"    session_backend_config=ServerSideSessionConfig(),\n"
"    # exclude any URLs that should not have authentication.\n"
"    # We exclude the documentation URLs, signup and login.\n"
"    exclude=[\"/login\", \"/signup\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# We initialize the app instance, passing to it the 'session_auth."
"on_app_init' and the 'openapi_config'.\n"
"app = Litestar(\n"
"    route_handlers=[login, signup, get_user],\n"
"    on_app_init=[session_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/security-backends.rst:0
msgid "Python 3.10+"
msgstr "Python 3.10+"

#: ../../../usage/security/security-backends.rst:23
msgid ""
"from typing import Any, Literal\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr, SecretStr\n"
"\n"
"from litestar import Litestar, Request, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.middleware.session.server_side import "
"ServerSideSessionBackend, ServerSideSessionConfig\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.session_auth import SessionAuth\n"
"from litestar.stores.memory import MemoryStore\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n"
"# a representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# we also have pydantic types for two different\n"
"# kinds of POST request bodies: one for creating\n"
"# a user, e.g. \"sign-up\", and the other for logging\n"
"# an existing user in.\n"
"class UserCreatePayload(BaseModel):\n"
"    name: str\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"class UserLoginPayload(BaseModel):\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"memory_store = MemoryStore()\n"
"\n"
"\n"
"# The SessionAuth class requires a handler callable\n"
"# that takes the session dictionary, and returns the\n"
"# 'User' instance correlating to it.\n"
"#\n"
"# The session dictionary itself is a value the user decides\n"
"# upon. So for example, it might be a simple dictionary\n"
"# that holds a user id, for example: { \"id\": \"abcd123\" }\n"
"#\n"
"# Note: The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(\n"
"    session: dict[str, Any], connection: \"ASGIConnection[Any, Any, Any, "
"Any]\"\n"
") -> User | None:\n"
"    return MOCK_DB.get(user_id) if (user_id := session.get(\"user_id\")) "
"else None\n"
"\n"
"\n"
"@post(\"/login\")\n"
"async def login(data: UserLoginPayload, request: \"Request[Any, Any, Any]\") "
"-> User:\n"
"    # we received log-in data via post.\n"
"    # our login handler should retrieve from persistence (a db etc.)\n"
"    # the user data and verify that the login details\n"
"    # are correct. If we are using passwords, we should check that\n"
"    # the password hashes match etc. We will simply assume that we\n"
"    # have done all of that we now have a user value:\n"
"    user_id = await memory_store.get(data.email)\n"
"\n"
"    if not user_id:\n"
"        raise NotAuthorizedException\n"
"    user_id = user_id.decode(\"utf-8\")\n"
"\n"
"    # once verified we can create a session.\n"
"    # to do this we simply need to call the Litestar\n"
"    # 'Request.set_session' method, which accepts either dictionaries\n"
"    # or pydantic models. In our case, we can simply record a\n"
"    # simple dictionary with the user ID value:\n"
"    request.set_session({\"user_id\": user_id})\n"
"\n"
"    # you can do whatever we want here. In this case, we will simply return "
"the user data:\n"
"    return MOCK_DB[user_id]\n"
"\n"
"\n"
"@post(\"/signup\")\n"
"async def signup(data: UserCreatePayload, request: Request[Any, Any, Any]) -"
"> User:\n"
"    # this is similar to the login handler, except here we should\n"
"    # insert into persistence - after doing whatever extra\n"
"    # validation we might require. We will assume that this is done,\n"
"    # and we now have a user instance with an assigned ID value:\n"
"    user = User(name=data.name, email=data.email, id=uuid4())\n"
"\n"
"    await memory_store.set(data.email, str(user.id))\n"
"    MOCK_DB[str(user.id)] = user\n"
"    # we are creating a session the same as we do in the\n"
"    # 'login_handler' above:\n"
"    request.set_session({\"user_id\": str(user.id)})\n"
"\n"
"    # and again, you can add whatever logic is required here, we\n"
"    # will simply return the user:\n"
"    return user\n"
"\n"
"\n"
"# the endpoint below requires the user to be already authenticated\n"
"# to be able to access it.\n"
"@get(\"/user\", sync_to_thread=False)\n"
"def get_user(request: Request[User, dict[Literal[\"user_id\"], str], Any]) -"
"> Any:\n"
"    # because this route requires authentication, we can access\n"
"    # `request.user`, which is the authenticated user returned\n"
"    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n"
"    return request.user\n"
"\n"
"\n"
"# We add the session security schema to the OpenAPI config.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"session_auth = SessionAuth[User, ServerSideSessionBackend](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    # we must pass a config for a session backend.\n"
"    # all session backends are supported\n"
"    session_backend_config=ServerSideSessionConfig(),\n"
"    # exclude any URLs that should not have authentication.\n"
"    # We exclude the documentation URLs, signup and login.\n"
"    exclude=[\"/login\", \"/signup\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# We initialize the app instance, passing to it the 'session_auth."
"on_app_init' and the 'openapi_config'.\n"
"app = Litestar(\n"
"    route_handlers=[login, signup, get_user],\n"
"    on_app_init=[session_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/security-backends.rst:27
msgid "JWT Auth"
msgstr ""

#: ../../../usage/security/security-backends.rst:29
msgid ""
"Litestar includes several JWT security backends. Check out the :doc:`JWT "
"documentation </usage/security/jwt>` for more details."
msgstr ""
