# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/exceptions.rst:2
msgid "Exceptions and exception handling"
msgstr ""

#: ../../../usage/exceptions.rst:4
msgid ""
"Litestar defines a base exception called :class:`LitestarException <litestar."
"exceptions.LitestarException>` which serves as a base class for all other "
"exceptions, see :mod:`API Reference <litestar.exceptions>`."
msgstr ""

#: ../../../usage/exceptions.rst:7
msgid "In general, Litestar has two scenarios for exception handling:"
msgstr ""

#: ../../../usage/exceptions.rst:9
msgid ""
"Exceptions that are raised during application configuration, startup, and "
"initialization, which are handled like regular Python exceptions"
msgstr ""

#: ../../../usage/exceptions.rst:10
msgid ""
"Exceptions that are raised as part of the request handling, i.e. exceptions "
"in route handlers, dependencies, and middleware, that should be returned as "
"a response to the end user"
msgstr ""

#: ../../../usage/exceptions.rst:14
msgid "Configuration Exceptions"
msgstr ""

#: ../../../usage/exceptions.rst:16
msgid ""
"For missing extra dependencies, Litestar will raise either :class:"
"`MissingDependencyException <litestar.exceptions."
"MissingDependencyException>`. For example, if you try to use the :ref:"
"`SQLAlchemyPlugin <plugins>` without having SQLAlchemy installed, this will "
"be raised when you start the application."
msgstr ""

#: ../../../usage/exceptions.rst:21
msgid ""
"For other configuration issues, Litestar will raise :class:"
"`ImproperlyConfiguredException <litestar.exceptions."
"ImproperlyConfiguredException>` with a message explaining the issue."
msgstr ""

#: ../../../usage/exceptions.rst:26
msgid "Application Exceptions"
msgstr ""

#: ../../../usage/exceptions.rst:28
msgid ""
"For application exceptions, Litestar uses the class :class:`~litestar."
"exceptions.http_exceptions.HTTPException`, which inherits from :class:"
"`~litestar.exceptions.LitestarException`. This exception will be serialized "
"into a JSON response of the following schema:"
msgstr ""

#: ../../../usage/exceptions.rst:32
msgid ""
"{\n"
"  \"status_code\": 500,\n"
"  \"detail\": \"Internal Server Error\",\n"
"  \"extra\": {}\n"
"}"
msgstr ""

#: ../../../usage/exceptions.rst:40
msgid ""
"Litestar also offers several pre-configured ``HTTPException`` subclasses "
"with pre-set error codes that you can use, such as:"
msgstr ""

#: ../../../usage/exceptions.rst:46
msgid "Exception"
msgstr ""

#: ../../../usage/exceptions.rst:46
msgid "Status code"
msgstr ""

#: ../../../usage/exceptions.rst:46
msgid "Description"
msgstr ""

#: ../../../usage/exceptions.rst:48
msgid ":class:`ImproperlyConfiguredException`"
msgstr ""

#: ../../../usage/exceptions.rst:48 ../../../usage/exceptions.rst:58
msgid "500"
msgstr ""

#: ../../../usage/exceptions.rst:48
msgid "Used internally for configuration errors"
msgstr ""

#: ../../../usage/exceptions.rst:50
msgid ":class:`ValidationException`"
msgstr ""

#: ../../../usage/exceptions.rst:50
msgid "400"
msgstr ""

#: ../../../usage/exceptions.rst:50
msgid "Raised when validation or parsing failed"
msgstr ""

#: ../../../usage/exceptions.rst:52
msgid ":class:`NotAuthorizedException`"
msgstr ""

#: ../../../usage/exceptions.rst:52
msgid "401"
msgstr ""

#: ../../../usage/exceptions.rst:52
msgid "HTTP status code 401"
msgstr ""

#: ../../../usage/exceptions.rst:54
msgid ":class:`PermissionDeniedException`"
msgstr ""

#: ../../../usage/exceptions.rst:54
msgid "403"
msgstr ""

#: ../../../usage/exceptions.rst:54
msgid "HTTP status code 403"
msgstr ""

#: ../../../usage/exceptions.rst:56
msgid ":class:`NotFoundException`"
msgstr ""

#: ../../../usage/exceptions.rst:56
msgid "404"
msgstr ""

#: ../../../usage/exceptions.rst:56
msgid "HTTP status code 404"
msgstr ""

#: ../../../usage/exceptions.rst:58
msgid ":class:`InternalServerException`"
msgstr ""

#: ../../../usage/exceptions.rst:58
msgid "HTTP status code 500"
msgstr ""

#: ../../../usage/exceptions.rst:60
msgid ":class:`ServiceUnavailableException`"
msgstr ""

#: ../../../usage/exceptions.rst:60
msgid "503"
msgstr ""

#: ../../../usage/exceptions.rst:60
msgid "HTTP status code 503"
msgstr ""

#: ../../../usage/exceptions.rst:65
msgid ""
"When a value fails validation, the result will be a :class:`~litestar."
"exceptions.http_exceptions.ValidationException` with the ``extra`` key set "
"to the validation error message."
msgstr ""

#: ../../../usage/exceptions.rst:67
msgid ""
"All validation error messages will be made available for the API consumers "
"by default. If this is not your intent, adjust the exception contents."
msgstr ""

#: ../../../usage/exceptions.rst:72
msgid "Exception handling"
msgstr ""

#: ../../../usage/exceptions.rst:74
msgid ""
"Litestar handles all errors by default by transforming them into **JSON "
"responses**. If the errors are **instances of** :class:`~litestar.exceptions."
"http_exceptions.HTTPException`, the responses will include the appropriate "
"``status_code``. Otherwise, the responses will default to ``500 - \"Internal "
"Server Error\"``."
msgstr ""

#: ../../../usage/exceptions.rst:79
msgid ""
"The following handler for instance will default to ``MediaType.TEXT`` so the "
"exception will be raised as text."
msgstr ""

#: ../../../usage/exceptions.rst:82
msgid ""
"from litestar import get\n"
"\n"
"\n"
"@get(sync_to_thread=False)\n"
"def handler(q: int) -> str:\n"
"    raise ValueError"
msgstr ""

#: ../../../usage/exceptions.rst:84
msgid ""
"You can customize exception handling by passing a dictionary, mapping either "
"status codes or exception classes to callables. For example, if you would "
"like to replace the default exception handler with a handler that returns "
"plain-text responses you could do this:"
msgstr ""

#: ../../../usage/exceptions.rst:89
msgid ""
"from litestar import Litestar, MediaType, Request, Response, get\n"
"from litestar.exceptions import HTTPException\n"
"from litestar.status_codes import HTTP_500_INTERNAL_SERVER_ERROR\n"
"\n"
"\n"
"def plain_text_exception_handler(_: Request, exc: Exception) -> Response:\n"
"    \"\"\"Default handler for exceptions subclassed from HTTPException."
"\"\"\"\n"
"    status_code = getattr(exc, \"status_code\", "
"HTTP_500_INTERNAL_SERVER_ERROR)\n"
"    detail = getattr(exc, \"detail\", \"\")\n"
"\n"
"    return Response(\n"
"        media_type=MediaType.TEXT,\n"
"        content=detail,\n"
"        status_code=status_code,\n"
"    )\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def index() -> None:\n"
"    raise HTTPException(detail=\"an error occurred\", status_code=400)\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[index],\n"
"    exception_handlers={HTTPException: plain_text_exception_handler},\n"
")"
msgstr ""

#: ../../../usage/exceptions.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"an error occurred"
msgstr ""

#: ../../../usage/exceptions.rst:92
msgid ""
"The above will define a top level exception handler that will apply the "
"``plain_text_exception_handler`` function to all exceptions that inherit "
"from ``HTTPException``. You could of course be more granular:"
msgstr ""

#: ../../../usage/exceptions.rst:96
msgid ""
"from litestar import Litestar, MediaType, Request, Response, get\n"
"from litestar.exceptions import HTTPException, ValidationException\n"
"from litestar.status_codes import HTTP_500_INTERNAL_SERVER_ERROR\n"
"\n"
"\n"
"def validation_exception_handler(request: Request, exc: ValidationException) "
"-> Response:\n"
"    return Response(\n"
"        media_type=MediaType.TEXT,\n"
"        content=f\"validation error: {exc.detail}\",\n"
"        status_code=400,\n"
"    )\n"
"\n"
"\n"
"def internal_server_error_handler(request: Request, exc: Exception) -> "
"Response:\n"
"    return Response(\n"
"        media_type=MediaType.TEXT,\n"
"        content=f\"server error: {exc}\",\n"
"        status_code=500,\n"
"    )\n"
"\n"
"\n"
"def value_error_handler(request: Request, exc: ValueError) -> Response:\n"
"    return Response(\n"
"        media_type=MediaType.TEXT,\n"
"        content=f\"value error: {exc}\",\n"
"        status_code=400,\n"
"    )\n"
"\n"
"\n"
"@get(\"/validation-error\")\n"
"async def validation_error(some_query_param: str) -> str:\n"
"    return some_query_param\n"
"\n"
"\n"
"@get(\"/server-error\")\n"
"async def server_error() -> None:\n"
"    raise HTTPException()\n"
"\n"
"\n"
"@get(\"/value-error\")\n"
"async def value_error() -> None:\n"
"    raise ValueError(\"this is wrong\")\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[validation_error, server_error, value_error],\n"
"    exception_handlers={\n"
"        ValidationException: validation_exception_handler,\n"
"        HTTP_500_INTERNAL_SERVER_ERROR: internal_server_error_handler,\n"
"        ValueError: value_error_handler,\n"
"    },\n"
")"
msgstr ""

#: ../../../usage/exceptions.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/validation-error\n"
"validation error: Missing required query parameter 'some_query_param' for "
"path /validation-error\n"
"> curl http://127.0.0.1:8000/server-error\n"
"server error: 500: Internal Server Error\n"
"> curl http://127.0.0.1:8000/value-error\n"
"value error: this is wrong"
msgstr ""

#: ../../../usage/exceptions.rst:99
msgid ""
"The choice whether to use a single function that has switching logic inside "
"it, or multiple functions depends on your specific needs."
msgstr ""

#: ../../../usage/exceptions.rst:104
msgid "Exception handling layers"
msgstr ""

#: ../../../usage/exceptions.rst:106
msgid ""
"Since Litestar allows users to define both exception handlers and "
"middlewares in a layered fashion, i.e. on individual route handlers, "
"controllers, routers, or the app layer, multiple layers of exception "
"handlers are required to ensure that exceptions are handled correctly:"
msgstr ""

#: ../../../usage/exceptions.rst:114
msgid "Exception Handlers"
msgstr ""

#: ../../../usage/exceptions.rst:117
msgid ""
"As a result of the above structure, the exceptions raised by the ASGI Router "
"itself, namely ``404 Not Found`` and ``405 Method Not Allowed`` are handled "
"only by exception handlers defined on the app layer. Thus, if you want to "
"affect these exceptions, you will need to pass the exception handlers for "
"them to the Litestar constructor and cannot use other layers for this "
"purpose."
msgstr ""

#: ../../../usage/exceptions.rst:122
msgid ""
"Litestar supports defining exception handlers on all layers of the app, with "
"the lower layers overriding layer above them. In the following example, the "
"exception handler for the route handler function will only handle the "
"``ValidationException`` occurring within that route handler:"
msgstr ""

#: ../../../usage/exceptions.rst:127
msgid ""
"from litestar import Litestar, Request, Response, get\n"
"from litestar.exceptions import HTTPException, ValidationException\n"
"\n"
"\n"
"def app_exception_handler(request: Request, exc: HTTPException) -> "
"Response:\n"
"    return Response(\n"
"        content={\n"
"            \"error\": \"server error\",\n"
"            \"path\": request.url.path,\n"
"            \"detail\": exc.detail,\n"
"            \"status_code\": exc.status_code,\n"
"        },\n"
"        status_code=500,\n"
"    )\n"
"\n"
"\n"
"def router_handler_exception_handler(request: Request, exc: "
"ValidationException) -> Response:\n"
"    return Response(\n"
"        content={\"error\": \"validation error\", \"path\": request.url."
"path},\n"
"        status_code=400,\n"
"    )\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def index() -> None:\n"
"    raise HTTPException(\"something's gone wrong\")\n"
"\n"
"\n"
"@get(\n"
"    \"/greet\",\n"
"    exception_handlers={ValidationException: "
"router_handler_exception_handler},\n"
")\n"
"async def greet(name: str) -> str:\n"
"    return f\"hello {name}\"\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[index, greet],\n"
"    exception_handlers={HTTPException: app_exception_handler},\n"
")"
msgstr ""

#: ../../../usage/exceptions.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"{\"error\":\"server error\",\"path\":\"/\",\"detail\":\"something's gone "
"wrong\",\"status_code\":500}\n"
"> curl http://127.0.0.1:8000/greet\n"
"{\"error\":\"validation error\",\"path\":\"/greet\"}"
msgstr ""
