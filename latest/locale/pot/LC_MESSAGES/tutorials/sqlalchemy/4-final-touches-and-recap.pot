# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:2
msgid "Final touches and recap"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:4
msgid ""
"There is one more improvement that we can make to our application. "
"Currently, we utilize both the :class:`SQLAlchemyInitPlugin <litestar."
"contrib.sqlalchemy.plugins.SQLAlchemyInitPlugin>` and the :class:"
"`SQLAlchemySerializationPlugin <litestar.contrib.sqlalchemy.plugins."
"SQLAlchemySerializationPlugin>`, but there is a shortcut for this "
"configuration: the :class:`SQLAlchemyPlugin <litestar.contrib.sqlalchemy."
"plugins.SQLAlchemyPlugin>` is a combination of the two, so we can simplify "
"our configuration by using it instead."
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:11
msgid "Here is our final application:"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:14
msgid ""
"from typing import AsyncGenerator, List, Optional\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import SQLAlchemyAsyncConfig, "
"SQLAlchemyPlugin\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"List[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> List[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"db_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///todo.sqlite\",\n"
"    metadata=Base.metadata,\n"
"    create_all=True,\n"
"    before_send_handler=\"autocommit\",\n"
")\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[SQLAlchemyPlugin(db_config)],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:14
msgid ""
"from typing import Optional\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import SQLAlchemyAsyncConfig, "
"SQLAlchemyPlugin\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"db_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///todo.sqlite\",\n"
"    metadata=Base.metadata,\n"
"    create_all=True,\n"
"    before_send_handler=\"autocommit\",\n"
")\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[SQLAlchemyPlugin(db_config)],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:14
msgid ""
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import SQLAlchemyAsyncConfig, "
"SQLAlchemyPlugin\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: bool | None, session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: bool | None = None) -> "
"list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"db_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///todo.sqlite\",\n"
"    metadata=Base.metadata,\n"
"    create_all=True,\n"
"    before_send_handler=\"autocommit\",\n"
")\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[SQLAlchemyPlugin(db_config)],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:19
msgid "Recap"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:21
msgid ""
"In this tutorial, we have learned how to use the SQLAlchemy plugin to create "
"a simple application that uses a database to store and retrieve data."
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:24
msgid ""
"In the final application ``TodoItem`` is defined, representing a TODO item. "
"It extends from the :class:`DeclarativeBase <sqlalchemy.orm."
"DeclarativeBase>` class provided by `SQLAlchemy <http://www.sqlalchemy.org/"
">`_:"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:28
msgid ""
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:32
msgid ""
"Next, we define a dependency that centralizes our database transaction "
"management and error handling. This dependency depends on the ``db_session`` "
"dependency, which is provided by the SQLAlchemy plugin, and is made "
"available to our handlers via the ``transaction`` argument:"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:37
msgid ""
"from typing import AsyncGenerator\n"
"\n"
"from sqlalchemy.exc import IntegrityError\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar.exceptions import ClientException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:37
msgid ""
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy.exc import IntegrityError\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar.exceptions import ClientException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:41
msgid ""
"We also define a couple of utility functions, that help us to retrieve our "
"TODO items from the database:"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:44
msgid ""
"from typing import List, Optional\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"List[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:44
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:44
msgid ""
"from sqlalchemy import select\n"
"from sqlalchemy.exc import NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: bool | None, session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:48
msgid ""
"We define our route handlers, which are the interface through which TODO "
"items can be created, retrieved and updated:"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:51
msgid ""
"from typing import List, Optional\n"
"\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar import get, post, put\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> List[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:51
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar import get, post, put\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:51
msgid ""
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar import get, post, put\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: bool | None = None) -> "
"list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:55
msgid ""
"Finally, we define our application, using the :class:`SQLAlchemyPlugin "
"<litestar.contrib.sqlalchemy.plugins.SQLAlchemyPlugin>` to configure "
"SQLAlchemy and manage the engine and session lifecycle, and register our "
"``transaction`` dependency."
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:60
msgid ""
"from litestar import Litestar\n"
"from litestar.plugins.sqlalchemy import SQLAlchemyPlugin\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[SQLAlchemyPlugin(db_config)],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/4-final-touches-and-recap.rst:66
msgid ""
":doc:`SQLAlchemy Plugins Usage Guide </usage/databases/sqlalchemy/plugins/"
"index>`"
msgstr ""
