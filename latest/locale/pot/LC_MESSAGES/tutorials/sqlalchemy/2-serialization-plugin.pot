# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:2
msgid "Using the serialization plugin"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:4
msgid ""
"Our next improvement is to leverage the :class:"
"`SQLAlchemySerializationPlugin <litestar.contrib.sqlalchemy.plugins."
"SQLAlchemySerializationPlugin>` so that we can receive and return our "
"SQLAlchemy models directly to and from our handlers."
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:8
msgid "Here's the code:"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:11
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import AsyncGenerator, List, Optional\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import SQLAlchemySerializationPlugin\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"List[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> List[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
"    plugins=[SQLAlchemySerializationPlugin()],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:11
msgid ""
"from contextlib import asynccontextmanager\n"
"from typing import Optional\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import SQLAlchemySerializationPlugin\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
"    plugins=[SQLAlchemySerializationPlugin()],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:11
msgid ""
"from contextlib import asynccontextmanager\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, "
"create_async_engine\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import SQLAlchemySerializationPlugin\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"@asynccontextmanager\n"
"async def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n"
"    engine = getattr(app.state, \"engine\", None)\n"
"    if engine is None:\n"
"        engine = create_async_engine(\"sqlite+aiosqlite:///todo.sqlite\", "
"echo=True)\n"
"        app.state.engine = engine\n"
"\n"
"    async with engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        await engine.dispose()\n"
"\n"
"\n"
"sessionmaker = async_sessionmaker(expire_on_commit=False)\n"
"\n"
"\n"
"async def provide_transaction(state: State) -> AsyncGenerator[AsyncSession, "
"None]:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                yield session\n"
"        except IntegrityError as exc:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=str(exc),\n"
"            ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: bool | None, session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: bool | None = None) -> "
"list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
"    plugins=[SQLAlchemySerializationPlugin()],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:15
msgid ""
"We've simply imported the plugin and added it to our app's plugins list, and "
"now we can receive and return our SQLAlchemy data models directly to and "
"from our handler."
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:18
msgid ""
"We've also been able to remove the ``TodoType`` and ``TodoCollectionType`` "
"aliases, and the ``serialize_todo()`` function, making the implementation "
"even more concise."
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:22
msgid "Compare handlers before and after Serialization Plugin"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:24
msgid ""
"Once more, let's compare the sets of application handlers before and after "
"our refactoring:"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:0
msgid "After"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:31
msgid ""
"from typing import List, Optional\n"
"\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.plugins.sqlalchemy import SQLAlchemySerializationPlugin\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> List[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
"    plugins=[SQLAlchemySerializationPlugin()],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:31
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.plugins.sqlalchemy import SQLAlchemySerializationPlugin\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
"    plugins=[SQLAlchemySerializationPlugin()],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:31
msgid ""
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.plugins.sqlalchemy import SQLAlchemySerializationPlugin\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: bool | None = None) -> "
"list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    lifespan=[db_connection],\n"
"    plugins=[SQLAlchemySerializationPlugin()],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:0
msgid "Before"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:38
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy.exc import IntegrityError\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(state: State, done: Optional[bool] = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, state: State) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                session.add(new_todo)\n"
"        except IntegrityError as e:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=f\"TODO {new_todo.title!r} already exists\",\n"
"            ) from e\n"
"\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:38
msgid ""
"from sqlalchemy.exc import IntegrityError\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.datastructures import State\n"
"from litestar.exceptions import ClientException\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(state: State, done: bool | None = None) -> "
"TodoCollectionType:\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        return [serialize_todo(todo) for todo in await get_todo_list(done, "
"session)]\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoType, state: State) -> TodoType:\n"
"    new_todo = TodoItem(title=data[\"title\"], done=data[\"done\"])\n"
"    async with sessionmaker(bind=state.engine) as session:\n"
"        try:\n"
"            async with session.begin():\n"
"                session.add(new_todo)\n"
"        except IntegrityError as e:\n"
"            raise ClientException(\n"
"                status_code=HTTP_409_CONFLICT,\n"
"                detail=f\"TODO {new_todo.title!r} already exists\",\n"
"            ) from e\n"
"\n"
"    return serialize_todo(new_todo)\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoType, state: State) -> "
"TodoType:\n"
"    async with sessionmaker(bind=state.engine) as session, session.begin():\n"
"        todo_item = await get_todo_by_title(item_title, session)\n"
"        todo_item.title = data[\"title\"]\n"
"        todo_item.done = data[\"done\"]\n"
"    return serialize_todo(todo_item)\n"
"\n"
"\n"
"app = Litestar([get_list, add_item, update_item], lifespan=[db_connection])"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:42
msgid "Very nice! But, we can do better."
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:45
msgid "Next steps"
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:47
msgid ""
"In our application, we've had to build a bit of scaffolding to integrate "
"SQLAlchemy with our application. We've had to define the ``db_connection()`` "
"lifespan context manager, and the ``provide_transaction()`` dependency "
"provider."
msgstr ""

#: ../../../tutorials/sqlalchemy/2-serialization-plugin.rst:50
msgid ""
"Next we'll look at how the :class:`SQLAlchemyInitPlugin <litestar.contrib."
"sqlalchemy.plugins.SQLAlchemyInitPlugin>` can help us."
msgstr ""
