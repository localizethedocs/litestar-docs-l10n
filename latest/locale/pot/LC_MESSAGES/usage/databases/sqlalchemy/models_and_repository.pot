# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:2
msgid "SQLAlchemy Models & Repository"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:4
msgid ""
"Litestar comes with a built-in repository class (:class:"
"`SQLAlchemyAsyncRepository <advanced_alchemy.repository."
"SQLAlchemyAsyncRepository>`) for `SQLAlchemy <https://docs.sqlalchemy.org/"
">`_ to make CRUD operations easier."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:9
msgid "Features"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:11
msgid ""
"Pre-configured ``DeclarativeBase`` for :doc:`SQLAlchemy <sqlalchemy:index>` "
"2.0 that includes a UUID or Big Integer based primary-key, a  `sentinel "
"column <https://docs.sqlalchemy.org/en/20/core/connections.html#configuring-"
"sentinel-columns>`_, and an optional version with audit columns."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:15
msgid ""
"Generic synchronous and asynchronous repositories for select, insert, "
"update, and delete operations on SQLAlchemy models"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:16
msgid ""
"Implements optimized methods for bulk inserts, updates, and deletes and uses "
"`lambda_stmt <https://docs.sqlalchemy.org/en/20/core/sqlelement."
"html#sqlalchemy.sql.expression.lambda_stmt>`_ when possible."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:17
msgid ""
"Integrated counts, pagination, sorting, filtering with ``LIKE``, ``IN``, and "
"dates before and/or after."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:18
msgid "Tested support for multiple database backends including:"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:20
msgid ""
"SQLite via `aiosqlite <https://aiosqlite.omnilib.dev/en/stable/>`_ or "
"`sqlite <https://docs.python.org/3/library/sqlite3.html>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:21
msgid ""
"Postgres via `asyncpg <https://magicstack.github.io/asyncpg/current/>`_ or "
"`psycopg3 (async or sync) <https://www.psycopg.org/psycopg3/>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:22
msgid "MySQL via `asyncmy <https://github.com/long2ice/asyncmy>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:23
msgid "Oracle via `oracledb <https://oracle.github.io/python-oracledb/>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:24
msgid ""
"Google Spanner via `spanner-sqlalchemy <https://github.com/googleapis/python-"
"spanner-sqlalchemy/>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:25
msgid "DuckDB via `duckdb_engine <https://github.com/Mause/duckdb_engine>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:26
msgid ""
"Microsoft SQL Server via `pyodbc <https://github.com/mkleehammer/pyodbc>`_"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:29
msgid "Basic Use"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:31
msgid ""
"To use the :class:`SQLAlchemyAsyncRepository <advanced_alchemy.repository."
"SQLAlchemyAsyncRepository>` repository, you must first define your models "
"using one of the included built-in ``DeclarativeBase`` ORM base "
"implementations:"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:35
msgid ":class:`UUIDBase <advanced_alchemy.base.UUIDBase>`"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:36
msgid ":class:`UUIDAuditBase <advanced_alchemy.base.UUIDAuditBase>`"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:38
msgid ""
"Both include a ``UUID`` based primary key and ``UUIDAuditBase`` includes "
"``updated_at`` and ``created_at`` timestamp columns."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:41
msgid ""
"The ``UUID`` will be a native ``UUID``/``GUID`` type on databases that "
"support it such as Postgres.  For other engines without a native UUID data "
"type, the UUID is stored as a 16-byte ``BYTES`` or ``RAW`` field."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:44
msgid ":class:`BigIntBase <advanced_alchemy.base.BigIntBase>`"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:45
msgid ":class:`BigIntAuditBase <advanced_alchemy.base.BigIntAuditBase>`"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:47
msgid ""
"Both include a ``BigInteger`` based primary key and ``BigIntAuditBase`` "
"includes ``updated_at`` and ``created_at`` timestamp columns."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:50
msgid "Models using these bases also include the following enhancements:"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:52
msgid "Auto-generated snake-case table name from class name"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:53
msgid ""
"Pydantic BaseModel and Dict classes map to an optimized JSON type that is :"
"class:`JSONB <sqlalchemy.dialects.postgresql.JSONB>` for Postgres, `VARCHAR` "
"or `BYTES` with JSON check constraint for Oracle, and :class:`JSON "
"<sqlalchemy.types.JSON>` for other dialects."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:59
msgid "``sqlalchemy_declarative_models.py``"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:59
msgid ""
"from __future__ import annotations\n"
"\n"
"import uuid\n"
"from datetime import date\n"
"from uuid import UUID\n"
"\n"
"from sqlalchemy import ForeignKey, func, select\n"
"from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.plugins.sqlalchemy import AsyncSessionConfig, "
"SQLAlchemyAsyncConfig, SQLAlchemyPlugin, base\n"
"\n"
"\n"
"# The SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `UUIDBase` class includes a `UUID` based primary key (`id`)\n"
"class Author(base.UUIDBase):\n"
"    __tablename__ = \"author\"\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date]\n"
"    books: Mapped[list[Book]] = relationship(back_populates=\"author\", "
"lazy=\"selectin\")\n"
"\n"
"\n"
"# The `UUIDAuditBase` class includes the same UUID` based primary key (`id`) "
"and 2\n"
"# additional columns: `created_at` and `updated_at`. `created_at` is a "
"timestamp of when the\n"
"# record created, and `updated_at` is the last time the record was "
"modified.\n"
"class Book(base.UUIDAuditBase):\n"
"    __tablename__ = \"book\"\n"
"    title: Mapped[str]\n"
"    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n"
"    author: Mapped[Author] = relationship(lazy=\"joined\", innerjoin=True, "
"viewonly=True)\n"
"\n"
"\n"
"session_config = AsyncSessionConfig(expire_on_commit=False)\n"
"sqlalchemy_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"session_config=session_config, create_all=True\n"
")  # Create 'async_session' dependency.\n"
"\n"
"\n"
"async def on_startup(app: Litestar) -> None:\n"
"    \"\"\"Adds some dummy data if no data is present.\"\"\"\n"
"    async with sqlalchemy_config.get_session() as session:\n"
"        statement = select(func.count()).select_from(Author)\n"
"        count = await session.execute(statement)\n"
"        if not count.scalar():\n"
"            author_id = uuid.uuid4()\n"
"            session.add(Author(name=\"Stephen King\", dob=date(1954, 9, 21), "
"id=author_id))\n"
"            session.add(Book(title=\"It\", author_id=author_id))\n"
"            await session.commit()\n"
"\n"
"\n"
"@get(path=\"/authors\")\n"
"async def get_authors(db_session: AsyncSession, db_engine: AsyncEngine) -> "
"list[Author]:\n"
"    \"\"\"Interact with SQLAlchemy engine and session.\"\"\"\n"
"    return list(await db_session.scalars(select(Author)))\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[get_authors],\n"
"    on_startup=[on_startup],\n"
"    debug=True,\n"
"    plugins=[SQLAlchemyPlugin(config=sqlalchemy_config)],\n"
")"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:63
msgid "Basic Controller Integration"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:65
msgid ""
"Once you have declared your models, you are ready to use the "
"``SQLAlchemyAsyncRepository`` class with your controllers and function based "
"routes."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:69
msgid "``sqlalchemy_async_repository.py``"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:69
msgid ""
"from __future__ import annotations\n"
"\n"
"from datetime import date\n"
"from typing import TYPE_CHECKING\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel as _BaseModel\n"
"from pydantic import TypeAdapter\n"
"from sqlalchemy import ForeignKey, select\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship, "
"selectinload\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.controller import Controller\n"
"from litestar.di import Provide\n"
"from litestar.handlers.http_handlers.decorators import delete, patch, post\n"
"from litestar.pagination import OffsetPagination\n"
"from litestar.params import Parameter\n"
"from litestar.plugins.sqlalchemy import (\n"
"    AsyncSessionConfig,\n"
"    SQLAlchemyAsyncConfig,\n"
"    SQLAlchemyInitPlugin,\n"
"    base,\n"
"    filters,\n"
"    repository,\n"
")\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"\n"
"class BaseModel(_BaseModel):\n"
"    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n"
"\n"
"    model_config = {\"from_attributes\": True}\n"
"\n"
"\n"
"# The SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `UUIDBase` class includes a `UUID` based primary key (`id`)\n"
"class AuthorModel(base.UUIDBase):\n"
"    # we can optionally provide the table name instead of auto-generating "
"it\n"
"    __tablename__ = \"author\"  #  type: ignore[assignment]\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date | None]\n"
"    books: Mapped[list[BookModel]] = relationship(back_populates=\"author\", "
"lazy=\"noload\")\n"
"\n"
"\n"
"# The `UUIDAuditBase` class includes the same UUID` based primary key (`id`) "
"and 2\n"
"# additional columns: `created_at` and `updated_at`. `created_at` is a "
"timestamp of when the\n"
"# record created, and `updated_at` is the last time the record was "
"modified.\n"
"class BookModel(base.UUIDAuditBase):\n"
"    __tablename__ = \"book\"  #  type: ignore[assignment]\n"
"    title: Mapped[str]\n"
"    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n"
"    author: Mapped[AuthorModel] = relationship(lazy=\"joined\", "
"innerjoin=True, viewonly=True)\n"
"\n"
"\n"
"# we will explicitly define the schema instead of using DTO objects for "
"clarity.\n"
"\n"
"\n"
"class Author(BaseModel):\n"
"    id: UUID | None\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorCreate(BaseModel):\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorUpdate(BaseModel):\n"
"    name: str | None = None\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemyAsyncRepository[AuthorModel]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = AuthorModel\n"
"\n"
"\n"
"async def provide_authors_repo(db_session: AsyncSession) -> "
"AuthorRepository:\n"
"    \"\"\"This provides the default Authors repository.\"\"\"\n"
"    return AuthorRepository(session=db_session)\n"
"\n"
"\n"
"# we can optionally override the default `select` used for the repository to "
"pass in\n"
"# specific SQL options such as join details\n"
"async def provide_author_details_repo(db_session: AsyncSession) -> "
"AuthorRepository:\n"
"    \"\"\"This provides a simple example demonstrating how to override the "
"join options for the repository.\"\"\"\n"
"    return AuthorRepository(\n"
"        statement=select(AuthorModel).options(selectinload(AuthorModel."
"books)),\n"
"        session=db_session,\n"
"    )\n"
"\n"
"\n"
"def provide_limit_offset_pagination(\n"
"    current_page: int = Parameter(ge=1, query=\"currentPage\", default=1, "
"required=False),\n"
"    page_size: int = Parameter(\n"
"        query=\"pageSize\",\n"
"        ge=1,\n"
"        default=10,\n"
"        required=False,\n"
"    ),\n"
") -> filters.LimitOffset:\n"
"    \"\"\"Add offset/limit pagination.\n"
"\n"
"    Return type consumed by `Repository.apply_limit_offset_pagination()`.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    current_page : int\n"
"        LIMIT to apply to select.\n"
"    page_size : int\n"
"        OFFSET to apply to select.\n"
"    \"\"\"\n"
"    return filters.LimitOffset(page_size, page_size * (current_page - 1))\n"
"\n"
"\n"
"class AuthorController(Controller):\n"
"    \"\"\"Author CRUD\"\"\"\n"
"\n"
"    dependencies = {\"authors_repo\": Provide(provide_authors_repo)}\n"
"\n"
"    @get(path=\"/authors\")\n"
"    async def list_authors(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        limit_offset: filters.LimitOffset,\n"
"    ) -> OffsetPagination[Author]:\n"
"        \"\"\"List authors.\"\"\"\n"
"        results, total = await authors_repo.list_and_count(limit_offset)\n"
"        type_adapter = TypeAdapter(list[Author])\n"
"        return OffsetPagination[Author](\n"
"            items=type_adapter.validate_python(results),\n"
"            total=total,\n"
"            limit=limit_offset.limit,\n"
"            offset=limit_offset.offset,\n"
"        )\n"
"\n"
"    @post(path=\"/authors\")\n"
"    async def create_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorCreate,\n"
"    ) -> Author:\n"
"        \"\"\"Create a new author.\"\"\"\n"
"        obj = await authors_repo.add(\n"
"            AuthorModel(**data.model_dump(exclude_unset=True, "
"exclude_none=True)),\n"
"        )\n"
"        await authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    # we override the authors_repo to use the version that joins the Books "
"in\n"
"    @get(path=\"/authors/{author_id:uuid}\", dependencies={\"authors_repo\": "
"Provide(provide_author_details_repo)})\n"
"    async def get_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to retrieve.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Get an existing author.\"\"\"\n"
"        obj = await authors_repo.get(author_id)\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @patch(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": "
"Provide(provide_author_details_repo)},\n"
"    )\n"
"    async def update_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorUpdate,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to update.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Update an author.\"\"\"\n"
"        raw_obj = data.model_dump(exclude_unset=True, exclude_none=True)\n"
"        raw_obj.update({\"id\": author_id})\n"
"        obj = await authors_repo.update(AuthorModel(**raw_obj))\n"
"        await authors_repo.session.commit()\n"
"        return Author.from_orm(obj)\n"
"\n"
"    @delete(path=\"/authors/{author_id:uuid}\")\n"
"    async def delete_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to delete.\",\n"
"        ),\n"
"    ) -> None:\n"
"        \"\"\"Delete a author from the system.\"\"\"\n"
"        _ = await authors_repo.delete(author_id)\n"
"        await authors_repo.session.commit()\n"
"\n"
"\n"
"session_config = AsyncSessionConfig(expire_on_commit=False)\n"
"sqlalchemy_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"session_config=session_config\n"
")  # Create 'db_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.get_engine().begin() as conn:\n"
"        await conn.run_sync(base.UUIDBase.metadata.create_all)\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[AuthorController],\n"
"    on_startup=[on_startup],\n"
"    plugins=[SQLAlchemyInitPlugin(config=sqlalchemy_config)],\n"
"    dependencies={\"limit_offset\": "
"Provide(provide_limit_offset_pagination)},\n"
")"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:72
msgid ""
"Alternately, you may use the ``SQLAlchemySyncRepository`` class for your "
"synchronous database connection."
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:75
msgid "``sqlalchemy_sync_repository.py``"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:75
msgid ""
"from __future__ import annotations\n"
"\n"
"from datetime import date\n"
"from typing import TYPE_CHECKING\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel as _BaseModel\n"
"from pydantic import TypeAdapter\n"
"from sqlalchemy import ForeignKey, select\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship, "
"selectinload\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.controller import Controller\n"
"from litestar.di import Provide\n"
"from litestar.handlers.http_handlers.decorators import delete, patch, post\n"
"from litestar.pagination import OffsetPagination\n"
"from litestar.params import Parameter\n"
"from litestar.plugins.sqlalchemy import (\n"
"    SQLAlchemyInitPlugin,\n"
"    SQLAlchemySyncConfig,\n"
"    base,\n"
"    repository,\n"
")\n"
"from litestar.repository.filters import LimitOffset\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.orm import Session\n"
"\n"
"\n"
"class BaseModel(_BaseModel):\n"
"    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n"
"\n"
"    model_config = {\"from_attributes\": True}\n"
"\n"
"\n"
"# The SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `UUIDBase` class includes a `UUID` based primary key (`id`)\n"
"class AuthorModel(base.UUIDBase):\n"
"    # we can optionally provide the table name instead of auto-generating "
"it\n"
"    __tablename__ = \"author\"  #  type: ignore[assignment]\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date | None]\n"
"    books: Mapped[list[BookModel]] = relationship(back_populates=\"author\", "
"lazy=\"noload\")\n"
"\n"
"\n"
"# The `UUIDAuditBase` class includes the same UUID` based primary key (`id`) "
"and 2\n"
"# additional columns: `created_at` and `updated_at`. `created_at` is a "
"timestamp of when the\n"
"# record created, and `updated_at` is the last time the record was "
"modified.\n"
"class BookModel(base.UUIDAuditBase):\n"
"    __tablename__ = \"book\"  #  type: ignore[assignment]\n"
"    title: Mapped[str]\n"
"    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n"
"    author: Mapped[AuthorModel] = relationship(lazy=\"joined\", "
"innerjoin=True, viewonly=True)\n"
"\n"
"\n"
"# we will explicitly define the schema instead of using DTO objects for "
"clarity.\n"
"\n"
"\n"
"class Author(BaseModel):\n"
"    id: UUID | None\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorCreate(BaseModel):\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorUpdate(BaseModel):\n"
"    name: str | None = None\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemySyncRepository[AuthorModel]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = AuthorModel\n"
"\n"
"\n"
"async def provide_authors_repo(db_session: Session) -> AuthorRepository:\n"
"    \"\"\"This provides the default Authors repository.\"\"\"\n"
"    return AuthorRepository(session=db_session)\n"
"\n"
"\n"
"# we can optionally override the default `select` used for the repository to "
"pass in\n"
"# specific SQL options such as join details\n"
"async def provide_author_details_repo(db_session: Session) -> "
"AuthorRepository:\n"
"    \"\"\"This provides a simple example demonstrating how to override the "
"join options\n"
"    for the repository.\"\"\"\n"
"    return AuthorRepository(\n"
"        statement=select(AuthorModel).options(selectinload(AuthorModel."
"books)),\n"
"        session=db_session,\n"
"    )\n"
"\n"
"\n"
"def provide_limit_offset_pagination(\n"
"    current_page: int = Parameter(ge=1, query=\"currentPage\", default=1, "
"required=False),\n"
"    page_size: int = Parameter(\n"
"        query=\"pageSize\",\n"
"        ge=1,\n"
"        default=10,\n"
"        required=False,\n"
"    ),\n"
") -> LimitOffset:\n"
"    \"\"\"Add offset/limit pagination.\n"
"\n"
"    Return type consumed by `Repository.apply_limit_offset_pagination()`.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    current_page : int\n"
"        LIMIT to apply to select.\n"
"    page_size : int\n"
"        OFFSET to apply to select.\n"
"    \"\"\"\n"
"    return LimitOffset(page_size, page_size * (current_page - 1))\n"
"\n"
"\n"
"class AuthorController(Controller):\n"
"    \"\"\"Author CRUD\"\"\"\n"
"\n"
"    dependencies = {\"authors_repo\": Provide(provide_authors_repo, "
"sync_to_thread=False)}\n"
"\n"
"    @get(path=\"/authors\")\n"
"    def list_authors(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        limit_offset: LimitOffset,\n"
"    ) -> OffsetPagination[Author]:\n"
"        \"\"\"List authors.\"\"\"\n"
"        results, total = authors_repo.list_and_count(limit_offset)\n"
"        type_adapter = TypeAdapter(list[Author])\n"
"        return OffsetPagination[Author](\n"
"            items=type_adapter.validate_python(results),\n"
"            total=total,\n"
"            limit=limit_offset.limit,\n"
"            offset=limit_offset.offset,\n"
"        )\n"
"\n"
"    @post(path=\"/authors\")\n"
"    def create_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorCreate,\n"
"    ) -> Author:\n"
"        \"\"\"Create a new author.\"\"\"\n"
"        obj = authors_repo.add(\n"
"            AuthorModel(**data.model_dump(exclude_unset=True, "
"exclude_none=True)),\n"
"        )\n"
"        authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    # we override the authors_repo to use the version that joins the Books "
"in\n"
"    @get(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": Provide(provide_author_details_repo, "
"sync_to_thread=False)},\n"
"    )\n"
"    def get_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to retrieve.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Get an existing author.\"\"\"\n"
"        obj = authors_repo.get(author_id)\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @patch(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": Provide(provide_author_details_repo, "
"sync_to_thread=False)},\n"
"    )\n"
"    def update_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorUpdate,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to update.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Update an author.\"\"\"\n"
"        raw_obj = data.model_dump(exclude_unset=True, exclude_none=True)\n"
"        raw_obj.update({\"id\": author_id})\n"
"        obj = authors_repo.update(AuthorModel(**raw_obj))\n"
"        authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @delete(path=\"/authors/{author_id:uuid}\")\n"
"    def delete_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to delete.\",\n"
"        ),\n"
"    ) -> None:\n"
"        \"\"\"Delete a author from the system.\"\"\"\n"
"        _ = authors_repo.delete(author_id)\n"
"        authors_repo.session.commit()\n"
"\n"
"\n"
"sqlalchemy_config = SQLAlchemySyncConfig(connection_string=\"sqlite:///test."
"sqlite\")  # Create 'db_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    with sqlalchemy_config.get_engine().begin() as conn:\n"
"        base.UUIDBase.metadata.create_all(conn)\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[AuthorController],\n"
"    on_startup=[on_startup],\n"
"    plugins=[SQLAlchemyInitPlugin(config=sqlalchemy_config)],\n"
"    dependencies={\"limit_offset\": "
"Provide(provide_limit_offset_pagination)},\n"
")"
msgstr ""

#: ../../../usage/databases/sqlalchemy/models_and_repository.rst:80
msgid ":doc:`/tutorials/repository-tutorial/index`"
msgstr ""
