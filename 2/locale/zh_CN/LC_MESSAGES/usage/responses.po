# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/responses.rst:2
msgid "Responses"
msgstr ""

#: ../../../usage/responses.rst:4
msgid ""
"Litestar allows for several ways in which HTTP responses can be specified "
"and handled, each fitting a different use case. The base pattern though is "
"straightforward - simply return a value from a route handler function and "
"let Litestar take care of the rest:"
msgstr ""

#: ../../../usage/responses.rst:9
msgid ""
"from pydantic import BaseModel\n"
"from litestar import get\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\")\n"
"def retrieve_resource() -> Resource:\n"
"    return Resource(id=1, name=\"my resource\")"
msgstr ""

#: ../../../usage/responses.rst:23
msgid ""
"In the example above, the route handler function returns an instance of the "
"``Resource`` pydantic class. This value will then be used by Litestar to "
"construct an instance of the :class:`Response <litestar.response.Response>` "
"class using defaults values: the response status code will be set to ``200`` "
"and it's ``Content-Type`` header will be set to ``application/json``. The "
"``Resource`` instance will be serialized into JSON and set as the response "
"body."
msgstr ""

#: ../../../usage/responses.rst:31
msgid "Media Type"
msgstr ""

#: ../../../usage/responses.rst:33
msgid ""
"You do not have to specify the ``media_type`` kwarg in the route handler "
"function if the response should be JSON. But if you wish to return a "
"response other than JSON, you should specify this value. You can use the :"
"class:`MediaType <litestar.enums.MediaType>` enum for this purpose:"
msgstr ""

#: ../../../usage/responses.rst:38
msgid ""
"from litestar import MediaType, get\n"
"\n"
"\n"
"@get(\"/resources\", media_type=MediaType.TEXT)\n"
"def retrieve_resource() -> str:\n"
"    return \"The rumbling rabbit ran around the rock\""
msgstr ""

#: ../../../usage/responses.rst:46
msgid ""
"The value of the ``media_type`` kwarg affects both the serialization of "
"response data and the generation of OpenAPI docs. The above example will "
"cause Litestar to serialize the response as a simple bytes string with a "
"``Content-Type`` header value of ``text/plain``. It will also set the "
"corresponding values in the OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:50
msgid "MediaType has the following members:"
msgstr ""

#: ../../../usage/responses.rst:53
msgid "MediaType.JSON: ``application/json``"
msgstr ""

#: ../../../usage/responses.rst:54
msgid "MediaType.MessagePack: ``application/x-msgpack``"
msgstr ""

#: ../../../usage/responses.rst:55
msgid "MediaType.TEXT: ``text/plain``"
msgstr ""

#: ../../../usage/responses.rst:56
msgid "MediaType.HTML: ``text/html``"
msgstr ""

#: ../../../usage/responses.rst:58
msgid ""
"You can also set any `IANA referenced <https://www.iana.org/assignments/"
"media-types/media-types.xhtml>`_ media type string as the ``media_type``. "
"While this will still affect the OpenAPI generation as expected, you might "
"need to handle serialization using either a :ref:`custom response <usage/"
"responses:Custom Responses>` with serializer or by serializing the value in "
"the route handler function."
msgstr ""

#: ../../../usage/responses.rst:64
msgid "JSON responses"
msgstr ""

#: ../../../usage/responses.rst:66
msgid ""
"As previously mentioned, the default ``media_type`` is ``MediaType.JSON``. "
"which supports the following values:"
msgstr ""

#: ../../../usage/responses.rst:68
msgid ":doc:`dataclasses <python:library/dataclasses>`"
msgstr ""

#: ../../../usage/responses.rst:69
msgid "`pydantic dataclasses <https://docs.pydantic.dev/usage/dataclasses/>`_"
msgstr ""

#: ../../../usage/responses.rst:70
msgid "`pydantic models <https://docs.pydantic.dev/usage/models/>`_"
msgstr ""

#: ../../../usage/responses.rst:71
msgid "models from libraries that extend pydantic models"
msgstr ""

#: ../../../usage/responses.rst:72
msgid ":class:`UUIDs <uuid.UUID>`"
msgstr ""

#: ../../../usage/responses.rst:73
msgid ":doc:`datetime objects <python:library/datetime>`"
msgstr ""

#: ../../../usage/responses.rst:74
msgid "`msgspec.Struct <https://jcristharif.com/msgspec/structs.html>`_"
msgstr ""

#: ../../../usage/responses.rst:75
msgid ""
"container types such as :class:`dict` or :class:`list` containing supported "
"types"
msgstr ""

#: ../../../usage/responses.rst:77
msgid ""
"If you need to return other values and would like to extend serialization "
"you can do this :ref:`custom responses <usage/responses:Custom Responses>`."
msgstr ""

#: ../../../usage/responses.rst:80
msgid ""
"You can also set an application media type string with the ``+json`` suffix "
"defined in `RFC 6839 <https://datatracker.ietf.org/doc/html/"
"rfc6839#section-3.1>`_ as the ``media_type`` and it will be recognized and "
"serialized as json."
msgstr ""

#: ../../../usage/responses.rst:84
msgid ""
"For example, you can use ``application/vnd.example.resource+json`` and it "
"will work just like json but have the appropriate content-type header and "
"show up in the generated OpenAPI schema."
msgstr ""

#: ../../../usage/responses.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/responses.rst:89
msgid ""
"from typing import Any, Dict\n"
"\n"
"import litestar.status_codes\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    status_code=litestar.status_codes.HTTP_418_IM_A_TEAPOT,\n"
"    media_type=\"application/vnd.example.resource+json\",\n"
")\n"
"async def retrieve_resource() -> Dict[str, Any]:\n"
"    return {\n"
"        \"title\": \"Server thinks it is a teapot\",\n"
"        \"type\": \"Server delusion\",\n"
"        \"status\": litestar.status_codes.HTTP_418_IM_A_TEAPOT,\n"
"    }\n"
"\n"
"\n"
"app = Litestar(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/responses.rst:89
msgid ""
"from typing import Any\n"
"\n"
"import litestar.status_codes\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    status_code=litestar.status_codes.HTTP_418_IM_A_TEAPOT,\n"
"    media_type=\"application/vnd.example.resource+json\",\n"
")\n"
"async def retrieve_resource() -> dict[str, Any]:\n"
"    return {\n"
"        \"title\": \"Server thinks it is a teapot\",\n"
"        \"type\": \"Server delusion\",\n"
"        \"status\": litestar.status_codes.HTTP_418_IM_A_TEAPOT,\n"
"    }\n"
"\n"
"\n"
"app = Litestar(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:92
msgid "MessagePack responses"
msgstr ""

#: ../../../usage/responses.rst:94
msgid ""
"In addition to JSON, Litestar offers support for the `MessagePack <https://"
"msgpack.org/>`_ format which can be a time and space efficient alternative "
"to JSON."
msgstr ""

#: ../../../usage/responses.rst:97
msgid ""
"It supports all the same types as JSON serialization. To send a "
"``MessagePack`` response, simply specify the media type as ``MediaType."
"MESSAGEPACK``\\ :"
msgstr ""

#: ../../../usage/responses.rst:101
msgid ""
"from typing import Dict\n"
"from litestar import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.MESSAGEPACK)\n"
"def health_check() -> Dict[str, str]:\n"
"    return {\"hello\": \"world\"}"
msgstr ""

#: ../../../usage/responses.rst:101
msgid ""
"from litestar import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.MESSAGEPACK)\n"
"def health_check() -> dict[str, str]:\n"
"    return {\"hello\": \"world\"}"
msgstr ""

#: ../../../usage/responses.rst:111
msgid "Plaintext responses"
msgstr ""

#: ../../../usage/responses.rst:113
msgid ""
"For ``MediaType.TEXT``, route handlers should return a :class:`str` or :"
"class:`bytes` value:"
msgstr ""

#: ../../../usage/responses.rst:116
msgid ""
"from litestar import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT)\n"
"def health_check() -> str:\n"
"    return \"healthy\""
msgstr ""

#: ../../../usage/responses.rst:125
msgid "HTML responses"
msgstr ""

#: ../../../usage/responses.rst:127
msgid ""
"For ``MediaType.HTML``, route handlers should return a :class:`str` or :"
"class:`bytes` value that contains HTML:"
msgstr ""

#: ../../../usage/responses.rst:130
msgid ""
"from litestar import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/page\", media_type=MediaType.HTML)\n"
"def health_check() -> str:\n"
"    return \"\"\"\n"
"    <html>\n"
"        <body>\n"
"            <div>\n"
"                <span>Hello World!</span>\n"
"            </div>\n"
"        </body>\n"
"    </html>\n"
"    \"\"\""
msgstr ""

#: ../../../usage/responses.rst:148
msgid ""
"It's a good idea to use a :ref:`template engine <usage/templating:template "
"engines>` for more complex HTML responses and to write the template itself "
"in a separate file rather than a string."
msgstr ""

#: ../../../usage/responses.rst:153
msgid "Content Negotiation"
msgstr ""

#: ../../../usage/responses.rst:155
msgid ""
"If your handler can return data with different media types and you want to "
"use `Content Negotiation <https://developer.mozilla.org/en-US/docs/Web/HTTP/"
"Content_negotiation>`_ to allow the client to choose which type to return, "
"you can use the :attr:`Request.accept <litestar.connection.Request.accept>` "
"property to calculate the best matching return media type."
msgstr ""

#: ../../../usage/responses.rst:162
msgid ""
"from litestar import Litestar, MediaType, Request, Response, get\n"
"\n"
"\n"
"@get(\"/resource\", sync_to_thread=False)\n"
"def retrieve_resource(request: Request) -> Response[bytes]:\n"
"    provided_types = [MediaType.TEXT, MediaType.HTML, \"application/xml\"]\n"
"    preferred_type = request.accept.best_match(provided_types, "
"default=MediaType.TEXT)\n"
"\n"
"    content = None\n"
"    if preferred_type == MediaType.TEXT:\n"
"        content = b\"Hello World!\"\n"
"    elif preferred_type == MediaType.HTML:\n"
"        content = b\"<h1>Hello World!</h1>\"\n"
"    elif preferred_type == \"application/xml\":\n"
"        content = b\"<xml><msg>Hello World!</msg></xml>\"\n"
"    return Response(content=content, media_type=preferred_type)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/resource\n"
"Hello World!\n"
"> curl http://127.0.0.1:8000/resource -H Accept: text/html\n"
"<h1>Hello World!</h1>\n"
"> curl http://127.0.0.1:8000/resource -H Accept: application/xml\n"
"<xml><msg>Hello World!</msg></xml>"
msgstr ""

#: ../../../usage/responses.rst:166
msgid "Status Codes"
msgstr ""

#: ../../../usage/responses.rst:168
msgid ""
"You can control the response ``status_code`` by setting the corresponding "
"kwarg to the desired value:"
msgstr ""

#: ../../../usage/responses.rst:171
msgid ""
"from pydantic import BaseModel\n"
"from litestar import get\n"
"from litestar.status_codes import HTTP_202_ACCEPTED\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\", status_code=HTTP_202_ACCEPTED)\n"
"def retrieve_resource() -> Resource:\n"
"    return Resource(id=1, name=\"my resource\")"
msgstr ""

#: ../../../usage/responses.rst:186
msgid ""
"If ``status_code`` is not set by the user, the following defaults are used:"
msgstr ""

#: ../../../usage/responses.rst:189
msgid "POST: 201 (Created)"
msgstr ""

#: ../../../usage/responses.rst:190
msgid "DELETE: 204 (No Content)"
msgstr ""

#: ../../../usage/responses.rst:191
msgid "GET, PATCH, PUT: 200 (Ok)"
msgstr ""

#: ../../../usage/responses.rst:195
msgid ""
"For status codes < 100 or 204, 304 statuses, no response body is allowed. If "
"you specify a return annotation other than ``None``, an :class:"
"`ImproperlyConfiguredException <litestar.exceptions."
"ImproperlyConfiguredException>` will be raised."
msgstr ""

#: ../../../usage/responses.rst:200
msgid ""
"When using the ``route`` decorator with multiple http methods, the default "
"status code is ``200``. The default for ``delete`` is ``204`` because by "
"default it is assumed that delete operations return no data. This though "
"might not be the case in your implementation - so take care of setting it as "
"you see fit."
msgstr ""

#: ../../../usage/responses.rst:206
msgid ""
"While you can write integers as the value for ``status_code``, e.g. ``200``, "
"it's best practice to use constants (also in tests). Litestar includes easy "
"to use statuses that are exported from ``litestar.status_codes``, e.g. "
"``HTTP_200_OK`` and ``HTTP_201_CREATED``. Another option is the :class:`http."
"HTTPStatus` enum from the standard library, which also offers extra "
"functionality."
msgstr ""

#: ../../../usage/responses.rst:213
msgid "Returning responses"
msgstr ""

#: ../../../usage/responses.rst:215
msgid ""
"While the default response handling fits most use cases, in some cases you "
"need to be able to return a response instance directly."
msgstr ""

#: ../../../usage/responses.rst:218
msgid ""
"Litestar allows you to return any class inheriting from the :class:`Response "
"<litestar.response.Response>` class. Thus, the below example will work "
"perfectly fine:"
msgstr ""

#: ../../../usage/responses.rst:222
msgid ""
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\", sync_to_thread=False)\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"MY-HEADER\": \"xyz\"},\n"
"        cookies=[Cookie(key=\"my-cookie\", value=\"abc\")],\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:227
msgid ""
"In the case of the builtin :class:`Template <litestar.response.Template>`, :"
"class:`File <litestar.response.File>`, :class:`Stream <litestar.response."
"Stream>`, and :class:`Redirect <litestar.response.Redirect>` you should use "
"the response \"response containers\", otherwise OpenAPI documentation will "
"not be generated correctly. For more details see the respective "
"documentation sections:"
msgstr ""

#: ../../../usage/responses.rst:232
msgid "`Template responses`_"
msgstr ""

#: ../../../usage/responses.rst:233
msgid "`File responses`_"
msgstr ""

#: ../../../usage/responses.rst:234
msgid "`Streaming responses`_"
msgstr ""

#: ../../../usage/responses.rst:235
msgid "`Redirect responses`_"
msgstr ""

#: ../../../usage/responses.rst:239
msgid "Annotating responses"
msgstr ""

#: ../../../usage/responses.rst:241
msgid ""
"As you can see above, the :class:`Response <litestar.response.Response>` "
"class accepts a generic argument. This allows Litestar to infer the response "
"body when generating the OpenAPI docs."
msgstr ""

#: ../../../usage/responses.rst:246
msgid ""
"If the generic argument is not provided, and thus defaults to ``Any``, the "
"OpenAPI docs will be imprecise. So make sure to type this argument even when "
"returning an empty or ``null`` body, i.e. use ``None``."
msgstr ""

#: ../../../usage/responses.rst:250
msgid "Returning ASGI Applications"
msgstr ""

#: ../../../usage/responses.rst:252
msgid ""
"Litestar also supports returning ASGI applications directly, as you would "
"responses. For example:"
msgstr ""

#: ../../../usage/responses.rst:255
msgid ""
"from litestar import get\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"@get(\"/\")\n"
"def handler() -> ASGIApp:\n"
"    async def my_asgi_app(scope: Scope, receive: Receive, send: Send) -> "
"None: ...\n"
"\n"
"    return my_asgi_app"
msgstr ""

#: ../../../usage/responses.rst:267
msgid "What is an ASGI Application?"
msgstr ""

#: ../../../usage/responses.rst:269
msgid ""
"An ASGI application in this context is any async callable (function, class "
"method or simply a class that implements that special :meth:`object."
"__call__` dunder method) that accepts the three ASGI arguments: ``scope``, "
"``receive``, and ``send``."
msgstr ""

#: ../../../usage/responses.rst:273
msgid "For example, all the following examples are ASGI applications:"
msgstr ""

#: ../../../usage/responses.rst:276
msgid "Function ASGI Application"
msgstr ""

#: ../../../usage/responses.rst:279
msgid ""
"from litestar.types import Receive, Scope, Send\n"
"\n"
"\n"
"async def my_asgi_app_function(scope: Scope, receive: Receive, send: Send) -"
"> None:\n"
"    # do something here\n"
"    ..."
msgstr ""

#: ../../../usage/responses.rst:288
msgid "Method ASGI Application"
msgstr ""

#: ../../../usage/responses.rst:291
msgid ""
"from litestar.types import Receive, Scope, Send\n"
"\n"
"\n"
"class MyClass:\n"
"    async def my_asgi_app_method(\n"
"        self, scope: Scope, receive: Receive, send: Send\n"
"    ) -> None:\n"
"        # do something here\n"
"        ..."
msgstr ""

#: ../../../usage/responses.rst:303
msgid "Class ASGI Application"
msgstr ""

#: ../../../usage/responses.rst:306
msgid ""
"from litestar.types import Receive, Scope, Send\n"
"\n"
"\n"
"class ASGIApp:\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ..."
msgstr ""

#: ../../../usage/responses.rst:316
msgid "Returning responses from third party libraries"
msgstr ""

#: ../../../usage/responses.rst:318
msgid ""
"Because you can return any ASGI Application from a route handler, you can "
"also use any ASGI application from other libraries. For example, you can "
"return the response classes from Starlette or FastAPI directly from route "
"handlers:"
msgstr ""

#: ../../../usage/responses.rst:322
msgid ""
"from starlette.responses import JSONResponse\n"
"\n"
"from litestar import get\n"
"from litestar.types import ASGIApp\n"
"\n"
"\n"
"@get(\"/\")\n"
"def handler() -> ASGIApp:\n"
"    return JSONResponse(content={\"hello\": \"world\"})  # type: ignore"
msgstr ""

#: ../../../usage/responses.rst:335
msgid ""
"Litestar offers strong typing for the ASGI arguments. Other libraries often "
"offer less strict typing, which might cause type checkers to complain when "
"using ASGI apps from them inside Litestar. For the time being, the only "
"solution is to add ``# type: ignore`` comments in the pertinent places. "
"Nonetheless, the above example will work perfectly fine."
msgstr ""

#: ../../../usage/responses.rst:342
msgid "Setting Response Headers"
msgstr ""

#: ../../../usage/responses.rst:344
msgid ""
"Litestar allows you to define response headers by using the "
"``response_headers`` kwarg. This kwarg is available on all layers of the app "
"- individual route handlers, controllers, routers, and the app itself:"
msgstr ""

#: ../../../usage/responses.rst:349
msgid ""
"from litestar import Controller, Litestar, MediaType, Router, get\n"
"from litestar.datastructures import ResponseHeader\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller-path\"\n"
"    response_headers = [\n"
"        ResponseHeader(name=\"controller-level-header\", value=\"controller "
"header\", description=\"controller level header\")\n"
"    ]\n"
"\n"
"    @get(\n"
"        path=\"/handler-path\",\n"
"        response_headers=[\n"
"            ResponseHeader(name=\"my-local-header\", value=\"local header\", "
"description=\"local level header\")\n"
"        ],\n"
"        media_type=MediaType.TEXT,\n"
"        sync_to_thread=False,\n"
"    )\n"
"    def my_route_handler(self) -> str:\n"
"        return \"hello world\"\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[MyController],\n"
"    response_headers=[\n"
"        ResponseHeader(name=\"router-level-header\", value=\"router "
"header\", description=\"router level header\")\n"
"    ],\n"
")\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[router],\n"
"    response_headers=[ResponseHeader(name=\"app-level-header\", value=\"app "
"header\", description=\"app level header\")],\n"
")"
msgstr ""

#: ../../../usage/responses.rst:352
msgid ""
"In the above example the response returned from ``my_route_handler`` will "
"have headers set from each layer of the application using the given "
"key+value combinations. I.e. it will be a dictionary equal to this:"
msgstr ""

#: ../../../usage/responses.rst:355
msgid ""
"{\n"
"  \"my-local-header\": \"local header\",\n"
"  \"controller-level-header\": \"controller header\",\n"
"  \"router-level-header\": \"router header\",\n"
"  \"app-level-header\": \"app header\"\n"
"}"
msgstr ""

#: ../../../usage/responses.rst:364
msgid "The respective descriptions will be used for the OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:369
msgid ""
":class:`ResponseHeader <litestar.datastructures.response_header."
"ResponseHeader>` is a special class that allows to add OpenAPI attributes "
"such as `description` or `documentation_only`. If you don't need those, you "
"can optionally define `response_headers` using a mapping - such as a "
"dictionary - as well:"
msgstr ""

#: ../../../usage/responses.rst:375
msgid ""
"@get(response_headers={\"my-header\": \"header-value\"})\n"
"async def handler() -> str: ..."
msgstr ""

#: ../../../usage/responses.rst:382
msgid "Setting Headers Dynamically"
msgstr ""

#: ../../../usage/responses.rst:384
msgid ""
"The above detailed scheme works great for statically configured headers, but "
"how would you go about handling dynamically setting headers? Litestar allows "
"you to set headers dynamically in several ways and below we will detail the "
"two primary patterns."
msgstr ""

#: ../../../usage/responses.rst:389 ../../../usage/responses.rst:540
msgid "Using Annotated Responses"
msgstr ""

#: ../../../usage/responses.rst:391
msgid ""
"We can simply return a response instance directly from the route handler and "
"set the headers dictionary manually as you see fit, e.g.:"
msgstr ""

#: ../../../usage/responses.rst:395
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.datastructures import ResponseHeader\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_headers=[\n"
"        ResponseHeader(\n"
"            name=\"Random-Header\", description=\"a random number in the "
"range 1 - 100\", documentation_only=True\n"
"        )\n"
"    ],\n"
"    sync_to_thread=False,\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"Random-Header\": str(randint(1, 100))},\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:398
msgid ""
"In the above we use the ``response_headers`` kwarg to pass the ``name`` and "
"``description`` parameters for the ``Random-Header`` to the OpenAPI "
"documentation, but we set the value dynamically in as part of the :ref:"
"`annotated response <usage/responses:annotating responses>` we return. To "
"this end we do not set a ``value`` for it and we designate it as "
"``documentation_only=True``."
msgstr ""

#: ../../../usage/responses.rst:404 ../../../usage/responses.rst:555
msgid "Using the After Request Hook"
msgstr ""

#: ../../../usage/responses.rst:406
msgid ""
"An alternative pattern would be to use an :ref:`after request handler "
"<after_request>`. We can define the handler on different layers of the "
"application as explained in the pertinent docs. We should take care to "
"document the headers on the corresponding layer:"
msgstr ""

#: ../../../usage/responses.rst:411
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, Router, get\n"
"from litestar.datastructures import ResponseHeader\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_headers=[\n"
"        ResponseHeader(\n"
"            name=\"Random-Header\",\n"
"            description=\"a random number in the range 100 - 1000\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
"    sync_to_thread=False,\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"Random-Header\": str(randint(100, 1000))},\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.headers.update({\"Random-Header\": str(randint(1, 100))})\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_headers=[\n"
"        ResponseHeader(\n"
"            name=\"Random-Header\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"\n"
"\n"
"app = Litestar(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:414
msgid ""
"In the above we set the response header using an ``after_request_handler`` "
"function on the router level. Because the handler function is applied on the "
"router, we also set the documentation for it on the router."
msgstr ""

#: ../../../usage/responses.rst:417
msgid ""
"We can use this pattern to fine-tune the OpenAPI documentation more "
"granularly by overriding header specification as required. For example, lets "
"say we have a router level header being set and a local header with the same "
"key but a different value range:"
msgstr ""

#: ../../../usage/responses.rst:422
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, Router, get\n"
"from litestar.datastructures import ResponseHeader\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_headers=[\n"
"        ResponseHeader(\n"
"            name=\"Random-Header\",\n"
"            description=\"a random number in the range 100 - 1000\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
"    sync_to_thread=False,\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"Random-Header\": str(randint(100, 1000))},\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.headers.update({\"Random-Header\": str(randint(1, 100))})\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_headers=[\n"
"        ResponseHeader(\n"
"            name=\"Random-Header\", description=\"a random number in the "
"range 1 - 100\", documentation_only=True\n"
"        )\n"
"    ],\n"
")\n"
"\n"
"app = Litestar(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:426
msgid "Predefined Headers"
msgstr ""

#: ../../../usage/responses.rst:428
msgid ""
"Litestar has a dedicated implementation for a few commonly used headers. "
"These headers can be set separately with dedicated keyword arguments or as "
"class attributes on all layers of the app (individual route handlers, "
"controllers, routers, and the app itself). Each layer overrides the layer "
"above it - thus, the headers defined for a specific route handler will "
"override those defined on its router, which will in turn override those "
"defined on the app level."
msgstr ""

#: ../../../usage/responses.rst:433
msgid ""
"These header implementations allow easy creating, serialization and parsing "
"according to the associated header specifications."
msgstr ""

#: ../../../usage/responses.rst:437
msgid "Cache Control"
msgstr ""

#: ../../../usage/responses.rst:439
msgid ""
":class:`CacheControlHeader <.datastructures.headers.CacheControlHeader>` "
"represents a `Cache-Control Header <https://developer.mozilla.org/en-US/docs/"
"Web/HTTP/Headers/Cache-Control>`_."
msgstr ""

#: ../../../usage/responses.rst:442
msgid "Here is a simple example that shows how to use it:"
msgstr ""

#: ../../../usage/responses.rst:445
msgid "Cache Control Header"
msgstr ""

#: ../../../usage/responses.rst:445
msgid ""
"import time\n"
"\n"
"from litestar import Controller, Litestar, get\n"
"from litestar.datastructures import CacheControlHeader\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    cache_control = CacheControlHeader(max_age=86_400, public=True)\n"
"\n"
"    @get(\"/chance_of_rain\", sync_to_thread=False)\n"
"    def get_chance_of_rain(self) -> float:\n"
"        \"\"\"This endpoint uses the cache control value defined in the "
"controller which overrides the app value.\"\"\"\n"
"        return 0.5\n"
"\n"
"    @get(\"/timestamp\", cache_control=CacheControlHeader(no_store=True), "
"sync_to_thread=False)\n"
"    def get_server_time(self) -> float:\n"
"        \"\"\"This endpoint overrides the cache control value defined in the "
"controller.\"\"\"\n"
"        return time.time()\n"
"\n"
"\n"
"@get(\"/population\", sync_to_thread=False)\n"
"def get_population_count() -> int:\n"
"    \"\"\"This endpoint will use the cache control defined in the app."
"\"\"\"\n"
"    return 100000\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[MyController, get_population_count],\n"
"    cache_control=CacheControlHeader(max_age=2_628_288, public=True),\n"
")"
msgstr ""

#: ../../../usage/responses.rst:449
msgid ""
"In this example we have a ``cache-control`` with ``max-age`` of 1 month for "
"the whole app, a ``max-age`` of 1 day for all routes within "
"``MyController``, and ``no-store`` for one specific route "
"``get_server_time``. Here are the cache control values that will be returned "
"from each endpoint:"
msgstr ""

#: ../../../usage/responses.rst:454
msgid ""
"When calling ``/population`` the response will have ``cache-control`` with "
"``max-age=2628288`` (1 month)."
msgstr ""

#: ../../../usage/responses.rst:455
msgid ""
"When calling ``/chance_of_rain`` the response will have ``cache-control`` "
"with ``max-age=86400`` (1 day)."
msgstr ""

#: ../../../usage/responses.rst:456
msgid ""
"When calling ``/timestamp`` the response will have ``cache-control`` with "
"``no-store`` which means don't store the result in any cache."
msgstr ""

#: ../../../usage/responses.rst:460
msgid "ETag"
msgstr ""

#: ../../../usage/responses.rst:462
msgid ""
":class:`ETag <.datastructures.headers.ETag>` represents an `ETag header "
"<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag>`_."
msgstr ""

#: ../../../usage/responses.rst:465
msgid "Here are some usage examples:"
msgstr ""

#: ../../../usage/responses.rst:468
msgid "Returning ETag headers"
msgstr ""

#: ../../../usage/responses.rst:468
msgid ""
"import random\n"
"import time\n"
"\n"
"from litestar import Controller, Litestar, get\n"
"from litestar.datastructures import ETag\n"
"from litestar.enums import MediaType\n"
"from litestar.response import Response\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    etag = ETag(value=\"foo\")\n"
"\n"
"    @get(\"/chance_of_rain\")\n"
"    def get_chance_of_rain(self) -> float:\n"
"        \"\"\"This endpoint uses the etag value in the controller which "
"overrides the app value.\n"
"\n"
"        The returned header will be `etag: \"foo\"`\n"
"        \"\"\"\n"
"        return 0.5\n"
"\n"
"    @get(\"/timestamp\", etag=ETag(value=\"bar\"))\n"
"    def get_server_time(self) -> float:\n"
"        \"\"\"This endpoint overrides the etag defined in the controller.\n"
"\n"
"        The returned header will be `etag: W/\"bar\"`\n"
"        \"\"\"\n"
"        return time.time()\n"
"\n"
"\n"
"@get(\"/population\")\n"
"def get_population_count() -> int:\n"
"    \"\"\"This endpoint will use the etag defined in the app.\n"
"\n"
"    The returned header will be `etag: \"bar\"`\n"
"    \"\"\"\n"
"    return 100000\n"
"\n"
"\n"
"@get(\"/population-dynamic\", etag=ETag(documentation_only=True))\n"
"def get_population_count_dynamic() -> Response[str]:\n"
"    \"\"\"The etag defined in this route handler will not be returned, and "
"does not need a value.\n"
"\n"
"    It will only be used for OpenAPI generation.\n"
"    \"\"\"\n"
"    population_count = random.randint(0, 1000)\n"
"    return Response(\n"
"        content=str(population_count),\n"
"        headers={\"etag\": str(population_count)},\n"
"        media_type=MediaType.TEXT,\n"
"        status_code=200,\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[MyController, get_population_count], "
"etag=ETag(value=\"bar\"))"
msgstr ""

#: ../../../usage/responses.rst:473
msgid "Parsing ETag headers"
msgstr ""

#: ../../../usage/responses.rst:473
msgid ""
"from litestar.datastructures import ETag\n"
"\n"
"assert ETag.from_header('\"foo\"') == ETag(value=\"foo\")\n"
"assert ETag.from_header('W/\"foo\"') == ETag(value=\"foo\", weak=True)"
msgstr ""

#: ../../../usage/responses.rst:478
msgid "Setting Response Cookies"
msgstr ""

#: ../../../usage/responses.rst:480
msgid ""
"Litestar allows you to define response cookies by using the "
"``response_cookies`` kwarg. This kwarg is available on all layers of the app "
"- individual route handlers, controllers, routers, and the app itself:"
msgstr ""

#: ../../../usage/responses.rst:485
msgid ""
"from litestar import Controller, Litestar, MediaType, Router, get\n"
"from litestar.datastructures import Cookie\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller-path\"\n"
"    response_cookies = [\n"
"        Cookie(\n"
"            key=\"controller-cookie\",\n"
"            value=\"controller value\",\n"
"            description=\"controller level cookie\",\n"
"        )\n"
"    ]\n"
"\n"
"    @get(\n"
"        path=\"/\",\n"
"        response_cookies=[\n"
"            Cookie(\n"
"                key=\"local-cookie\",\n"
"                value=\"local value\",\n"
"                description=\"route handler level cookie\",\n"
"            )\n"
"        ],\n"
"        media_type=MediaType.TEXT,\n"
"        sync_to_thread=False,\n"
"    )\n"
"    def my_route_handler(self) -> str:\n"
"        return \"hello world\"\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[MyController],\n"
"    response_cookies=[Cookie(key=\"router-cookie\", value=\"router value\", "
"description=\"router level cookie\")],\n"
")\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[router],\n"
"    response_cookies=[Cookie(key=\"app-cookie\", value=\"app value\", "
"description=\"app level cookie\")],\n"
")"
msgstr ""

#: ../../../usage/responses.rst:488
msgid ""
"In the above example, the response returned by ``my_route_handler`` will "
"have cookies set by each layer of the application. Cookies are set using the "
"`Set-Cookie header <https://developer.mozilla.org/en-US/docs/Web/HTTP/"
"Headers/Set-Cookie>`_ and with above resulting in:"
msgstr ""

#: ../../../usage/responses.rst:493
msgid ""
"Set-Cookie: local-cookie=local value; Path=/; SameSite=lax\n"
"Set-Cookie: controller-cookie=controller value; Path=/; SameSite=lax\n"
"Set-Cookie: router-cookie=router value; Path=/; SameSite=lax\n"
"Set-Cookie: app-cookie=app value; Path=/; SameSite=lax"
msgstr ""

#: ../../../usage/responses.rst:500
msgid ""
"You can easily override cookies declared in higher levels by redeclaring a "
"cookie with the same key in a lower level, e.g.:"
msgstr ""

#: ../../../usage/responses.rst:504
msgid ""
"from litestar import Controller, Litestar, MediaType, get\n"
"from litestar.datastructures import Cookie\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller-path\"\n"
"    response_cookies = [Cookie(key=\"my-cookie\", value=\"123\")]\n"
"\n"
"    @get(\n"
"        path=\"/\",\n"
"        response_cookies=[Cookie(key=\"my-cookie\", value=\"456\")],\n"
"        media_type=MediaType.TEXT,\n"
"        sync_to_thread=False,\n"
"    )\n"
"    def my_route_handler(self) -> str:\n"
"        return \"hello world\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[MyController])"
msgstr ""

#: ../../../usage/responses.rst:507
msgid ""
"Of the two declarations of ``my-cookie`` only the route handler one will be "
"used, because its lower level:"
msgstr ""

#: ../../../usage/responses.rst:509
msgid "Set-Cookie: my-cookie=456; Path=/; SameSite=lax"
msgstr ""

#: ../../../usage/responses.rst:517
msgid ""
"If all you need for your cookies are key and value, you can supply them "
"using a :class:`Mapping[str, str] <typing.Mapping>` - like a :class:`dict` - "
"instead:"
msgstr ""

#: ../../../usage/responses.rst:521
msgid ""
"@get(response_cookies={\"my-cookie\": \"cookie-value\"})\n"
"async def handler() -> str: ..."
msgstr ""

#: ../../../usage/responses.rst:528
msgid ":class:`Cookie reference <.datastructures.cookie.Cookie>`"
msgstr ""

#: ../../../usage/responses.rst:533
msgid "Setting Cookies dynamically"
msgstr ""

#: ../../../usage/responses.rst:535
msgid ""
"While the above scheme works great for static cookie values, it doesn't "
"allow for dynamic cookies. Because cookies are fundamentally a type of "
"response header, we can utilize the same patterns we use to setting :ref:"
"`set headers headers <usage/responses:setting headers dynamically>`."
msgstr ""

#: ../../../usage/responses.rst:542
msgid ""
"We can simply return a response instance directly from the route handler and "
"set the cookies list manually as you see fit, e.g.:"
msgstr ""

#: ../../../usage/responses.rst:546
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
"    sync_to_thread=False,\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        cookies=[Cookie(key=\"Random-Cookie\", value=str(randint(1, "
"100)))],\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:549
msgid ""
"In the above we use the ``response_cookies`` kwarg to pass the ``key`` and "
"``description`` parameters for the ``Random-Cookie`` to the OpenAPI "
"documentation, but we set the value dynamically in as part of the :ref:"
"`annotated response <usage/responses:annotating responses>` we return. To "
"this end we do not set a ``value`` for it and we designate it as "
"``documentation_only=True``."
msgstr ""

#: ../../../usage/responses.rst:557
msgid ""
"An alternative pattern would be to use an :ref:`after request handler "
"<after_request>`. We can define the handler on different layers of the "
"application as explained in the pertinent docs. We should take care to "
"document the cookies on the corresponding layer:"
msgstr ""

#: ../../../usage/responses.rst:562
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, Router, get\n"
"from litestar.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\", sync_to_thread=False)\n"
"def retrieve_resource() -> Resource:\n"
"    return Resource(\n"
"        id=1,\n"
"        name=\"my resource\",\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.set_cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"\n"
"app = Litestar(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:565
msgid ""
"In the above we set the cookie using an ``after_request_handler`` function "
"on the router level. Because the handler function is applied on the router, "
"we also set the documentation for it on the router."
msgstr ""

#: ../../../usage/responses.rst:568
msgid ""
"We can use this pattern to fine-tune the OpenAPI documentation more granular "
"by overriding cookie specification as required. For example, lets say we "
"have a router level cookie being set and a local cookie with the same key "
"but a different value range:"
msgstr ""

#: ../../../usage/responses.rst:573
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, Response, Router, get\n"
"from litestar.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 100 - 1000\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
"    sync_to_thread=False,\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        cookies=[Cookie(key=\"Random-Cookie\", value=str(randint(100, "
"1000)))],\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.set_cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"\n"
"app = Litestar(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:577
msgid "Redirect Responses"
msgstr ""

#: ../../../usage/responses.rst:579
msgid ""
"Redirect responses are `special HTTP responses <https://developer.mozilla."
"org/en-US/docs/Web/HTTP/Redirections>`_ with a status code in the 30x range."
msgstr ""

#: ../../../usage/responses.rst:582
msgid "In Litestar, a redirect response looks like this:"
msgstr ""

#: ../../../usage/responses.rst:585
msgid ""
"from litestar.status_codes import HTTP_302_FOUND\n"
"from litestar import get\n"
"from litestar.response import Redirect\n"
"\n"
"\n"
"@get(path=\"/some-path\", status_code=HTTP_302_FOUND)\n"
"def redirect() -> Redirect:\n"
"    # do some stuff here\n"
"    # ...\n"
"    # finally return redirect\n"
"    return Redirect(path=\"/other-path\")"
msgstr ""

#: ../../../usage/responses.rst:598
msgid "To return a redirect response you should do the following:"
msgstr ""

#: ../../../usage/responses.rst:600
msgid ""
"optionally: set an appropriate status code for the route handler (301, 302, "
"303, 307, 308). If not set the default of 302 will be used."
msgstr ""

#: ../../../usage/responses.rst:601
msgid ""
"annotate the return value of the route handler as returning :class:`Redirect "
"<.response.Redirect>`"
msgstr ""

#: ../../../usage/responses.rst:602
msgid ""
"return an instance of the :class:`Redirect <.response.Redirect>` class with "
"the desired redirect path"
msgstr ""

#: ../../../usage/responses.rst:605
msgid "File Responses"
msgstr ""

#: ../../../usage/responses.rst:607
msgid "File responses send a file:"
msgstr ""

#: ../../../usage/responses.rst:610
msgid ""
"from pathlib import Path\n"
"from litestar import get\n"
"from litestar.response import File\n"
"\n"
"\n"
"@get(path=\"/file-download\")\n"
"def handle_file_download() -> File:\n"
"    return File(\n"
"        path=Path(Path(__file__).resolve().parent, \"report\")."
"with_suffix(\".pdf\"),\n"
"        filename=\"report.pdf\",\n"
"    )"
msgstr ""

#: ../../../usage/responses.rst:623
msgid "The :class:`File <.response.File>` class expects two kwargs:"
msgstr ""

#: ../../../usage/responses.rst:626
msgid "``path``: path of the file to download."
msgstr ""

#: ../../../usage/responses.rst:627
msgid ""
"``filename``: the filename to set in the response `Content-Disposition "
"<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-"
"Disposition>`_ attachment."
msgstr ""

#: ../../../usage/responses.rst:633
msgid ""
"When a route handler's return value is annotated with :class:`File <."
"response.File>`, the default ``media_type`` for the route_handler is "
"switched from :class:`MediaType.JSON <.enums.MediaType>` to :class:"
"`MediaType.TEXT <.enums.MediaType>` (i.e. ``\"text/plain\"``). If the file "
"being sent has an `IANA media type <https://developer.mozilla.org/en-US/docs/"
"Web/HTTP/Basics_of_HTTP/MIME_types>`_, you should set it as the value for "
"``media_type`` instead."
msgstr ""

#: ../../../usage/responses.rst:639
msgid "For example:"
msgstr ""

#: ../../../usage/responses.rst:642
msgid ""
"from pathlib import Path\n"
"from litestar import get\n"
"from litestar.response import File\n"
"\n"
"\n"
"@get(path=\"/file-download\", media_type=\"application/pdf\")\n"
"def handle_file_download() -> File:\n"
"    return File(\n"
"        path=Path(Path(__file__).resolve().parent, \"report\")."
"with_suffix(\".pdf\"),\n"
"        filename=\"report.pdf\",\n"
"    )"
msgstr ""

#: ../../../usage/responses.rst:657
msgid "Streaming Responses"
msgstr ""

#: ../../../usage/responses.rst:659
msgid ""
"To return a streaming response use the :class:`Stream <.response.Stream>` "
"class. The class receives a single positional arg, that must be an iterator "
"delivering the stream:"
msgstr ""

#: ../../../usage/responses.rst:663
msgid ""
"from asyncio import sleep\n"
"from datetime import datetime\n"
"from typing import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import Stream\n"
"from litestar.serialization import encode_json\n"
"\n"
"\n"
"async def my_generator() -> AsyncGenerator[bytes, None]:\n"
"    while True:\n"
"        await sleep(0.01)\n"
"        yield encode_json({\"current_time\": datetime.now()})\n"
"\n"
"\n"
"@get(path=\"/time\")\n"
"def stream_time() -> Stream:\n"
"    return Stream(my_generator())\n"
"\n"
"\n"
"app = Litestar(route_handlers=[stream_time])"
msgstr ""

#: ../../../usage/responses.rst:663
msgid ""
"from asyncio import sleep\n"
"from datetime import datetime\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import Stream\n"
"from litestar.serialization import encode_json\n"
"\n"
"\n"
"async def my_generator() -> AsyncGenerator[bytes, None]:\n"
"    while True:\n"
"        await sleep(0.01)\n"
"        yield encode_json({\"current_time\": datetime.now()})\n"
"\n"
"\n"
"@get(path=\"/time\")\n"
"def stream_time() -> Stream:\n"
"    return Stream(my_generator())\n"
"\n"
"\n"
"app = Litestar(route_handlers=[stream_time])"
msgstr ""

#: ../../../usage/responses.rst:668 ../../../usage/responses.rst:686
msgid ""
"You can use different kinds of values for the iterator. It can be a callable "
"returning a sync or async generator, a generator itself, a sync or async "
"iterator class, or an instance of a sync or async iterator class."
msgstr ""

#: ../../../usage/responses.rst:673
msgid "Server Sent Event Responses"
msgstr ""

#: ../../../usage/responses.rst:675
msgid ""
"To send `server-sent-events` or SSEs to the frontend, use the :class:"
"`ServerSentEvent <.response.ServerSentEvent>` class. The class receives a "
"content arg. You can additionally specify ``event_type``, which is the name "
"of the event as declared in the browser, the ``event_id``, which sets the "
"event source property, ``comment_message``, which is used in for sending "
"pings, and ``retry_duration``, which dictates the duration for retrying."
msgstr ""

#: ../../../usage/responses.rst:681
msgid ""
"from asyncio import sleep\n"
"from typing import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import ServerSentEvent, ServerSentEventMessage\n"
"from litestar.types import SSEData\n"
"\n"
"\n"
"async def my_generator() -> AsyncGenerator[SSEData, None]:\n"
"    count = 0\n"
"    while count < 10:\n"
"        await sleep(0.01)\n"
"        count += 1\n"
"        # In the generator you can yield integers, strings, bytes, "
"dictionaries, or ServerSentEventMessage objects\n"
"        # dicts can have the following keys: data, event, id, retry, "
"comment\n"
"\n"
"        # here we yield an integer\n"
"        yield count\n"
"        # here a string\n"
"        yield str(count)\n"
"        # here bytes\n"
"        yield str(count).encode(\"utf-8\")\n"
"        # here a dictionary\n"
"        yield {\"data\": 2 * count, \"event\": \"event2\", \"retry\": 10}\n"
"        # here a ServerSentEventMessage object\n"
"        yield ServerSentEventMessage(event=\"something-with-comment\", "
"retry=1000, comment=\"some comment\")\n"
"\n"
"\n"
"@get(path=\"/count\", sync_to_thread=False)\n"
"def sse_handler() -> ServerSentEvent:\n"
"    return ServerSentEvent(my_generator())\n"
"\n"
"\n"
"app = Litestar(route_handlers=[sse_handler])"
msgstr ""

#: ../../../usage/responses.rst:681
msgid ""
"from asyncio import sleep\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import ServerSentEvent, ServerSentEventMessage\n"
"from litestar.types import SSEData\n"
"\n"
"\n"
"async def my_generator() -> AsyncGenerator[SSEData, None]:\n"
"    count = 0\n"
"    while count < 10:\n"
"        await sleep(0.01)\n"
"        count += 1\n"
"        # In the generator you can yield integers, strings, bytes, "
"dictionaries, or ServerSentEventMessage objects\n"
"        # dicts can have the following keys: data, event, id, retry, "
"comment\n"
"\n"
"        # here we yield an integer\n"
"        yield count\n"
"        # here a string\n"
"        yield str(count)\n"
"        # here bytes\n"
"        yield str(count).encode(\"utf-8\")\n"
"        # here a dictionary\n"
"        yield {\"data\": 2 * count, \"event\": \"event2\", \"retry\": 10}\n"
"        # here a ServerSentEventMessage object\n"
"        yield ServerSentEventMessage(event=\"something-with-comment\", "
"retry=1000, comment=\"some comment\")\n"
"\n"
"\n"
"@get(path=\"/count\", sync_to_thread=False)\n"
"def sse_handler() -> ServerSentEvent:\n"
"    return ServerSentEvent(my_generator())\n"
"\n"
"\n"
"app = Litestar(route_handlers=[sse_handler])"
msgstr ""

#: ../../../usage/responses.rst:689
msgid ""
"In your iterator function you can yield integers, strings or bytes, the "
"message sent in that case will have ``message`` as the ``event_type`` if the "
"ServerSentEvent has no ``event_type`` set, otherwise it will use the "
"``event_type`` specified, and the data will be the yielded value."
msgstr ""

#: ../../../usage/responses.rst:693
msgid ""
"If you want to send a different event type, you can use a dictionary with "
"the keys ``event_type`` and ``data`` or the :class:`ServerSentEventMessage <."
"response.ServerSentEventMessage>` class."
msgstr ""

#: ../../../usage/responses.rst:697
msgid ""
"You can further customize all the sse parameters, add comments, and set the "
"retry duration by using the :class:`ServerSentEvent <.response."
"ServerSentEvent>` class directly or by using the :class:"
"`ServerSentEventMessage <.response.ServerSentEventMessage>` or dictionaries "
"with the appropriate keys."
msgstr ""

#: ../../../usage/responses.rst:701
msgid "Template Responses"
msgstr ""

#: ../../../usage/responses.rst:703
msgid ""
"Template responses are used to render templates into HTML. To use a template "
"response you must first :ref:`register a template engine <usage/templating:"
"registering a template engine>` on the application level. Once an engine is "
"in place, you can use a template response like so:"
msgstr ""

#: ../../../usage/responses.rst:708
msgid ""
"from litestar import Request, get\n"
"from litestar.response import Template\n"
"\n"
"\n"
"@get(path=\"/info\")\n"
"def info(request: Request) -> Template:\n"
"    return Template(template_name=\"info.html\", context={\"user\": request."
"user})"
msgstr ""

#: ../../../usage/responses.rst:717
msgid ""
"In the above example, :class:`Template <.response.Template>` is passed the "
"template name, which is a path like value, and a context dictionary that "
"maps string keys into values that will be rendered in the template."
msgstr ""

#: ../../../usage/responses.rst:721
msgid "Custom Responses"
msgstr ""

#: ../../../usage/responses.rst:723
msgid ""
"While Litestar supports the serialization of many types by default, "
"sometimes you want to return something that's not supported. In those cases "
"it's convenient to make use of a custom response class."
msgstr ""

#: ../../../usage/responses.rst:726
msgid ""
"The example below illustrates how to deal with :class:`MultiDict <."
"datastructures.MultiDict>` instances."
msgstr ""

#: ../../../usage/responses.rst:730
msgid ""
"from litestar import Litestar, Response, get\n"
"from litestar.datastructures import MultiDict\n"
"\n"
"\n"
"class MultiDictResponse(Response):\n"
"    type_encoders = {MultiDict: lambda d: d.dict()}\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def index() -> MultiDict:\n"
"    return MultiDict([(\"foo\", \"bar\"), (\"foo\", \"baz\")])\n"
"\n"
"\n"
"app = Litestar([index], response_class=MultiDictResponse)"
msgstr ""

#: ../../../usage/responses.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"{\"foo\":[\"bar\",\"baz\"]}"
msgstr ""

#: ../../../usage/responses.rst:732
msgid "Layered architecture"
msgstr ""

#: ../../../usage/responses.rst:735
msgid ""
"Response classes are part of Litestar's layered architecture, which means "
"you can set a response class on every layer of the application. If you have "
"set a response class on multiple layers, the layer closest to the route "
"handler will take precedence."
msgstr ""

#: ../../../usage/responses.rst:739
msgid ""
"You can read more about this here: :ref:`usage/applications:layered "
"architecture`"
msgstr ""

#: ../../../usage/responses.rst:742
msgid "Background Tasks"
msgstr ""

#: ../../../usage/responses.rst:744
msgid ""
"All Litestar responses allow passing in a ``background`` kwarg. This kwarg "
"accepts either an instance of :class:`BackgroundTask <.background_tasks."
"BackgroundTask>` or an instance of :class:`BackgroundTasks <."
"background_tasks.BackgroundTasks>`, which wraps an iterable of :class:"
"`BackgroundTask <.background_tasks.BackgroundTask>` instances."
msgstr ""

#: ../../../usage/responses.rst:749
msgid ""
"A background task is a sync or async callable (function, method, or class "
"that implements the :meth:`object.__call__` dunder method) that will be "
"called after the response finishes sending the data."
msgstr ""

#: ../../../usage/responses.rst:752
msgid ""
"Thus, in the following example the passed in background task will be "
"executed after the response sends:"
msgstr ""

#: ../../../usage/responses.rst:755
msgid "Background Task Passed into Response"
msgstr ""

#: ../../../usage/responses.rst:755
msgid ""
"import logging\n"
"from typing import Dict\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.background_tasks import BackgroundTask\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def greeter(name: str) -> Response[Dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTask(logging_task, \"greeter\", message=f\"was "
"called with name {name}\"),\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:755
msgid ""
"import logging\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.background_tasks import BackgroundTask\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def greeter(name: str) -> Response[dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTask(logging_task, \"greeter\", message=f\"was "
"called with name {name}\"),\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:758
msgid ""
"When the ``greeter`` handler is called, the logging task will be called with "
"any ``*args`` and ``**kwargs`` passed into the :class:`BackgroundTask <."
"background_tasks.BackgroundTask>`."
msgstr ""

#: ../../../usage/responses.rst:763
msgid ""
"In the above example ``\"greeter\"`` is an arg and ``message=f\"was called "
"with name {name}\"`` is a kwarg. The function signature of ``logging_task`` "
"allows for this, so this should pose no problem. :class:`BackgroundTask <."
"background_tasks.BackgroundTask>` is typed with :class:`ParamSpec <typing."
"ParamSpec>`, enabling correct type checking for arguments and keyword "
"arguments passed to it."
msgstr ""

#: ../../../usage/responses.rst:768
msgid ""
"Route decorators (e.g. ``@get``, ``@post``, etc.) also allow passing in a "
"background task with the ``background`` kwarg:"
msgstr ""

#: ../../../usage/responses.rst:771
msgid "Background Task Passed into Decorator"
msgstr ""

#: ../../../usage/responses.rst:771
msgid ""
"import logging\n"
"from typing import Dict\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.background_tasks import BackgroundTask\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\", background=BackgroundTask(logging_task, \"greeter\", "
"message=\"was called\"), sync_to_thread=False)\n"
"def greeter() -> Dict[str, str]:\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:771
msgid ""
"import logging\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.background_tasks import BackgroundTask\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\", background=BackgroundTask(logging_task, \"greeter\", "
"message=\"was called\"), sync_to_thread=False)\n"
"def greeter() -> dict[str, str]:\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:777
msgid ""
"Route handler arguments cannot be passed into background tasks when they are "
"passed into decorators."
msgstr ""

#: ../../../usage/responses.rst:780
msgid "Executing Multiple Background Tasks"
msgstr ""

#: ../../../usage/responses.rst:782
msgid ""
"You can also use the :class:`BackgroundTasks <.background_tasks."
"BackgroundTasks>` class and pass to it an iterable (:class:`list`, :class:"
"`tuple`, etc.) of :class:`BackgroundTask <.background_tasks.BackgroundTask>` "
"instances:"
msgstr ""

#: ../../../usage/responses.rst:786
msgid "Multiple Background Tasks"
msgstr ""

#: ../../../usage/responses.rst:786
msgid ""
"import logging\n"
"from typing import Dict\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.background_tasks import BackgroundTask, BackgroundTasks\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"greeted = set()\n"
"\n"
"\n"
"async def logging_task(name: str) -> None:\n"
"    logger.info(\"%s was greeted\", name)\n"
"\n"
"\n"
"async def saving_task(name: str) -> None:\n"
"    greeted.add(name)\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def greeter(name: str) -> Response[Dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTasks(\n"
"            [\n"
"                BackgroundTask(logging_task, name),\n"
"                BackgroundTask(saving_task, name),\n"
"            ]\n"
"        ),\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:786
msgid ""
"import logging\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.background_tasks import BackgroundTask, BackgroundTasks\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"greeted = set()\n"
"\n"
"\n"
"async def logging_task(name: str) -> None:\n"
"    logger.info(\"%s was greeted\", name)\n"
"\n"
"\n"
"async def saving_task(name: str) -> None:\n"
"    greeted.add(name)\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def greeter(name: str) -> Response[dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTasks(\n"
"            [\n"
"                BackgroundTask(logging_task, name),\n"
"                BackgroundTask(saving_task, name),\n"
"            ]\n"
"        ),\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:790
msgid ""
":class:`BackgroundTasks <.background_tasks.BackgroundTasks>` class accepts "
"an optional keyword argument ``run_in_task_group`` with a default value of "
"``False``. Setting this to ``True`` allows background tasks to run "
"concurrently, using an `anyio.task_group <https://anyio.readthedocs.io/en/"
"stable/tasks.html>`_."
msgstr ""

#: ../../../usage/responses.rst:796
msgid ""
"Setting ``run_in_task_group`` to ``True`` will not preserve execution order."
msgstr ""

#: ../../../usage/responses.rst:799
msgid "Pagination"
msgstr ""

#: ../../../usage/responses.rst:801
msgid ""
"When you need to return a large number of items from an endpoint it is "
"common practice to use pagination to ensure clients can request a specific "
"subset or \"page\" from the total dataset. Litestar supports three types of "
"pagination out of the box:"
msgstr ""

#: ../../../usage/responses.rst:805
msgid "classic pagination"
msgstr ""

#: ../../../usage/responses.rst:806
msgid "limit / offset pagination"
msgstr ""

#: ../../../usage/responses.rst:807
msgid "cursor pagination"
msgstr ""

#: ../../../usage/responses.rst:810 ../../../usage/responses.rst:815
msgid "Classic Pagination"
msgstr ""

#: ../../../usage/responses.rst:812
msgid ""
"In classic pagination the dataset is divided into pages of a specific size "
"and the consumer then requests a specific page."
msgstr ""

#: ../../../usage/responses.rst:815
msgid ""
"from typing import List\n"
"\n"
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncClassicPaginator, "
"ClassicPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonClassicPaginator(AbstractSyncClassicPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self, page_size: int) -> int:\n"
"        return round(len(self.data) / page_size)\n"
"\n"
"    def get_items(self, page_size: int, current_page: int) -> List[Person]:\n"
"        return [self.data[i : i + page_size] for i in range(0, len(self."
"data), page_size)][current_page - 1]\n"
"\n"
"\n"
"paginator = PersonClassicPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'page_size' and 'current_page', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(page_size: int, current_page: int) -> "
"ClassicPagination[Person]:\n"
"    return paginator(page_size=page_size, current_page=current_page)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:815
msgid ""
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncClassicPaginator, "
"ClassicPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonClassicPaginator(AbstractSyncClassicPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self, page_size: int) -> int:\n"
"        return round(len(self.data) / page_size)\n"
"\n"
"    def get_items(self, page_size: int, current_page: int) -> list[Person]:\n"
"        return [self.data[i : i + page_size] for i in range(0, len(self."
"data), page_size)][current_page - 1]\n"
"\n"
"\n"
"paginator = PersonClassicPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'page_size' and 'current_page', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(page_size: int, current_page: int) -> "
"ClassicPagination[Person]:\n"
"    return paginator(page_size=page_size, current_page=current_page)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:818
msgid ""
"The data container for this pagination is called :class:`ClassicPagination <."
"pagination.ClassicPagination>`, which is what will be returned by the "
"paginator in the above example This will also generate the corresponding "
"OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:822
msgid ""
"If you require async logic, you can implement the :class:"
"`AbstractAsyncClassicPaginator <.pagination.AbstractAsyncClassicPaginator>` "
"instead of the :class:`AbstractSyncClassicPaginator <.pagination."
"AbstractSyncClassicPaginator>`."
msgstr ""

#: ../../../usage/responses.rst:827 ../../../usage/responses.rst:833
msgid "Offset Pagination"
msgstr ""

#: ../../../usage/responses.rst:829
msgid ""
"In offset pagination the consumer requests a number of items specified by "
"``limit`` and the ``offset`` from the beginning of the dataset. For example, "
"given a list of 50 items, you could request ``limit=10``, ``offset=39`` to "
"request items 40-50."
msgstr ""

#: ../../../usage/responses.rst:833
msgid ""
"from itertools import islice\n"
"from typing import List\n"
"\n"
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncOffsetPaginator, "
"OffsetPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractSyncOffsetPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self) -> int:\n"
"        return len(self.data)\n"
"\n"
"    def get_items(self, limit: int, offset: int) -> List[Person]:\n"
"        return list(islice(islice(self.data, offset, None), limit))\n"
"\n"
"\n"
"paginator = PersonOffsetPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'limit' and 'offset', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(limit: int, offset: int) -> OffsetPagination[Person]:\n"
"    return paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:833
msgid ""
"from itertools import islice\n"
"\n"
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncOffsetPaginator, "
"OffsetPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractSyncOffsetPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self) -> int:\n"
"        return len(self.data)\n"
"\n"
"    def get_items(self, limit: int, offset: int) -> list[Person]:\n"
"        return list(islice(islice(self.data, offset, None), limit))\n"
"\n"
"\n"
"paginator = PersonOffsetPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'limit' and 'offset', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(limit: int, offset: int) -> OffsetPagination[Person]:\n"
"    return paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:836
msgid ""
"The data container for this pagination is called :class:`OffsetPagination <."
"pagination.OffsetPagination>`, which is what will be returned by the "
"paginator in the above example This will also generate the corresponding "
"OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:840
msgid ""
"If you require async logic, you can implement the :class:"
"`AbstractAsyncOffsetPaginator <.pagination.AbstractAsyncOffsetPaginator>` "
"instead of the :class:`AbstractSyncOffsetPaginator <.pagination."
"AbstractSyncOffsetPaginator>`."
msgstr ""

#: ../../../usage/responses.rst:845 ../../../usage/responses.rst:851
msgid "Offset Pagination With SQLAlchemy"
msgstr ""

#: ../../../usage/responses.rst:847
msgid ""
"When retrieving paginated data from the database using SQLAlchemy, the "
"Paginator instance requires an SQLAlchemy session instance to make queries. "
"This can be achieved with :doc:`/usage/dependency-injection`"
msgstr ""

#: ../../../usage/responses.rst:851
msgid ""
"from typing import TYPE_CHECKING, List, cast\n"
"\n"
"from sqlalchemy import func, select\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.di import Provide\n"
"from litestar.pagination import AbstractAsyncOffsetPaginator, "
"OffsetPagination\n"
"from litestar.plugins.sqlalchemy import SQLAlchemyAsyncConfig, "
"SQLAlchemyInitPlugin, base\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.engine.result import ScalarResult\n"
"    from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"\n"
"class Person(base.UUIDBase):\n"
"    name: Mapped[str]\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractAsyncOffsetPaginator[Person]):\n"
"    def __init__(self, async_session: AsyncSession) -> None:  # "
"'async_session' dependency will be injected here.\n"
"        self.async_session = async_session\n"
"\n"
"    async def get_total(self) -> int:\n"
"        return cast(\"int\", await self.async_session.scalar(select(func."
"count(Person.id))))\n"
"\n"
"    async def get_items(self, limit: int, offset: int) -> List[Person]:\n"
"        people: ScalarResult = await self.async_session."
"scalars(select(Person).slice(offset, limit))\n"
"        return list(people.all())\n"
"\n"
"\n"
"# Create a route handler. The handler will receive two query parameters - "
"'limit' and 'offset', which is passed\n"
"# to the paginator instance. Also create a dependency 'paginator' which will "
"be injected into the handler.\n"
"@get(\"/people\", dependencies={\"paginator\": "
"Provide(PersonOffsetPaginator)})\n"
"async def people_handler(paginator: PersonOffsetPaginator, limit: int, "
"offset: int) -> OffsetPagination[Person]:\n"
"    return await paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"sqlalchemy_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"session_dependency_key=\"async_session\"\n"
")  # Create 'async_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.get_engine().begin() as conn:\n"
"        await conn.run_sync(base.UUIDBase.metadata.create_all)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler], on_startup=[on_startup], "
"plugins=[sqlalchemy_plugin])"
msgstr ""

#: ../../../usage/responses.rst:851
msgid ""
"from typing import TYPE_CHECKING, cast\n"
"\n"
"from sqlalchemy import func, select\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.di import Provide\n"
"from litestar.pagination import AbstractAsyncOffsetPaginator, "
"OffsetPagination\n"
"from litestar.plugins.sqlalchemy import SQLAlchemyAsyncConfig, "
"SQLAlchemyInitPlugin, base\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.engine.result import ScalarResult\n"
"    from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"\n"
"class Person(base.UUIDBase):\n"
"    name: Mapped[str]\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractAsyncOffsetPaginator[Person]):\n"
"    def __init__(self, async_session: AsyncSession) -> None:  # "
"'async_session' dependency will be injected here.\n"
"        self.async_session = async_session\n"
"\n"
"    async def get_total(self) -> int:\n"
"        return cast(\"int\", await self.async_session.scalar(select(func."
"count(Person.id))))\n"
"\n"
"    async def get_items(self, limit: int, offset: int) -> list[Person]:\n"
"        people: ScalarResult = await self.async_session."
"scalars(select(Person).slice(offset, limit))\n"
"        return list(people.all())\n"
"\n"
"\n"
"# Create a route handler. The handler will receive two query parameters - "
"'limit' and 'offset', which is passed\n"
"# to the paginator instance. Also create a dependency 'paginator' which will "
"be injected into the handler.\n"
"@get(\"/people\", dependencies={\"paginator\": "
"Provide(PersonOffsetPaginator)})\n"
"async def people_handler(paginator: PersonOffsetPaginator, limit: int, "
"offset: int) -> OffsetPagination[Person]:\n"
"    return await paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"sqlalchemy_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"session_dependency_key=\"async_session\"\n"
")  # Create 'async_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.get_engine().begin() as conn:\n"
"        await conn.run_sync(base.UUIDBase.metadata.create_all)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler], on_startup=[on_startup], "
"plugins=[sqlalchemy_plugin])"
msgstr ""

#: ../../../usage/responses.rst:854
msgid ""
"See :ref:`SQLAlchemy plugin <usage/databases/sqlalchemy/plugins/index:"
"Plugins>` for sqlalchemy integration."
msgstr ""

#: ../../../usage/responses.rst:857 ../../../usage/responses.rst:863
msgid "Cursor Pagination"
msgstr ""

#: ../../../usage/responses.rst:859
msgid ""
"In cursor pagination the consumer requests a number of items specified by "
"``results_per_page`` and a ``cursor`` after which results are given. Cursor "
"is unique identifier within the dataset that serves as a way to point the "
"starting position."
msgstr ""

#: ../../../usage/responses.rst:863
msgid ""
"from typing import List, Optional, Tuple\n"
"\n"
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncCursorPaginator, "
"CursorPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement the method "
"'get_items'.\n"
"\n"
"\n"
"class PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_items(self, cursor: Optional[str], results_per_page: int) -> "
"Tuple[List[Person], Optional[str]]:\n"
"        results = self.data[:results_per_page]\n"
"        return results, results[-1].id\n"
"\n"
"\n"
"paginator = PersonCursorPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive a single query "
"parameter - 'cursor', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(cursor: Optional[str], results_per_page: int) -> "
"CursorPagination[str, Person]:\n"
"    return paginator(cursor=cursor, results_per_page=results_per_page)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:863
msgid ""
"from typing import Optional\n"
"\n"
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncCursorPaginator, "
"CursorPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement the method "
"'get_items'.\n"
"\n"
"\n"
"class PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_items(self, cursor: Optional[str], results_per_page: int) -> "
"tuple[list[Person], Optional[str]]:\n"
"        results = self.data[:results_per_page]\n"
"        return results, results[-1].id\n"
"\n"
"\n"
"paginator = PersonCursorPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive a single query "
"parameter - 'cursor', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(cursor: Optional[str], results_per_page: int) -> "
"CursorPagination[str, Person]:\n"
"    return paginator(cursor=cursor, results_per_page=results_per_page)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/responses.rst:863
msgid ""
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from pydantic import BaseModel\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.pagination import AbstractSyncCursorPaginator, "
"CursorPagination\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement the method "
"'get_items'.\n"
"\n"
"\n"
"class PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_items(self, cursor: str | None, results_per_page: int) -> "
"tuple[list[Person], str | None]:\n"
"        results = self.data[:results_per_page]\n"
"        return results, results[-1].id\n"
"\n"
"\n"
"paginator = PersonCursorPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive a single query "
"parameter - 'cursor', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\", sync_to_thread=False)\n"
"def people_handler(cursor: str | None, results_per_page: int) -> "
"CursorPagination[str, Person]:\n"
"    return paginator(cursor=cursor, results_per_page=results_per_page)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:866
msgid ""
"The data container for this pagination is called :class:`CursorPagination <."
"pagination.CursorPagination>`, which is what will be returned by the "
"paginator in the above example This will also generate the corresponding "
"OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:869
msgid ""
"If you require async logic, you can implement the :class:"
"`AbstractAsyncCursorPaginator <.pagination.AbstractAsyncCursorPaginator>` "
"instead of the :class:`AbstractSyncCursorPaginator <.pagination."
"AbstractSyncCursorPaginator>`."
msgstr ""
