# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:2
msgid "Working with Controllers and Repositories"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:3
msgid ""
"We've been working our way up the stack, starting with the database models, "
"and now we are ready to use the repository in an actual route.  Let's see "
"how we can use this in a controller."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:7
msgid ""
"The full code for this tutorial can be found below in the :ref:`Full Code "
"<03-repo-full-code>` section."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:9
msgid ""
"First, we create a simple function that returns an instance of "
"``AuthorRepository``. This function will be used to inject a repository "
"instance into our controller routes. Note that we are only passing in the "
"database session in this example with no other parameters."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:15
#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:28
#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:43
#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:58
#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:74
msgid "``app.py``"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:15
msgid ""
"async def provide_authors_repo(db_session: AsyncSession) -> "
"AuthorRepository:\n"
"    \"\"\"This provides the default Authors repository.\"\"\"\n"
"    return AuthorRepository(session=db_session)"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:20
msgid ""
"Because we'll be using the SQLAlchemy plugin in Litestar, the session is "
"automatically configured as a dependency."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:23
msgid ""
"By default, the repository doesn't add any additional query options to your "
"base statement, but provides the flexibility to override it, allowing you to "
"pass your own statement:"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:28
msgid ""
"# we can optionally override the default `select` used for the repository to "
"pass in\n"
"# specific SQL options such as join details\n"
"async def provide_author_details_repo(db_session: AsyncSession) -> "
"AuthorRepository:\n"
"    \"\"\"This provides a simple example demonstrating how to override the "
"join options for the repository.\"\"\"\n"
"    return AuthorRepository(\n"
"        statement=select(AuthorModel).options(selectinload(AuthorModel."
"books)),\n"
"        session=db_session,\n"
"    )"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:33
msgid ""
"In this instance, we enhance the repository function by adding a "
"``selectinload`` option. This option configures the specified relationship "
"to load via `SELECT .. IN ...` loading pattern, optimizing the query "
"execution."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:37
msgid ""
"Next, we define the ``AuthorController``. This controller exposes five "
"routes for interacting with the ``Author`` model:"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:0
msgid "``AuthorController`` (click to toggle)"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:43
msgid ""
"class AuthorController(Controller):\n"
"    \"\"\"Author CRUD\"\"\"\n"
"\n"
"    dependencies = {\"authors_repo\": Provide(provide_authors_repo)}\n"
"\n"
"    @get(path=\"/authors\")\n"
"    async def list_authors(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        limit_offset: filters.LimitOffset,\n"
"    ) -> OffsetPagination[Author]:\n"
"        \"\"\"List authors.\"\"\"\n"
"        results, total = await authors_repo.list_and_count(limit_offset)\n"
"        type_adapter = TypeAdapter(list[Author])\n"
"        return OffsetPagination[Author](\n"
"            items=type_adapter.validate_python(results),\n"
"            total=total,\n"
"            limit=limit_offset.limit,\n"
"            offset=limit_offset.offset,\n"
"        )\n"
"\n"
"    @post(path=\"/authors\")\n"
"    async def create_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorCreate,\n"
"    ) -> Author:\n"
"        \"\"\"Create a new author.\"\"\"\n"
"        obj = await authors_repo.add(\n"
"            AuthorModel(**data.model_dump(exclude_unset=True, "
"exclude_none=True)),\n"
"        )\n"
"        await authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    # we override the authors_repo to use the version that joins the Books "
"in\n"
"    @get(path=\"/authors/{author_id:uuid}\", dependencies={\"authors_repo\": "
"Provide(provide_author_details_repo)})\n"
"    async def get_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to retrieve.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Get an existing author.\"\"\"\n"
"        obj = await authors_repo.get(author_id)\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @patch(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": "
"Provide(provide_author_details_repo)},\n"
"    )\n"
"    async def update_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorUpdate,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to update.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Update an author.\"\"\"\n"
"        raw_obj = data.model_dump(exclude_unset=True, exclude_none=True)\n"
"        raw_obj.update({\"id\": author_id})\n"
"        obj = await authors_repo.update(AuthorModel(**raw_obj))\n"
"        await authors_repo.session.commit()\n"
"        return Author.from_orm(obj)\n"
"\n"
"    @delete(path=\"/authors/{author_id:uuid}\")\n"
"    async def delete_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to delete.\",\n"
"        ),\n"
"    ) -> None:\n"
"        \"\"\"Delete a author from the system.\"\"\"\n"
"        _ = await authors_repo.delete(author_id)\n"
"        await authors_repo.session.commit()"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:48
msgid ""
"In our list detail endpoint, we use the pagination filter for limiting the "
"amount of data returned, allowing us to retrieve large datasets in smaller, "
"more manageable chunks."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:51
msgid ""
"In the above examples, we've used the asynchronous repository "
"implementation. However, Litestar also supports synchronous database drivers "
"with an identical implementation. Here's a corresponding synchronous version "
"of the previous example:"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:0
msgid "Synchronous Repository (click to toggle)"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:58
msgid ""
"from __future__ import annotations\n"
"\n"
"from datetime import date\n"
"from typing import TYPE_CHECKING\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel as _BaseModel\n"
"from pydantic import TypeAdapter\n"
"from sqlalchemy import ForeignKey, select\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship, "
"selectinload\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.controller import Controller\n"
"from litestar.di import Provide\n"
"from litestar.handlers.http_handlers.decorators import delete, patch, post\n"
"from litestar.pagination import OffsetPagination\n"
"from litestar.params import Parameter\n"
"from litestar.plugins.sqlalchemy import (\n"
"    SQLAlchemyInitPlugin,\n"
"    SQLAlchemySyncConfig,\n"
"    base,\n"
"    repository,\n"
")\n"
"from litestar.repository.filters import LimitOffset\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.orm import Session\n"
"\n"
"\n"
"class BaseModel(_BaseModel):\n"
"    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n"
"\n"
"    model_config = {\"from_attributes\": True}\n"
"\n"
"\n"
"# The SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `UUIDBase` class includes a `UUID` based primary key (`id`)\n"
"class AuthorModel(base.UUIDBase):\n"
"    # we can optionally provide the table name instead of auto-generating "
"it\n"
"    __tablename__ = \"author\"  #  type: ignore[assignment]\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date | None]\n"
"    books: Mapped[list[BookModel]] = relationship(back_populates=\"author\", "
"lazy=\"noload\")\n"
"\n"
"\n"
"# The `UUIDAuditBase` class includes the same UUID` based primary key (`id`) "
"and 2\n"
"# additional columns: `created_at` and `updated_at`. `created_at` is a "
"timestamp of when the\n"
"# record created, and `updated_at` is the last time the record was "
"modified.\n"
"class BookModel(base.UUIDAuditBase):\n"
"    __tablename__ = \"book\"  #  type: ignore[assignment]\n"
"    title: Mapped[str]\n"
"    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n"
"    author: Mapped[AuthorModel] = relationship(lazy=\"joined\", "
"innerjoin=True, viewonly=True)\n"
"\n"
"\n"
"# we will explicitly define the schema instead of using DTO objects for "
"clarity.\n"
"\n"
"\n"
"class Author(BaseModel):\n"
"    id: UUID | None\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorCreate(BaseModel):\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorUpdate(BaseModel):\n"
"    name: str | None = None\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemySyncRepository[AuthorModel]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = AuthorModel\n"
"\n"
"\n"
"async def provide_authors_repo(db_session: Session) -> AuthorRepository:\n"
"    \"\"\"This provides the default Authors repository.\"\"\"\n"
"    return AuthorRepository(session=db_session)\n"
"\n"
"\n"
"# we can optionally override the default `select` used for the repository to "
"pass in\n"
"# specific SQL options such as join details\n"
"async def provide_author_details_repo(db_session: Session) -> "
"AuthorRepository:\n"
"    \"\"\"This provides a simple example demonstrating how to override the "
"join options\n"
"    for the repository.\"\"\"\n"
"    return AuthorRepository(\n"
"        statement=select(AuthorModel).options(selectinload(AuthorModel."
"books)),\n"
"        session=db_session,\n"
"    )\n"
"\n"
"\n"
"def provide_limit_offset_pagination(\n"
"    current_page: int = Parameter(ge=1, query=\"currentPage\", default=1, "
"required=False),\n"
"    page_size: int = Parameter(\n"
"        query=\"pageSize\",\n"
"        ge=1,\n"
"        default=10,\n"
"        required=False,\n"
"    ),\n"
") -> LimitOffset:\n"
"    \"\"\"Add offset/limit pagination.\n"
"\n"
"    Return type consumed by `Repository.apply_limit_offset_pagination()`.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    current_page : int\n"
"        LIMIT to apply to select.\n"
"    page_size : int\n"
"        OFFSET to apply to select.\n"
"    \"\"\"\n"
"    return LimitOffset(page_size, page_size * (current_page - 1))\n"
"\n"
"\n"
"class AuthorController(Controller):\n"
"    \"\"\"Author CRUD\"\"\"\n"
"\n"
"    dependencies = {\"authors_repo\": Provide(provide_authors_repo, "
"sync_to_thread=False)}\n"
"\n"
"    @get(path=\"/authors\")\n"
"    def list_authors(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        limit_offset: LimitOffset,\n"
"    ) -> OffsetPagination[Author]:\n"
"        \"\"\"List authors.\"\"\"\n"
"        results, total = authors_repo.list_and_count(limit_offset)\n"
"        type_adapter = TypeAdapter(list[Author])\n"
"        return OffsetPagination[Author](\n"
"            items=type_adapter.validate_python(results),\n"
"            total=total,\n"
"            limit=limit_offset.limit,\n"
"            offset=limit_offset.offset,\n"
"        )\n"
"\n"
"    @post(path=\"/authors\")\n"
"    def create_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorCreate,\n"
"    ) -> Author:\n"
"        \"\"\"Create a new author.\"\"\"\n"
"        obj = authors_repo.add(\n"
"            AuthorModel(**data.model_dump(exclude_unset=True, "
"exclude_none=True)),\n"
"        )\n"
"        authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    # we override the authors_repo to use the version that joins the Books "
"in\n"
"    @get(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": Provide(provide_author_details_repo, "
"sync_to_thread=False)},\n"
"    )\n"
"    def get_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to retrieve.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Get an existing author.\"\"\"\n"
"        obj = authors_repo.get(author_id)\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @patch(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": Provide(provide_author_details_repo, "
"sync_to_thread=False)},\n"
"    )\n"
"    def update_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorUpdate,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to update.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Update an author.\"\"\"\n"
"        raw_obj = data.model_dump(exclude_unset=True, exclude_none=True)\n"
"        raw_obj.update({\"id\": author_id})\n"
"        obj = authors_repo.update(AuthorModel(**raw_obj))\n"
"        authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @delete(path=\"/authors/{author_id:uuid}\")\n"
"    def delete_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to delete.\",\n"
"        ),\n"
"    ) -> None:\n"
"        \"\"\"Delete a author from the system.\"\"\"\n"
"        _ = authors_repo.delete(author_id)\n"
"        authors_repo.session.commit()\n"
"\n"
"\n"
"sqlalchemy_config = SQLAlchemySyncConfig(connection_string=\"sqlite:///test."
"sqlite\")  # Create 'db_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    with sqlalchemy_config.get_engine().begin() as conn:\n"
"        base.UUIDBase.metadata.create_all(conn)\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[AuthorController],\n"
"    on_startup=[on_startup],\n"
"    plugins=[SQLAlchemyInitPlugin(config=sqlalchemy_config)],\n"
"    dependencies={\"limit_offset\": "
"Provide(provide_limit_offset_pagination)},\n"
")"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:62
msgid ""
"The examples above enable a feature-complete CRUD service that includes "
"pagination! In the next section, we'll explore how to extend the built-in "
"repository to add additional functionality to our application."
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:69
msgid "Full Code"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:0
msgid "Full Code (click to toggle)"
msgstr ""

#: ../../../tutorials/repository-tutorial/03-repository-controller.rst:74
msgid ""
"from __future__ import annotations\n"
"\n"
"from datetime import date\n"
"from typing import TYPE_CHECKING\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel as _BaseModel\n"
"from pydantic import TypeAdapter\n"
"from sqlalchemy import ForeignKey, select\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship, "
"selectinload\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.controller import Controller\n"
"from litestar.di import Provide\n"
"from litestar.handlers.http_handlers.decorators import delete, patch, post\n"
"from litestar.pagination import OffsetPagination\n"
"from litestar.params import Parameter\n"
"from litestar.plugins.sqlalchemy import (\n"
"    AsyncSessionConfig,\n"
"    SQLAlchemyAsyncConfig,\n"
"    SQLAlchemyInitPlugin,\n"
"    base,\n"
"    filters,\n"
"    repository,\n"
")\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"\n"
"class BaseModel(_BaseModel):\n"
"    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n"
"\n"
"    model_config = {\"from_attributes\": True}\n"
"\n"
"\n"
"# The SQLAlchemy base includes a declarative model for you to use in your "
"models.\n"
"# The `UUIDBase` class includes a `UUID` based primary key (`id`)\n"
"class AuthorModel(base.UUIDBase):\n"
"    # we can optionally provide the table name instead of auto-generating "
"it\n"
"    __tablename__ = \"author\"  #  type: ignore[assignment]\n"
"    name: Mapped[str]\n"
"    dob: Mapped[date | None]\n"
"    books: Mapped[list[BookModel]] = relationship(back_populates=\"author\", "
"lazy=\"noload\")\n"
"\n"
"\n"
"# The `UUIDAuditBase` class includes the same UUID` based primary key (`id`) "
"and 2\n"
"# additional columns: `created_at` and `updated_at`. `created_at` is a "
"timestamp of when the\n"
"# record created, and `updated_at` is the last time the record was "
"modified.\n"
"class BookModel(base.UUIDAuditBase):\n"
"    __tablename__ = \"book\"  #  type: ignore[assignment]\n"
"    title: Mapped[str]\n"
"    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n"
"    author: Mapped[AuthorModel] = relationship(lazy=\"joined\", "
"innerjoin=True, viewonly=True)\n"
"\n"
"\n"
"# we will explicitly define the schema instead of using DTO objects for "
"clarity.\n"
"\n"
"\n"
"class Author(BaseModel):\n"
"    id: UUID | None\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorCreate(BaseModel):\n"
"    name: str\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorUpdate(BaseModel):\n"
"    name: str | None = None\n"
"    dob: date | None = None\n"
"\n"
"\n"
"class AuthorRepository(repository.SQLAlchemyAsyncRepository[AuthorModel]):\n"
"    \"\"\"Author repository.\"\"\"\n"
"\n"
"    model_type = AuthorModel\n"
"\n"
"\n"
"async def provide_authors_repo(db_session: AsyncSession) -> "
"AuthorRepository:\n"
"    \"\"\"This provides the default Authors repository.\"\"\"\n"
"    return AuthorRepository(session=db_session)\n"
"\n"
"\n"
"# we can optionally override the default `select` used for the repository to "
"pass in\n"
"# specific SQL options such as join details\n"
"async def provide_author_details_repo(db_session: AsyncSession) -> "
"AuthorRepository:\n"
"    \"\"\"This provides a simple example demonstrating how to override the "
"join options for the repository.\"\"\"\n"
"    return AuthorRepository(\n"
"        statement=select(AuthorModel).options(selectinload(AuthorModel."
"books)),\n"
"        session=db_session,\n"
"    )\n"
"\n"
"\n"
"def provide_limit_offset_pagination(\n"
"    current_page: int = Parameter(ge=1, query=\"currentPage\", default=1, "
"required=False),\n"
"    page_size: int = Parameter(\n"
"        query=\"pageSize\",\n"
"        ge=1,\n"
"        default=10,\n"
"        required=False,\n"
"    ),\n"
") -> filters.LimitOffset:\n"
"    \"\"\"Add offset/limit pagination.\n"
"\n"
"    Return type consumed by `Repository.apply_limit_offset_pagination()`.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    current_page : int\n"
"        LIMIT to apply to select.\n"
"    page_size : int\n"
"        OFFSET to apply to select.\n"
"    \"\"\"\n"
"    return filters.LimitOffset(page_size, page_size * (current_page - 1))\n"
"\n"
"\n"
"class AuthorController(Controller):\n"
"    \"\"\"Author CRUD\"\"\"\n"
"\n"
"    dependencies = {\"authors_repo\": Provide(provide_authors_repo)}\n"
"\n"
"    @get(path=\"/authors\")\n"
"    async def list_authors(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        limit_offset: filters.LimitOffset,\n"
"    ) -> OffsetPagination[Author]:\n"
"        \"\"\"List authors.\"\"\"\n"
"        results, total = await authors_repo.list_and_count(limit_offset)\n"
"        type_adapter = TypeAdapter(list[Author])\n"
"        return OffsetPagination[Author](\n"
"            items=type_adapter.validate_python(results),\n"
"            total=total,\n"
"            limit=limit_offset.limit,\n"
"            offset=limit_offset.offset,\n"
"        )\n"
"\n"
"    @post(path=\"/authors\")\n"
"    async def create_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorCreate,\n"
"    ) -> Author:\n"
"        \"\"\"Create a new author.\"\"\"\n"
"        obj = await authors_repo.add(\n"
"            AuthorModel(**data.model_dump(exclude_unset=True, "
"exclude_none=True)),\n"
"        )\n"
"        await authors_repo.session.commit()\n"
"        return Author.model_validate(obj)\n"
"\n"
"    # we override the authors_repo to use the version that joins the Books "
"in\n"
"    @get(path=\"/authors/{author_id:uuid}\", dependencies={\"authors_repo\": "
"Provide(provide_author_details_repo)})\n"
"    async def get_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to retrieve.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Get an existing author.\"\"\"\n"
"        obj = await authors_repo.get(author_id)\n"
"        return Author.model_validate(obj)\n"
"\n"
"    @patch(\n"
"        path=\"/authors/{author_id:uuid}\",\n"
"        dependencies={\"authors_repo\": "
"Provide(provide_author_details_repo)},\n"
"    )\n"
"    async def update_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        data: AuthorUpdate,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to update.\",\n"
"        ),\n"
"    ) -> Author:\n"
"        \"\"\"Update an author.\"\"\"\n"
"        raw_obj = data.model_dump(exclude_unset=True, exclude_none=True)\n"
"        raw_obj.update({\"id\": author_id})\n"
"        obj = await authors_repo.update(AuthorModel(**raw_obj))\n"
"        await authors_repo.session.commit()\n"
"        return Author.from_orm(obj)\n"
"\n"
"    @delete(path=\"/authors/{author_id:uuid}\")\n"
"    async def delete_author(\n"
"        self,\n"
"        authors_repo: AuthorRepository,\n"
"        author_id: UUID = Parameter(\n"
"            title=\"Author ID\",\n"
"            description=\"The author to delete.\",\n"
"        ),\n"
"    ) -> None:\n"
"        \"\"\"Delete a author from the system.\"\"\"\n"
"        _ = await authors_repo.delete(author_id)\n"
"        await authors_repo.session.commit()\n"
"\n"
"\n"
"session_config = AsyncSessionConfig(expire_on_commit=False)\n"
"sqlalchemy_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"session_config=session_config\n"
")  # Create 'db_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.get_engine().begin() as conn:\n"
"        await conn.run_sync(base.UUIDBase.metadata.create_all)\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[AuthorController],\n"
"    on_startup=[on_startup],\n"
"    plugins=[SQLAlchemyInitPlugin(config=sqlalchemy_config)],\n"
"    dependencies={\"limit_offset\": "
"Provide(provide_limit_offset_pagination)},\n"
")"
msgstr ""
