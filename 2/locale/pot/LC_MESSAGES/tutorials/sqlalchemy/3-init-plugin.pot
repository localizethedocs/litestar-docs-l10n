# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:2
msgid "Using the init plugin"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:4
msgid ""
"In our example application, we've seen that we need to manage the database "
"engine within the scope of the application's lifespan, and the session "
"within the scope of a request. This is a common pattern, and the :class:"
"`SQLAlchemyInitPlugin <litestar.contrib.sqlalchemy.plugins."
"SQLAlchemyInitPlugin>` plugin provides assistance for this."
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:9
msgid "In our latest update, we leverage two features of the plugin:"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:11
msgid ""
"The plugin will automatically create a database engine for us and manage it "
"within the scope of the application's lifespan."
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:13
msgid ""
"The plugin will automatically create a database session for us and manage it "
"within the scope of a request."
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:15
msgid ""
"We access the database session via dependency injection, using the "
"``db_session`` parameter."
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:17
msgid "Here's the updated code:"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:20
msgid ""
"from typing import AsyncGenerator, List, Optional\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import (\n"
"    SQLAlchemyAsyncConfig,\n"
"    SQLAlchemyInitPlugin,\n"
"    SQLAlchemySerializationPlugin,\n"
")\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"List[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> List[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"db_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///todo.sqlite\", metadata=Base."
"metadata, create_all=True\n"
")\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[\n"
"        SQLAlchemySerializationPlugin(),\n"
"        SQLAlchemyInitPlugin(db_config),\n"
"    ],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:20
msgid ""
"from typing import Optional\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import (\n"
"    SQLAlchemyAsyncConfig,\n"
"    SQLAlchemyInitPlugin,\n"
"    SQLAlchemySerializationPlugin,\n"
")\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: Optional[bool], session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: Optional[bool] = None) -"
"> list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"db_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///todo.sqlite\", metadata=Base."
"metadata, create_all=True\n"
")\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[\n"
"        SQLAlchemySerializationPlugin(),\n"
"        SQLAlchemyInitPlugin(db_config),\n"
"    ],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:20
msgid ""
"from collections.abc import AsyncGenerator\n"
"\n"
"from sqlalchemy import select\n"
"from sqlalchemy.exc import IntegrityError, NoResultFound\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, get, post, put\n"
"from litestar.exceptions import ClientException, NotFoundException\n"
"from litestar.plugins.sqlalchemy import (\n"
"    SQLAlchemyAsyncConfig,\n"
"    SQLAlchemyInitPlugin,\n"
"    SQLAlchemySerializationPlugin,\n"
")\n"
"from litestar.status_codes import HTTP_409_CONFLICT\n"
"\n"
"\n"
"class Base(DeclarativeBase): ...\n"
"\n"
"\n"
"class TodoItem(Base):\n"
"    __tablename__ = \"todo_items\"\n"
"\n"
"    title: Mapped[str] = mapped_column(primary_key=True)\n"
"    done: Mapped[bool]\n"
"\n"
"\n"
"async def provide_transaction(db_session: AsyncSession) -> "
"AsyncGenerator[AsyncSession, None]:\n"
"    try:\n"
"        async with db_session.begin():\n"
"            yield db_session\n"
"    except IntegrityError as exc:\n"
"        raise ClientException(\n"
"            status_code=HTTP_409_CONFLICT,\n"
"            detail=str(exc),\n"
"        ) from exc\n"
"\n"
"\n"
"async def get_todo_by_title(todo_name: str, session: AsyncSession) -> "
"TodoItem:\n"
"    query = select(TodoItem).where(TodoItem.title == todo_name)\n"
"    result = await session.execute(query)\n"
"    try:\n"
"        return result.scalar_one()\n"
"    except NoResultFound as e:\n"
"        raise NotFoundException(detail=f\"TODO {todo_name!r} not found\") "
"from e\n"
"\n"
"\n"
"async def get_todo_list(done: bool | None, session: AsyncSession) -> "
"list[TodoItem]:\n"
"    query = select(TodoItem)\n"
"    if done is not None:\n"
"        query = query.where(TodoItem.done.is_(done))\n"
"\n"
"    result = await session.execute(query)\n"
"    return list(result.scalars().all())\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(transaction: AsyncSession, done: bool | None = None) -> "
"list[TodoItem]:\n"
"    return await get_todo_list(done, transaction)\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem, transaction: AsyncSession) -> TodoItem:\n"
"    transaction.add(data)\n"
"    return data\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem, transaction: "
"AsyncSession) -> TodoItem:\n"
"    todo_item = await get_todo_by_title(item_title, transaction)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return todo_item\n"
"\n"
"\n"
"db_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///todo.sqlite\", metadata=Base."
"metadata, create_all=True\n"
")\n"
"\n"
"app = Litestar(\n"
"    [get_list, add_item, update_item],\n"
"    dependencies={\"transaction\": provide_transaction},\n"
"    plugins=[\n"
"        SQLAlchemySerializationPlugin(),\n"
"        SQLAlchemyInitPlugin(db_config),\n"
"    ],\n"
")"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:24
msgid ""
"The most notable difference is that we no longer need the "
"``db_connection()`` lifespan context manager - the plugin handles this for "
"us. It also handles the creation of the tables in our database if we supply "
"our metadata and set ``create_all=True`` when creating a "
"``SQLAlchemyAsyncConfig`` instance."
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:28
msgid ""
"Additionally, we have a new ``db_session`` dependency available to us, which "
"we use in our ``provide_transaction()`` dependency provider, instead of "
"creating our own session."
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:32
msgid "Next steps"
msgstr ""

#: ../../../tutorials/sqlalchemy/3-init-plugin.rst:34
msgid ""
"Next up, we'll make one final change to our application, and then we'll be "
"recap!"
msgstr ""
