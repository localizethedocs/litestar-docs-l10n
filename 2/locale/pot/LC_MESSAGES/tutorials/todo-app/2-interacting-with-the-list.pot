# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:2
msgid "Making the list interactive"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:4
msgid ""
"So far, our TODO list application is not very useful, since it's static. You "
"can't update items, nor add or remove them."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:8
msgid "Receiving incoming data"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:10
msgid ""
"Let's start by implementing a route handler that handles the creation of new "
"items. In the previous step you used the ``get`` decorator, which responds "
"to the ``GET`` HTTP method. In this case we want to react to ``POST`` "
"requests, so we are going to use the corresponding ``post`` decorator."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:16
msgid ""
"from typing import Any, Dict, List, Union\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"TODO_LIST: List[Dict[str, Union[str, bool]]] = []\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: Dict[str, Any]) -> List[Dict[str, Union[str, "
"bool]]]:\n"
"    TODO_LIST.append(data)\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([add_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:16
msgid ""
"from typing import Any, Union\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"TODO_LIST: list[dict[str, Union[str, bool]]] = []\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: dict[str, Any]) -> list[dict[str, Union[str, "
"bool]]]:\n"
"    TODO_LIST.append(data)\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([add_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:16
msgid ""
"from typing import Any\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"TODO_LIST: list[dict[str, str | bool]] = []\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: dict[str, Any]) -> list[dict[str, str | bool]]:\n"
"    TODO_LIST.append(data)\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([add_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:19
msgid ""
"Request data can be received via the ``data`` keyword. Litestar will "
"recognize this, and supply the data being sent with the request via this "
"parameter. As with the query parameters in the previous chapter, we use the "
"type annotations to configure what type of data we expect to receive, and "
"set up validation. In this case, Litestar will expect request data in the "
"form of JSON and use the type annotation we gave it to convert it into the "
"correct format."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:28
msgid ":doc:`/usage/requests`"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:32
msgid "Using the interactive documentation to test a route"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:34
msgid ""
"Since our example now uses the ``POST`` HTTP method, you can no longer "
"simply visit the URL in our browser and get a response. Instead, you can use "
"the interactive documentation to send a ``POST`` request. Because of the "
"OpenAPI schema generated by Litestar, Swagger will know exactly what kind of "
"data to send. In this example, it will send a simple JSON object."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:42
msgid ""
"Sending a sample request to our ``add_item`` route reveals a successful "
"response"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:46
msgid "Improving the example with dataclasses"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:48
msgid ""
"As in the previous chapter, this too can be improved by using :doc:"
"`dataclasses <python:library/dataclasses>` instead of plain dicts."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:52
msgid ""
"from dataclasses import dataclass\n"
"from typing import List\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = []\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem) -> List[TodoItem]:\n"
"    TODO_LIST.append(data)\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([add_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:52
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = []\n"
"\n"
"\n"
"@post(\"/\")\n"
"async def add_item(data: TodoItem) -> list[TodoItem]:\n"
"    TODO_LIST.append(data)\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([add_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:56
msgid ""
"This is not only easier on the eyes and adds more structure to the code, but "
"also gives better interactive documentation; it will now present us with the "
"field names and default values for the dataclass we have defined:"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:62
msgid ""
"Documentation for the ``add_item`` route with ``data`` typed as a ``dict`` "
"vs ``dataclass``"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:65
msgid ""
"Using a dataclass also gives you better validation: omitting a key such as "
"``title`` will result in a useful error response:"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:71
msgid "Sending a request without a ``title`` key fails"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:75
msgid "Create dynamic routes using path parameters"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:77
msgid ""
"The next task on the list is updating an item's status. For this, a way to "
"refer to a specific item on the list is needed. This could be done using "
"query parameters, but there's an easier, and more semantically coherent way "
"of expressing this: path parameters."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:83
msgid ""
"@get(\"/{name:str}\")\n"
"async def greeter(name: str) -> str:\n"
"    return \"Hello, \" + name"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:89
msgid ""
"So far all the paths in your application are static, meaning they are "
"expressed by a constant string which does not change. In fact, the only path "
"used so far is ``/``."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:92
msgid ""
"Path parameters allow you to construct dynamic paths and later refer to the "
"dynamically captured parts. This may sound complex at first, but it's "
"actually quite simple; you can think of it as a regular expression that's "
"being used on the requested path."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:96
msgid ""
"Path parameters consist of two parts: an expression inside the path, "
"describing the parameter, and a corresponding function parameter of the same "
"name in the route handler function, which will receive the path parameter's "
"value."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:100
msgid ""
"In the above example, a path parameter ``name:str`` is declared, which means "
"that now, a request to the path ``/john`` can be made, and the ``greeter`` "
"function will be called as ``greeter(name=\"john\")``, similar to how query "
"parameters are injected."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:106
msgid ""
"Just like query parameters, path parameters can convert and validate their "
"values as well. This is configured using the ``:type`` colon annotation, "
"similar to type annotations. For example, ``value:str`` will receive values "
"as a string, while ``value:int`` will try to convert it into an integer."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:111
msgid ""
"A full list of supported types can be found here: :ref:`usage/routing/"
"parameters:supported path parameter types`"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:115
msgid ""
"By using this pattern and combining it with those from the earlier section "
"about receiving data you can now set up a route handler that takes in the "
"title of a TODO item, an updated item in form of a dataclass instance, and "
"updates the item in the list."
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:122
msgid ""
"from dataclasses import dataclass\n"
"from typing import List\n"
"\n"
"from litestar import Litestar, put\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"def get_todo_by_title(todo_name) -> TodoItem:\n"
"    for item in TODO_LIST:\n"
"        if item.title == todo_name:\n"
"            return item\n"
"    raise NotFoundException(detail=f\"TODO {todo_name!r} not found\")\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem) -> List[TodoItem]:\n"
"    todo_item = get_todo_by_title(item_title)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([update_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:122
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, put\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"def get_todo_by_title(todo_name) -> TodoItem:\n"
"    for item in TODO_LIST:\n"
"        if item.title == todo_name:\n"
"            return item\n"
"    raise NotFoundException(detail=f\"TODO {todo_name!r} not found\")\n"
"\n"
"\n"
"@put(\"/{item_title:str}\")\n"
"async def update_item(item_title: str, data: TodoItem) -> list[TodoItem]:\n"
"    todo_item = get_todo_by_title(item_title)\n"
"    todo_item.title = data.title\n"
"    todo_item.done = data.done\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([update_item])"
msgstr ""

#: ../../../tutorials/todo-app/2-interacting-with-the-list.rst:127
msgid ":ref:`usage/routing/parameters:path parameters`"
msgstr ""
