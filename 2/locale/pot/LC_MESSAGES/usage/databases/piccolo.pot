# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/databases/piccolo.rst:2
msgid "Piccolo ORM"
msgstr ""

#: ../../../usage/databases/piccolo.rst:4
msgid ""
"Piccolo ORM is an easy-to-use async ORM and query builder and Litestar "
"includes the class :class:`PiccoloDTO <litestar.contrib.piccolo.PiccoloDTO>` "
"for data flow control. Example of a small application:"
msgstr ""

#: ../../../usage/databases/piccolo.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/databases/piccolo.rst:9
msgid "``app.py``"
msgstr ""

#: ../../../usage/databases/piccolo.rst:9
msgid ""
"from typing import List\n"
"\n"
"from piccolo.columns import Boolean, Varchar\n"
"from piccolo.table import Table, create_db_tables\n"
"\n"
"from litestar import Litestar, MediaType, delete, get, patch, post\n"
"from litestar.contrib.piccolo import PiccoloDTO\n"
"from litestar.dto import DTOConfig, DTOData\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"from .piccolo_conf import DB\n"
"\n"
"\n"
"class Task(Table, db=DB):\n"
"    \"\"\"\n"
"    An example table.\n"
"    \"\"\"\n"
"\n"
"    name = Varchar()\n"
"    completed = Boolean(default=False)\n"
"\n"
"\n"
"class PatchDTO(PiccoloDTO[Task]):\n"
"    \"\"\"Allow partial updates.\"\"\"\n"
"\n"
"    config = DTOConfig(exclude={\"id\"}, partial=True)\n"
"\n"
"\n"
"@get(\n"
"    \"/tasks\",\n"
"    return_dto=PiccoloDTO[Task],\n"
"    media_type=MediaType.JSON,\n"
"    tags=[\"Task\"],\n"
")\n"
"async def tasks() -> List[Task]:\n"
"    return await Task.select().order_by(Task.id, ascending=False)\n"
"\n"
"\n"
"@post(\n"
"    \"/tasks\",\n"
"    dto=PiccoloDTO[Task],\n"
"    return_dto=PiccoloDTO[Task],\n"
"    media_type=MediaType.JSON,\n"
"    tags=[\"Task\"],\n"
")\n"
"async def create_task(data: Task) -> Task:\n"
"    await data.save()\n"
"    await data.refresh()\n"
"    return data\n"
"\n"
"\n"
"@patch(\n"
"    \"/tasks/{task_id:int}\",\n"
"    dto=PatchDTO,\n"
"    return_dto=PiccoloDTO[Task],\n"
"    media_type=MediaType.JSON,\n"
"    tags=[\"Task\"],\n"
")\n"
"async def update_task(task_id: int, data: DTOData[Task]) -> Task:\n"
"    task = await Task.objects().get(Task.id == task_id)\n"
"    if not task:\n"
"        raise NotFoundException(\"Task does not exist\")\n"
"    result = data.update_instance(task)\n"
"    await result.save()\n"
"    return result\n"
"\n"
"\n"
"@delete(\"/tasks/{task_id:int}\", tags=[\"Task\"])\n"
"async def delete_task(task_id: int) -> None:\n"
"    task = await Task.objects().get(Task.id == task_id)\n"
"    if not task:\n"
"        raise NotFoundException(\"Task does not exist\")\n"
"    await task.remove()\n"
"\n"
"\n"
"async def on_startup():\n"
"    await create_db_tables(Task, if_not_exists=True)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[tasks, create_task, delete_task, "
"update_task], on_startup=[on_startup], debug=True)"
msgstr ""

#: ../../../usage/databases/piccolo.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/databases/piccolo.rst:9
msgid ""
"from piccolo.columns import Boolean, Varchar\n"
"from piccolo.table import Table, create_db_tables\n"
"\n"
"from litestar import Litestar, MediaType, delete, get, patch, post\n"
"from litestar.contrib.piccolo import PiccoloDTO\n"
"from litestar.dto import DTOConfig, DTOData\n"
"from litestar.exceptions import NotFoundException\n"
"\n"
"from .piccolo_conf import DB\n"
"\n"
"\n"
"class Task(Table, db=DB):\n"
"    \"\"\"\n"
"    An example table.\n"
"    \"\"\"\n"
"\n"
"    name = Varchar()\n"
"    completed = Boolean(default=False)\n"
"\n"
"\n"
"class PatchDTO(PiccoloDTO[Task]):\n"
"    \"\"\"Allow partial updates.\"\"\"\n"
"\n"
"    config = DTOConfig(exclude={\"id\"}, partial=True)\n"
"\n"
"\n"
"@get(\n"
"    \"/tasks\",\n"
"    return_dto=PiccoloDTO[Task],\n"
"    media_type=MediaType.JSON,\n"
"    tags=[\"Task\"],\n"
")\n"
"async def tasks() -> list[Task]:\n"
"    return await Task.select().order_by(Task.id, ascending=False)\n"
"\n"
"\n"
"@post(\n"
"    \"/tasks\",\n"
"    dto=PiccoloDTO[Task],\n"
"    return_dto=PiccoloDTO[Task],\n"
"    media_type=MediaType.JSON,\n"
"    tags=[\"Task\"],\n"
")\n"
"async def create_task(data: Task) -> Task:\n"
"    await data.save()\n"
"    await data.refresh()\n"
"    return data\n"
"\n"
"\n"
"@patch(\n"
"    \"/tasks/{task_id:int}\",\n"
"    dto=PatchDTO,\n"
"    return_dto=PiccoloDTO[Task],\n"
"    media_type=MediaType.JSON,\n"
"    tags=[\"Task\"],\n"
")\n"
"async def update_task(task_id: int, data: DTOData[Task]) -> Task:\n"
"    task = await Task.objects().get(Task.id == task_id)\n"
"    if not task:\n"
"        raise NotFoundException(\"Task does not exist\")\n"
"    result = data.update_instance(task)\n"
"    await result.save()\n"
"    return result\n"
"\n"
"\n"
"@delete(\"/tasks/{task_id:int}\", tags=[\"Task\"])\n"
"async def delete_task(task_id: int) -> None:\n"
"    task = await Task.objects().get(Task.id == task_id)\n"
"    if not task:\n"
"        raise NotFoundException(\"Task does not exist\")\n"
"    await task.remove()\n"
"\n"
"\n"
"async def on_startup():\n"
"    await create_db_tables(Task, if_not_exists=True)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[tasks, create_task, delete_task, "
"update_task], on_startup=[on_startup], debug=True)"
msgstr ""
