# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/routing/overview.rst:3
msgid "Overview"
msgstr ""

#: ../../../usage/routing/overview.rst:6
msgid "Registering Routes"
msgstr ""

#: ../../../usage/routing/overview.rst:8
msgid ""
"At the root of every Litestar application there is an instance of the :class:"
"`Litestar <litestar.app.Litestar>` class, on which the root level :class:"
"`controllers <.controller.Controller>`, :class:`routers <.router.Router>`, "
"and :class:`route handler <.handlers.BaseRouteHandler>` functions are "
"registered using the :paramref:`~litestar.config.app.AppConfig."
"route_handlers` :term:`kwarg <argument>`:"
msgstr ""

#: ../../../usage/routing/overview.rst:14
msgid "Registering route handlers"
msgstr ""

#: ../../../usage/routing/overview.rst:14
msgid ""
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get(\"/sub-path\")\n"
"def sub_path_handler() -> None: ...\n"
"\n"
"\n"
"@get()\n"
"def root_handler() -> None: ...\n"
"\n"
"\n"
"app = Litestar(route_handlers=[root_handler, sub_path_handler])"
msgstr ""

#: ../../../usage/routing/overview.rst:29
msgid ""
"Components registered on the app are appended to the root path. Thus, the "
"``root_handler`` function will be called for the path ``\"/\"``, whereas the "
"``sub_path_handler`` will be called for ``\"/sub-path\"``."
msgstr ""

#: ../../../usage/routing/overview.rst:32
msgid "You can also declare a function to handle multiple paths, e.g.:"
msgstr ""

#: ../../../usage/routing/overview.rst:35
msgid "Registering a route handler for multiple paths"
msgstr ""

#: ../../../usage/routing/overview.rst:35
msgid ""
"from litestar import get, Litestar\n"
"\n"
"\n"
"@get([\"/\", \"/sub-path\"])\n"
"def handler() -> None: ...\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler])"
msgstr ""

#: ../../../usage/routing/overview.rst:46
msgid ""
"To handle more complex path schemas you should use :class:`controllers <."
"controller.Controller>` and :class:`routers <.router.Router>`"
msgstr ""

#: ../../../usage/routing/overview.rst:50
msgid "Registering routes dynamically"
msgstr ""

#: ../../../usage/routing/overview.rst:52
msgid ""
"Occasionally there is a need for dynamic route registration. Litestar "
"supports this via the :paramref:`~.app.Litestar.register` method exposed by "
"the Litestar app instance:"
msgstr ""

#: ../../../usage/routing/overview.rst:56
msgid ""
"Registering a route handler dynamically with the :paramref:`~.app.Litestar."
"register` method"
msgstr ""

#: ../../../usage/routing/overview.rst:56
msgid ""
"from litestar import Litestar, get\n"
"\n"
"\n"
"@get()\n"
"def root_handler() -> None: ...\n"
"\n"
"\n"
"app = Litestar(route_handlers=[root_handler])\n"
"\n"
"\n"
"@get(\"/sub-path\")\n"
"def sub_path_handler() -> None: ...\n"
"\n"
"\n"
"app.register(sub_path_handler)"
msgstr ""

#: ../../../usage/routing/overview.rst:74
msgid ""
"Since the app instance is attached to all instances of :class:`~.connection."
"base.ASGIConnection`, :class:`~.connection.request.Request`, and :class:`~."
"connection.websocket.WebSocket` objects, you can in effect call the :meth:`~."
"router.Router.register` method inside route handler functions, middlewares, "
"and even injected dependencies. For example:"
msgstr ""

#: ../../../usage/routing/overview.rst:80
msgid ""
"Call the :meth:`~.router.Router.register` method from inside a route handler "
"function"
msgstr ""

#: ../../../usage/routing/overview.rst:80
msgid ""
"from typing import Any\n"
"from litestar import Litestar, Request, get\n"
"\n"
"\n"
"@get(\"/some-path\")\n"
"def route_handler(request: Request[Any, Any]) -> None:\n"
"   @get(\"/sub-path\")\n"
"   def sub_path_handler() -> None: ...\n"
"\n"
"   request.app.register(sub_path_handler)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[route_handler])"
msgstr ""

#: ../../../usage/routing/overview.rst:96
msgid ""
"In the above we dynamically created the ``sub_path_handler`` and registered "
"it inside the ``route_handler`` function."
msgstr ""

#: ../../../usage/routing/overview.rst:98
msgid ""
"Although Litestar exposes the :meth:`register <.router.Router.register>` "
"method, it should not be abused. Dynamic route registration increases the "
"application complexity and makes it harder to reason about the code. It "
"should therefore be used only when absolutely required."
msgstr ""

#: ../../../usage/routing/overview.rst:103
msgid ":class:`Routers <.router.Router>`"
msgstr ""

#: ../../../usage/routing/overview.rst:105
msgid ""
":class:`Routers <.router.Router>` are instances of the :class:`~.router."
"Router`, class which is the base class for the :class:`Litestar app <.app."
"Litestar>` itself."
msgstr ""

#: ../../../usage/routing/overview.rst:108
msgid ""
"A :class:`~.router.Router` can register :class:`Controllers <.controller."
"Controller>`, :class:`route handler <.handlers.BaseRouteHandler>` functions, "
"and other routers, similarly to the Litestar constructor:"
msgstr ""

#: ../../../usage/routing/overview.rst:112
msgid "Registering a :class:`~.router.Router`"
msgstr ""

#: ../../../usage/routing/overview.rst:112
msgid ""
"from litestar import Litestar, Router, get\n"
"\n"
"\n"
"@get(\"/{order_id:int}\")\n"
"def order_handler(order_id: int) -> None: ...\n"
"\n"
"\n"
"order_router = Router(path=\"/orders\", route_handlers=[order_handler])\n"
"base_router = Router(path=\"/base\", route_handlers=[order_router])\n"
"app = Litestar(route_handlers=[base_router])"
msgstr ""

#: ../../../usage/routing/overview.rst:125
msgid ""
"Once ``order_router`` is registered on ``base_router``, the handler function "
"registered on ``order_router`` will become available on ``/base/orders/"
"{order_id}``."
msgstr ""

#: ../../../usage/routing/overview.rst:129
msgid ":class:`Controllers <.controller.Controller>`"
msgstr ""

#: ../../../usage/routing/overview.rst:131
msgid ""
":class:`Controllers <.controller.Controller>` are subclasses of the :class:"
"`Controller <.controller.Controller>` class. They are used to organize "
"endpoints under a specific sub-path, which is the controller's path. Their "
"purpose is to allow users to utilize Python OOP for better code organization "
"and organize code by logical concerns."
msgstr ""

#: ../../../usage/routing/overview.rst:0
msgid "Click to see an example of registering a controller"
msgstr ""

#: ../../../usage/routing/overview.rst:138
msgid "Registering a :class:`~.controller.Controller`"
msgstr ""

#: ../../../usage/routing/overview.rst:138
msgid ""
"from litestar.plugins.pydantic import PydanticDTO\n"
"from litestar.controller import Controller\n"
"from litestar.dto import DTOConfig, DTOData\n"
"from litestar.handlers import get, post, patch, delete\n"
"from pydantic import BaseModel, UUID4\n"
"\n"
"\n"
"class UserOrder(BaseModel):\n"
"   user_id: int\n"
"   order: str\n"
"\n"
"\n"
"class PartialUserOrderDTO(PydanticDTO[UserOrder]):\n"
"   config = DTOConfig(partial=True)\n"
"\n"
"\n"
"class UserOrderController(Controller):\n"
"   path = \"/user-order\"\n"
"\n"
"   @post()\n"
"   async def create_user_order(self, data: UserOrder) -> UserOrder: ...\n"
"\n"
"   @get(path=\"/{order_id:uuid}\")\n"
"   async def retrieve_user_order(self, order_id: UUID4) -> UserOrder: ...\n"
"\n"
"   @patch(path=\"/{order_id:uuid}\", dto=PartialUserOrderDTO)\n"
"   async def update_user_order(\n"
"       self, order_id: UUID4, data: DTOData[PartialUserOrderDTO]\n"
"   ) -> UserOrder: ...\n"
"\n"
"   @delete(path=\"/{order_id:uuid}\")\n"
"   async def delete_user_order(self, order_id: UUID4) -> None: ..."
msgstr ""

#: ../../../usage/routing/overview.rst:173
msgid ""
"The above is a simple example of a \"CRUD\" controller for a model called "
"``UserOrder``. You can place as many :doc:`route handler methods </usage/"
"routing/handlers>` on a controller, as long as the combination of path+http "
"method is unique."
msgstr ""

#: ../../../usage/routing/overview.rst:177
msgid ""
"The ``path`` that is defined on the :class:`controller <.controller."
"Controller>` is appended before the path that is defined for the route "
"handlers declared on it. Thus, in the above example, ``create_user_order`` "
"has the path of the :class:`controller <.controller.Controller>` - ``/user-"
"order/``, while ``retrieve_user_order`` has the path ``/user-order/{order_id:"
"uuid}\"``."
msgstr ""

#: ../../../usage/routing/overview.rst:182
msgid ""
"If you do not declare a ``path`` class variable on the controller, it will "
"default to the root path of ``\"/\"``."
msgstr ""

#: ../../../usage/routing/overview.rst:185
msgid "Registering components multiple times"
msgstr ""

#: ../../../usage/routing/overview.rst:187
msgid ""
"You can register both standalone route handler functions and controllers "
"multiple times."
msgstr ""

#: ../../../usage/routing/overview.rst:190
msgid "Controllers"
msgstr ""

#: ../../../usage/routing/overview.rst:193
msgid "Registering a controller multiple times"
msgstr ""

#: ../../../usage/routing/overview.rst:193
msgid ""
"from litestar import Router, Controller, get\n"
"\n"
"\n"
"class MyController(Controller):\n"
"   path = \"/controller\"\n"
"\n"
"   @get()\n"
"   def handler(self) -> None: ...\n"
"\n"
"\n"
"internal_router = Router(path=\"/internal\", route_handlers=[MyController])\n"
"partner_router = Router(path=\"/partner\", route_handlers=[MyController])\n"
"consumer_router = Router(path=\"/consumer\", route_handlers=[MyController])"
msgstr ""

#: ../../../usage/routing/overview.rst:209
msgid ""
"In the above, the same ``MyController`` class has been registered on three "
"different routers. This is possible because what is passed to the :class:"
"`router <.router.Router>` is not a class instance but rather the class "
"itself. The :class:`router <.router.Router>` creates its own instance of "
"the :class:`controller <.controller.Controller>`, which ensures "
"encapsulation."
msgstr ""

#: ../../../usage/routing/overview.rst:214
msgid ""
"Therefore, in the above example, three different instances of "
"``MyController`` will be created, each mounted on a different sub-path, e."
"g., ``/internal/controller``, ``/partner/controller``, and ``/consumer/"
"controller``."
msgstr ""

#: ../../../usage/routing/overview.rst:218
msgid "Route handlers"
msgstr ""

#: ../../../usage/routing/overview.rst:220
msgid "You can also register standalone route handlers multiple times:"
msgstr ""

#: ../../../usage/routing/overview.rst:223
msgid "Registering a route handler multiple times"
msgstr ""

#: ../../../usage/routing/overview.rst:223
msgid ""
"from litestar import Litestar, Router, get\n"
"\n"
"\n"
"@get(path=\"/handler\")\n"
"def my_route_handler() -> None: ...\n"
"\n"
"\n"
"internal_router = Router(path=\"/internal\", "
"route_handlers=[my_route_handler])\n"
"partner_router = Router(path=\"/partner\", "
"route_handlers=[my_route_handler])\n"
"consumer_router = Router(path=\"/consumer\", "
"route_handlers=[my_route_handler])\n"
"\n"
"Litestar(route_handlers=[internal_router, partner_router, consumer_router])"
msgstr ""

#: ../../../usage/routing/overview.rst:238
msgid ""
"When the handler function is registered, it's actually copied. Thus, each "
"router has its own unique instance of the route handler. Path behaviour is "
"identical to that of controllers above, namely, the route handler function "
"will be accessible in the following paths: ``/internal/handler``, ``/partner/"
"handler``, and ``/consumer/handler``."
msgstr ""

#: ../../../usage/routing/overview.rst:242
msgid ""
"You can nest routers as you see fit - but be aware that once a router has "
"been registered it cannot be re-registered or an exception will be raised."
msgstr ""

#: ../../../usage/routing/overview.rst:246
msgid "Mounting ASGI Apps"
msgstr ""

#: ../../../usage/routing/overview.rst:248
msgid ""
"Litestar support \"mounting\" ASGI applications on sub-paths, i.e., "
"specifying a handler function that will handle all requests addressed to a "
"given path."
msgstr ""

#: ../../../usage/routing/overview.rst:0
msgid "Click to see an example of mounting an ASGI app"
msgstr ""

#: ../../../usage/routing/overview.rst:254
msgid "Mounting an ASGI App"
msgstr ""

#: ../../../usage/routing/overview.rst:254
msgid ""
"import json\n"
"from typing import TYPE_CHECKING\n"
"\n"
"from litestar import Litestar, asgi\n"
"from litestar.response.base import ASGIResponse\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar.types import Receive, Scope, Send\n"
"\n"
"\n"
"@asgi(\"/some/sub-path\", is_mount=True, copy_scope=True)\n"
"async def my_asgi_app(scope: \"Scope\", receive: \"Receive\", send: "
"\"Send\") -> None:\n"
"    \"\"\"\n"
"    Args:\n"
"        scope: The ASGI connection scope.\n"
"        receive: The ASGI receive function.\n"
"        send: The ASGI send function.\n"
"\n"
"    Returns:\n"
"        None\n"
"    \"\"\"\n"
"    body = json.dumps({\"forwarded_path\": scope[\"path\"]})\n"
"    response = ASGIResponse(body=body.encode(\"utf-8\"))\n"
"    await response(scope, receive, send)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[my_asgi_app])"
msgstr ""

#: ../../../usage/routing/overview.rst:257
msgid ""
"The handler function will receive all requests with an url that begins with "
"``/some/sub-path``, e.g, ``/some/sub-path``, ``/some/sub-path/abc``, ``/some/"
"sub-path/123/another/sub-path``, etc."
msgstr ""

#: ../../../usage/routing/overview.rst:260
msgid "Technical Details"
msgstr ""

#: ../../../usage/routing/overview.rst:263
msgid ""
"If we are sending a request to the above with the url ``/some/sub-path``, "
"the handler will be invoked and the value of ``scope[\"path\"]`` will equal "
"``\"/\"``. If we send a request to ``/some/sub-path/abc``, it will also be "
"invoked,and ``scope[\"path\"]`` will equal ``\"/abc\"``."
msgstr ""

#: ../../../usage/routing/overview.rst:267
msgid ""
"Mounting is especially useful when you need to combine components of other "
"ASGI applications - for example, for third party libraries. The following "
"example is identical in principle to the one above, but it uses `Starlette "
"<https://www.starlette.io/>`_:"
msgstr ""

#: ../../../usage/routing/overview.rst:0
msgid "Click to see an example of mounting a Starlette app"
msgstr ""

#: ../../../usage/routing/overview.rst:274
msgid "Mounting a Starlette App"
msgstr ""

#: ../../../usage/routing/overview.rst:274
msgid ""
"from typing import TYPE_CHECKING\n"
"\n"
"from starlette.applications import Starlette\n"
"from starlette.responses import JSONResponse\n"
"from starlette.routing import Route\n"
"\n"
"from litestar import Litestar, asgi\n"
"\n"
"if TYPE_CHECKING:\n"
"    from starlette.requests import Request\n"
"\n"
"\n"
"async def index(request: \"Request\") -> JSONResponse:\n"
"    \"\"\"A generic starlette handler.\"\"\"\n"
"    return JSONResponse({\"forwarded_path\": request.url.path})\n"
"\n"
"\n"
"starlette_app = asgi(path=\"/some/sub-path\", is_mount=True, copy_scope=True)"
"(\n"
"    Starlette(\n"
"        routes=[\n"
"            Route(\"/\", index),\n"
"            Route(\"/abc/\", index),\n"
"            Route(\"/123/another/sub-path/\", index),\n"
"        ],\n"
"    )\n"
")\n"
"\n"
"\n"
"app = Litestar(route_handlers=[starlette_app])"
msgstr ""

#: ../../../usage/routing/overview.rst:277
msgid "Why Litestar uses radix based routing"
msgstr ""

#: ../../../usage/routing/overview.rst:279
msgid ""
"The regex matching used by popular frameworks such as Starlette, FastAPI or "
"Flask is very good at resolving path parameters fast, giving it an advantage "
"when a URL has a lot of path parameters - what we can think of as "
"``vertical`` scaling. On the other hand, it is not good at scaling "
"horizontally - the more routes, the less performant it becomes. Thus, there "
"is an inverse relation between performance and application size with this "
"approach that strongly favors very small microservices. The **trie** based "
"approach used by Litestar is agnostic to the number of routes of the "
"application giving it better horizontal scaling characteristics at the "
"expense of somewhat slower resolution of path parameters."
msgstr ""

#: ../../../usage/routing/overview.rst:287
msgid ""
"Litestar implements its routing solution that is based on the concept of a "
"`radix tree <https://en.wikipedia.org/wiki/Radix_tree>`_ or *trie*."
msgstr ""

#: ../../../usage/routing/overview.rst:290
msgid ""
"If you are interested in the technical aspects of the implementation, refer "
"to `this GitHub issue <https://github.com/litestar-org/litestar/"
"issues/177>`_ - it includes an indepth discussion of the pertinent code."
msgstr ""
