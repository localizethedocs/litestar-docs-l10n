# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/testing.rst:2
msgid "Testing"
msgstr ""

#: ../../../usage/testing.rst:4
msgid ""
"Testing is a first class citizen in Litestar, which offers several powerful "
"testing utilities out of the box."
msgstr ""

#: ../../../usage/testing.rst:8
msgid "Test Client"
msgstr ""

#: ../../../usage/testing.rst:10
msgid ""
"Litestar's test client is built on top of the `httpx <https://github.com/"
"encode/httpx>`_ library. To use the test client you should pass to it an "
"instance of Litestar as the ``app`` kwarg."
msgstr ""

#: ../../../usage/testing.rst:14
msgid "Let's say we have a very simple app with a health check endpoint:"
msgstr ""

#: ../../../usage/testing.rst:17
msgid "``my_app/main.py``"
msgstr ""

#: ../../../usage/testing.rst:17
msgid ""
"from litestar import Litestar, MediaType, get\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check])"
msgstr ""

#: ../../../usage/testing.rst:30
msgid "We would then test it using the test client like so:"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Sync"
msgstr ""

#: ../../../usage/testing.rst:38 ../../../usage/testing.rst:58
#: ../../../usage/testing.rst:140 ../../../usage/testing.rst:148
msgid "``tests/test_health_check.py``"
msgstr ""

#: ../../../usage/testing.rst:38
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import TestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"def test_health_check():\n"
"    with TestClient(app=app) as client:\n"
"        response = client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Async"
msgstr ""

#: ../../../usage/testing.rst:58
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"async def test_health_check():\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        response = await client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:75
msgid ""
"Since we would probably need to use the client in multiple places, it's "
"better to make it into a pytest fixture:"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/testing.rst:84 ../../../usage/testing.rst:110
#: ../../../usage/testing.rst:447
msgid "``tests/conftest.py``"
msgstr ""

#: ../../../usage/testing.rst:84
msgid ""
"from typing import TYPE_CHECKING, Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import TestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/testing.rst:84
msgid ""
"from typing import TYPE_CHECKING\n"
"from collections.abc import Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import TestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:110
msgid ""
"from typing import TYPE_CHECKING, AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:110
msgid ""
"from typing import TYPE_CHECKING\n"
"from collections.abc import AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:132
msgid "We would then be able to rewrite our test like so:"
msgstr ""

#: ../../../usage/testing.rst:140
msgid ""
"from typing import Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar import Litestar, MediaType, get\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import TestClient\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT, "
"sync_to_thread=False)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check], debug=True)\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client\n"
"\n"
"\n"
"def test_health_check_with_fixture(test_client: TestClient[Litestar]) -> "
"None:\n"
"    response = test_client.get(\"/health-check\")\n"
"    assert response.status_code == HTTP_200_OK\n"
"    assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:140
msgid ""
"from collections.abc import Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar import Litestar, MediaType, get\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import TestClient\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT, "
"sync_to_thread=False)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check], debug=True)\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client\n"
"\n"
"\n"
"def test_health_check_with_fixture(test_client: TestClient[Litestar]) -> "
"None:\n"
"    response = test_client.get(\"/health-check\")\n"
"    assert response.status_code == HTTP_200_OK\n"
"    assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:148
msgid ""
"from typing import AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar import Litestar, MediaType, get\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT, "
"sync_to_thread=False)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check], debug=True)\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client\n"
"\n"
"\n"
"async def test_health_check_with_fixture(test_client: "
"AsyncTestClient[Litestar]) -> None:\n"
"    response = await test_client.get(\"/health-check\")\n"
"    assert response.status_code == HTTP_200_OK\n"
"    assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:148
msgid ""
"from collections.abc import AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar import Litestar, MediaType, get\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT, "
"sync_to_thread=False)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check], debug=True)\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client\n"
"\n"
"\n"
"async def test_health_check_with_fixture(test_client: "
"AsyncTestClient[Litestar]) -> None:\n"
"    response = await test_client.get(\"/health-check\")\n"
"    assert response.status_code == HTTP_200_OK\n"
"    assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:152
msgid "Testing websockets"
msgstr ""

#: ../../../usage/testing.rst:154
msgid ""
"Litestar's test client enhances the httpx client to support websockets. To "
"test a websocket endpoint, you can use the :meth:`websocket_connect "
"<litestar.testing.TestClient.websocket_connect>` method on the test client. "
"The method returns a websocket connection object that you can use to send "
"and receive messages, see an example below for json:"
msgstr ""

#: ../../../usage/testing.rst:157
msgid ""
"For more information, see also the :class:`WebSocket <litestar.connection."
"WebSocket>` class in the API documentation and the :ref:`websocket <usage/"
"websockets:websockets>` documentation."
msgstr ""

#: ../../../usage/testing.rst:160
msgid ""
"from typing import Any\n"
"\n"
"from litestar import WebSocket, websocket\n"
"from litestar.datastructures import State\n"
"from litestar.testing import create_test_client\n"
"\n"
"\n"
"def test_websocket() -> None:\n"
"    @websocket(path=\"/ws\")\n"
"    async def websocket_handler(socket: WebSocket[Any, Any, State]) -> "
"None:\n"
"        await socket.accept()\n"
"        recv = await socket.receive_json()\n"
"        await socket.send_json({\"message\": recv})\n"
"        await socket.close()\n"
"\n"
"    with create_test_client(route_handlers=[websocket_handler])."
"websocket_connect(\"/ws\") as ws:\n"
"        ws.send_json({\"hello\": \"world\"})\n"
"        data = ws.receive_json()\n"
"        assert data == {\"message\": {\"hello\": \"world\"}}"
msgstr ""

#: ../../../usage/testing.rst:164
msgid "Using sessions"
msgstr ""

#: ../../../usage/testing.rst:166
msgid ""
"If you are using :ref:`session middleware <usage/middleware/builtin-"
"middleware:session middleware>` for session persistence across requests, "
"then you might want to inject or inspect session data outside a request. For "
"this, :class:`TestClient <.testing.TestClient>` provides two methods:"
msgstr ""

#: ../../../usage/testing.rst:170
msgid ":meth:`set_session_data <litestar.testing.TestClient.set_session_data>`"
msgstr ""

#: ../../../usage/testing.rst:171
msgid ":meth:`get_session_data <litestar.testing.TestClient.get_session_data>`"
msgstr ""

#: ../../../usage/testing.rst:175
msgid ""
"The Session Middleware must be enabled in Litestar app provided to the "
"TestClient to use sessions."
msgstr ""

#: ../../../usage/testing.rst:176
msgid ""
"If you are using the :class:`ClientSideSessionBackend <litestar.middleware."
"session.client_side.ClientSideSessionBackend>` you need to install the "
"``cryptography`` package. You can do so by installing ``litestar``:"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "pip"
msgstr ""

#: ../../../usage/testing.rst:184
msgid "Using pip"
msgstr ""

#: ../../../usage/testing.rst:184
msgid "python3 -m pip install 'litestar[cryptography]'"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "pipx"
msgstr ""

#: ../../../usage/testing.rst:191
msgid "Using `pipx <https://pypa.github.io/pipx/>`_"
msgstr ""

#: ../../../usage/testing.rst:191
msgid "pipx install 'litestar[cryptography]'"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "pdm"
msgstr ""

#: ../../../usage/testing.rst:198
msgid "Using `PDM <https://pdm.fming.dev/>`_"
msgstr ""

#: ../../../usage/testing.rst:198
msgid "pdm add 'litestar[cryptography]'"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "poetry"
msgstr ""

#: ../../../usage/testing.rst:205
msgid "Using `poetry <https://python-poetry.org/>`_"
msgstr ""

#: ../../../usage/testing.rst:205
msgid "poetry add 'litestar[cryptography]'"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "uv"
msgstr ""

#: ../../../usage/testing.rst:212
msgid "Using `uv <https://docs.astral.sh/uv/>`_"
msgstr ""

#: ../../../usage/testing.rst:212
msgid "uv add 'litestar[cryptography]'"
msgstr ""

#: ../../../usage/testing.rst:223 ../../../usage/testing.rst:235
msgid "Setting session data"
msgstr ""

#: ../../../usage/testing.rst:223
msgid ""
"from typing import Any, Dict\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import TestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@get(path=\"/test\", sync_to_thread=False)\n"
"def get_session_data(request: Request) -> Dict[str, Any]:\n"
"    return request.session\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"def test_get_session_data() -> None:\n"
"    with TestClient(app=app, session_config=session_config) as client:\n"
"        client.set_session_data({\"foo\": \"bar\"})\n"
"        assert client.get(\"/test\").json() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:223
msgid ""
"from typing import Any\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import TestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@get(path=\"/test\", sync_to_thread=False)\n"
"def get_session_data(request: Request) -> dict[str, Any]:\n"
"    return request.session\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"def test_get_session_data() -> None:\n"
"    with TestClient(app=app, session_config=session_config) as client:\n"
"        client.set_session_data({\"foo\": \"bar\"})\n"
"        assert client.get(\"/test\").json() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:228 ../../../usage/testing.rst:240
msgid "Getting session data"
msgstr ""

#: ../../../usage/testing.rst:228
msgid ""
"from litestar import Litestar, Request, post\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import TestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@post(path=\"/test\", sync_to_thread=False)\n"
"def set_session_data(request: Request) -> None:\n"
"    request.session[\"foo\"] = \"bar\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[set_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"with TestClient(app=app, session_config=session_config) as client:\n"
"    client.post(\"/test\").json()\n"
"    assert client.get_session_data() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:235
msgid ""
"from typing import Any, Dict\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@get(path=\"/test\", sync_to_thread=False)\n"
"def get_session_data(request: Request) -> Dict[str, Any]:\n"
"    return request.session\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"async def test_get_session_data() -> None:\n"
"    async with AsyncTestClient(app=app, session_config=session_config) as "
"client:\n"
"        await client.set_session_data({\"foo\": \"bar\"})\n"
"        res = await client.get(\"/test\")\n"
"        assert res.json() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:235
msgid ""
"from typing import Any\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@get(path=\"/test\", sync_to_thread=False)\n"
"def get_session_data(request: Request) -> dict[str, Any]:\n"
"    return request.session\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"async def test_get_session_data() -> None:\n"
"    async with AsyncTestClient(app=app, session_config=session_config) as "
"client:\n"
"        await client.set_session_data({\"foo\": \"bar\"})\n"
"        res = await client.get(\"/test\")\n"
"        assert res.json() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:240
msgid ""
"from litestar import Litestar, Request, post\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@post(path=\"/test\", sync_to_thread=False)\n"
"def set_session_data(request: Request) -> None:\n"
"    request.session[\"foo\"] = \"bar\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[set_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"async def test_set_session_data() -> None:\n"
"    async with AsyncTestClient(app=app, session_config=session_config) as "
"client:\n"
"        await client.post(\"/test\")\n"
"        assert await client.get_session_data() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:245 ../../../usage/testing.rst:258
msgid "Using a blocking portal"
msgstr ""

#: ../../../usage/testing.rst:247
msgid ""
"The :class:`TestClient <.testing.TestClient>` uses a feature of `anyio "
"<https://anyio.readthedocs.io/en/stable/>`_ called a **Blocking Portal**."
msgstr ""

#: ../../../usage/testing.rst:250
msgid ""
"The :class:`anyio.abc.BlockingPortal` allows :class:`TestClient <.testing."
"TestClient>` to execute asynchronous functions using a synchronous call. "
"``TestClient`` creates a blocking portal to manage ``Litestar``'s async "
"logic, and it allows ``TestClient``'s API to remain fully synchronous."
msgstr ""

#: ../../../usage/testing.rst:254
msgid ""
"Any tests that are using an instance of ``TestClient`` can also make use of "
"the blocking portal to execute asynchronous functions without the test "
"itself being asynchronous."
msgstr ""

#: ../../../usage/testing.rst:258
msgid ""
"from concurrent.futures import Future, wait\n"
"\n"
"import anyio\n"
"\n"
"from litestar.testing import create_test_client\n"
"\n"
"\n"
"def test_with_portal() -> None:\n"
"    \"\"\"This example shows how to manage asynchronous tasks using a "
"portal.\n"
"\n"
"    The test function itself is not async. Asynchronous functions are "
"executed and awaited using the portal.\n"
"    \"\"\"\n"
"\n"
"    async def get_float(value: float) -> float:\n"
"        await anyio.sleep(value)\n"
"        return value\n"
"\n"
"    with create_test_client(route_handlers=[]) as test_client, test_client."
"portal() as portal:\n"
"        # start a background task with the portal\n"
"        future: Future[float] = portal.start_task_soon(get_float, 0.25)\n"
"        # do other work\n"
"        assert portal.call(get_float, 0.1) == 0.1\n"
"        # wait for the background task to complete\n"
"        wait([future])\n"
"        assert future.done()\n"
"        assert future.result() == 0.25"
msgstr ""

#: ../../../usage/testing.rst:263
msgid "Creating a test app"
msgstr ""

#: ../../../usage/testing.rst:265
msgid ""
"Litestar also offers a helper function called :func:`create_test_client "
"<litestar.testing.create_test_client>` which first creates an instance of "
"Litestar and then a test client using it. There are multiple use cases for "
"this helper - when you need to check generic logic that is decoupled from a "
"specific Litestar app, or when you want to test endpoints in isolation."
msgstr ""

#: ../../../usage/testing.rst:269
msgid ""
"You can pass to this helper all the kwargs accepted by the litestar "
"constructor, with the ``route_handlers`` kwarg being **required**. Yet "
"unlike the Litestar app, which expects ``route_handlers`` to be a list, here "
"you can also pass individual values."
msgstr ""

#: ../../../usage/testing.rst:273
msgid "For example, you can do this:"
msgstr ""

#: ../../../usage/testing.rst:276 ../../../usage/testing.rst:293
msgid "``my_app/tests/test_health_check.py``"
msgstr ""

#: ../../../usage/testing.rst:276
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import create_test_client\n"
"\n"
"from my_app.main import health_check\n"
"\n"
"\n"
"def test_health_check():\n"
"    with create_test_client(route_handlers=[health_check]) as client:\n"
"        response = client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:290
msgid "But also this:"
msgstr ""

#: ../../../usage/testing.rst:293
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import create_test_client\n"
"\n"
"from my_app.main import health_check\n"
"\n"
"\n"
"def test_health_check():\n"
"    with create_test_client(route_handlers=health_check) as client:\n"
"        response = client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:309
msgid "Running a live server"
msgstr ""

#: ../../../usage/testing.rst:311
msgid ""
"The test clients make use of HTTPX's ability to directly call into an ASGI "
"app, without having to run an actual server. In most cases this is "
"sufficient but there are some exceptions where this won't work, due to the "
"limitations of the emulated client-server communication."
msgstr ""

#: ../../../usage/testing.rst:316
msgid ""
"For example, when using server-sent events with an infinite generator, it "
"will lock up the test client, since HTTPX tries to consume the full response "
"before returning a request."
msgstr ""

#: ../../../usage/testing.rst:320
msgid ""
"Litestar offers two helper functions, :func:`litestar.testing."
"subprocess_sync_client` and :func:`litestar.testing.subprocess_async_client` "
"that will launch a Litestar instance with in a subprocess and set up an "
"httpx client for running tests. You can either load your actual app file or "
"create subsets from it as you would with the regular test client setup:"
msgstr ""

#: ../../../usage/testing.rst:328
msgid ""
"\"\"\"\n"
"Assemble components into an app that shall be tested\n"
"\"\"\"\n"
"\n"
"from typing import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import ServerSentEvent\n"
"from litestar.types import SSEData\n"
"\n"
"\n"
"async def generator(topic: str) -> AsyncGenerator[SSEData, None]:\n"
"    count = 0\n"
"    while count < 2:\n"
"        yield topic\n"
"        count += 1\n"
"\n"
"\n"
"@get(\"/notify/{topic:str}\")\n"
"async def get_notified(topic: str) -> ServerSentEvent:\n"
"    return ServerSentEvent(generator(topic), event_type=\"Notifier\")\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_notified])"
msgstr ""

#: ../../../usage/testing.rst:328
msgid ""
"\"\"\"\n"
"Assemble components into an app that shall be tested\n"
"\"\"\"\n"
"\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import ServerSentEvent\n"
"from litestar.types import SSEData\n"
"\n"
"\n"
"async def generator(topic: str) -> AsyncGenerator[SSEData, None]:\n"
"    count = 0\n"
"    while count < 2:\n"
"        yield topic\n"
"        count += 1\n"
"\n"
"\n"
"@get(\"/notify/{topic:str}\")\n"
"async def get_notified(topic: str) -> ServerSentEvent:\n"
"    return ServerSentEvent(generator(topic), event_type=\"Notifier\")\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_notified])"
msgstr ""

#: ../../../usage/testing.rst:331
msgid ""
"\"\"\"\n"
"Test the app running in a subprocess\n"
"\"\"\"\n"
"\n"
"import asyncio\n"
"import pathlib\n"
"import sys\n"
"from typing import AsyncIterator\n"
"\n"
"import httpx\n"
"import httpx_sse\n"
"import pytest\n"
"\n"
"from litestar.testing import subprocess_async_client\n"
"\n"
"if sys.platform == \"win32\":\n"
"    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n"
"\n"
"\n"
"ROOT = pathlib.Path(__file__).parent\n"
"\n"
"\n"
"@pytest.fixture(name=\"async_client\")\n"
"async def fx_async_client() -> AsyncIterator[httpx.AsyncClient]:\n"
"    async with subprocess_async_client(workdir=ROOT, "
"app=\"subprocess_sse_app:app\") as client:\n"
"        yield client\n"
"\n"
"\n"
"async def test_subprocess_async_client(async_client: httpx.AsyncClient) -> "
"None:\n"
"    \"\"\"Demonstrates functionality of the async client with an infinite "
"SSE source that cannot be tested with the\n"
"    regular async test client.\n"
"    \"\"\"\n"
"    topic = \"demo\"\n"
"\n"
"    async with httpx_sse.aconnect_sse(async_client, \"GET\", f\"/notify/"
"{topic}\") as event_source:\n"
"        async for event in event_source.aiter_sse():\n"
"            assert event.data == topic\n"
"            break"
msgstr ""

#: ../../../usage/testing.rst:331
msgid ""
"\"\"\"\n"
"Test the app running in a subprocess\n"
"\"\"\"\n"
"\n"
"import asyncio\n"
"import pathlib\n"
"import sys\n"
"from collections.abc import AsyncIterator\n"
"\n"
"import httpx\n"
"import httpx_sse\n"
"import pytest\n"
"\n"
"from litestar.testing import subprocess_async_client\n"
"\n"
"if sys.platform == \"win32\":\n"
"    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n"
"\n"
"\n"
"ROOT = pathlib.Path(__file__).parent\n"
"\n"
"\n"
"@pytest.fixture(name=\"async_client\")\n"
"async def fx_async_client() -> AsyncIterator[httpx.AsyncClient]:\n"
"    async with subprocess_async_client(workdir=ROOT, "
"app=\"subprocess_sse_app:app\") as client:\n"
"        yield client\n"
"\n"
"\n"
"async def test_subprocess_async_client(async_client: httpx.AsyncClient) -> "
"None:\n"
"    \"\"\"Demonstrates functionality of the async client with an infinite "
"SSE source that cannot be tested with the\n"
"    regular async test client.\n"
"    \"\"\"\n"
"    topic = \"demo\"\n"
"\n"
"    async with httpx_sse.aconnect_sse(async_client, \"GET\", f\"/notify/"
"{topic}\") as event_source:\n"
"        async for event in event_source.aiter_sse():\n"
"            assert event.data == topic\n"
"            break"
msgstr ""

#: ../../../usage/testing.rst:333
msgid ""
"By default, the subprocess client will capture all output from the litestar "
"instance. To discard output in the main (testing) process, set the "
"``capture_output`` argument to ``False`` when creating the client:"
msgstr ""

#: ../../../usage/testing.rst:336
msgid ""
"@pytest.fixture(name=\"async_client\")\n"
"async def fx_async_client() -> AsyncIterator[httpx.AsyncClient]:\n"
"    async with subprocess_async_client(workdir=ROOT, "
"app=\"subprocess_sse_app:app\", capture_output=False) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:344
msgid "RequestFactory"
msgstr ""

#: ../../../usage/testing.rst:346
msgid ""
"Another helper is the :class:`RequestFactory <litestar.testing."
"RequestFactory>` class, which creates instances of :class:`litestar."
"connection.request.Request <litestar.connection.request.Request>`. The use "
"case for this helper is when you need to test logic that expects to receive "
"a request object."
msgstr ""

#: ../../../usage/testing.rst:350
msgid ""
"For example, lets say we wanted to unit test a *guard* function in "
"isolation, to which end we'll reuse the examples from the :doc:`route guards "
"</usage/security/guards>` documentation:"
msgstr ""

#: ../../../usage/testing.rst:355
msgid "``my_app/guards.py``"
msgstr ""

#: ../../../usage/testing.rst:355
msgid ""
"from litestar import Request\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.handlers.base import BaseRouteHandler\n"
"\n"
"\n"
"def secret_token_guard(request: Request, route_handler: BaseRouteHandler) -> "
"None:\n"
"    if (\n"
"        route_handler.opt.get(\"secret\")\n"
"        and not request.headers.get(\"Secret-Header\", \"\") == "
"route_handler.opt[\"secret\"]\n"
"    ):\n"
"        raise NotAuthorizedException()"
msgstr ""

#: ../../../usage/testing.rst:369
msgid "We already have our route handler in place:"
msgstr ""

#: ../../../usage/testing.rst:372
msgid "``my_app/secret.py``"
msgstr ""

#: ../../../usage/testing.rst:372
msgid ""
"from os import environ\n"
"\n"
"from litestar import get\n"
"\n"
"from my_app.guards import secret_token_guard\n"
"\n"
"\n"
"@get(path=\"/secret\", guards=[secret_token_guard], opt={\"secret\": environ."
"get(\"SECRET\")})\n"
"def secret_endpoint() -> None: ..."
msgstr ""

#: ../../../usage/testing.rst:384
msgid "We could thus test the guard function like so:"
msgstr ""

#: ../../../usage/testing.rst:387
msgid "``tests/guards/test_secret_token_guard.py``"
msgstr ""

#: ../../../usage/testing.rst:387
msgid ""
"import pytest\n"
"\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.testing import RequestFactory\n"
"\n"
"from my_app.guards import secret_token_guard\n"
"from my_app.secret import secret_endpoint\n"
"\n"
"request = RequestFactory().get(\"/\")\n"
"\n"
"\n"
"def test_secret_token_guard_failure_scenario():\n"
"    copied_endpoint_handler = secret_endpoint.copy()\n"
"    copied_endpoint_handler.opt[\"secret\"] = None\n"
"    with pytest.raises(NotAuthorizedException):\n"
"        secret_token_guard(request=request, "
"route_handler=copied_endpoint_handler)\n"
"\n"
"\n"
"def test_secret_token_guard_success_scenario():\n"
"    copied_endpoint_handler = secret_endpoint.copy()\n"
"    copied_endpoint_handler.opt[\"secret\"] = \"super-secret\"\n"
"    secret_token_guard(request=request, "
"route_handler=copied_endpoint_handler)"
msgstr ""

#: ../../../usage/testing.rst:414
msgid "Using polyfactory"
msgstr ""

#: ../../../usage/testing.rst:416
msgid ""
"`Polyfactory <https://github.com/litestar-org/polyfactory>`__ offers an easy "
"and powerful way to generate mock data from pydantic models and dataclasses."
msgstr ""

#: ../../../usage/testing.rst:419
msgid ""
"Let's say we have an API that talks to an external service and retrieves "
"some data:"
msgstr ""

#: ../../../usage/testing.rst:422 ../../../usage/testing.rst:481
msgid "``main.py``"
msgstr ""

#: ../../../usage/testing.rst:422
msgid ""
"from typing import Protocol, runtime_checkable\n"
"\n"
"from polyfactory.factories.pydantic import BaseModel\n"
"from litestar import get\n"
"\n"
"\n"
"class Item(BaseModel):\n"
"    name: str\n"
"\n"
"\n"
"@runtime_checkable\n"
"class Service(Protocol):\n"
"    def get(self) -> Item: ...\n"
"\n"
"\n"
"@get(path=\"/item\")\n"
"def get_item(service: Service) -> Item:\n"
"    return service.get()"
msgstr ""

#: ../../../usage/testing.rst:444
msgid "We could test the ``/item`` route like so:"
msgstr ""

#: ../../../usage/testing.rst:447
msgid ""
"import pytest\n"
"\n"
"from litestar.di import Provide\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import create_test_client\n"
"\n"
"from my_app.main import Service, Item, get_item\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def item():\n"
"    return Item(name=\"Chair\")\n"
"\n"
"\n"
"def test_get_item(item: Item):\n"
"    class MyService(Service):\n"
"        def get_one(self) -> Item:\n"
"            return item\n"
"\n"
"    with create_test_client(\n"
"        route_handlers=get_item, dependencies={\"service\": Provide(lambda: "
"MyService())}\n"
"    ) as client:\n"
"        response = client.get(\"/item\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.json() == item.dict()"
msgstr ""

#: ../../../usage/testing.rst:475
msgid ""
"While we can define the test data manually, as is done in the above, this "
"can be quite cumbersome. That's where `polyfactory <https://github.com/"
"litestar-org/polyfactory>`_ library comes in. It generates mock data for "
"pydantic models and dataclasses based on type annotations. With it, we could "
"rewrite the above example like so:"
msgstr ""

#: ../../../usage/testing.rst:481
msgid ""
"from typing import Protocol, runtime_checkable\n"
"\n"
"import pytest\n"
"from pydantic import BaseModel\n"
"from polyfactory.factories.pydantic_factory import ModelFactory\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar import get\n"
"from litestar.di import Provide\n"
"from litestar.testing import create_test_client\n"
"\n"
"\n"
"class Item(BaseModel):\n"
"    name: str\n"
"\n"
"\n"
"@runtime_checkable\n"
"class Service(Protocol):\n"
"    def get_one(self) -> Item: ...\n"
"\n"
"\n"
"@get(path=\"/item\")\n"
"def get_item(service: Service) -> Item:\n"
"    return service.get_one()\n"
"\n"
"\n"
"class ItemFactory(ModelFactory[Item]):\n"
"    model = Item\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def item():\n"
"    return ItemFactory.build()\n"
"\n"
"\n"
"def test_get_item(item: Item):\n"
"    class MyService(Service):\n"
"        def get_one(self) -> Item:\n"
"            return item\n"
"\n"
"    with create_test_client(\n"
"        route_handlers=get_item, dependencies={\"service\": Provide(lambda: "
"MyService())}\n"
"    ) as client:\n"
"        response = client.get(\"/item\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.json() == item.dict()"
msgstr ""
