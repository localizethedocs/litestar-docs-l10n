# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/contrib/jwt.rst:2
msgid "JWT Security Backends"
msgstr ""

#: ../../../usage/contrib/jwt.rst:4
msgid ""
"Starlite offers optional JWT based security backends. To use these make sure "
"to install the ``python-jose`` and ``cryptography`` packages, or simply "
"install Starlite with the jwt extra: ``pip install starlite[jwt]``."
msgstr ""

#: ../../../usage/contrib/jwt.rst:8
msgid "JWT Auth Backend"
msgstr ""

#: ../../../usage/contrib/jwt.rst:10
msgid ""
"This is the base JWT Auth backend. You can read about its particular API in "
"the :class:`API Reference <starlite.contrib.jwt.JWTAuth>`. It sends the JWT "
"token using a header - and it expects requests to send the JWT token using "
"the same header key."
msgstr ""

#: ../../../usage/contrib/jwt.rst:0
msgid "Python 3.8+"
msgstr "Python 3.8+"

#: ../../../usage/contrib/jwt.rst:15
msgid "Using JWT Auth"
msgstr ""

#: ../../../usage/contrib/jwt.rst:15
msgid ""
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Response,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.contrib.jwt import JWTAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# JWTAuth requires a retrieve handler callable that receives the JWT token "
"model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"ASGIConnection[Any, Any, Any]) -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    cached_value = await connection.cache.get(token.sub)\n"
"    if cached_value:\n"
"        return User(**cached_value)\n"
"    return None\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTAuth' we can create a login handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any]\", data: User) -> "
"Response[User]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"    response = jwt_auth.login(identifier=str(data.id), response_body=data)\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\")\n"
"def some_route_handler(request: Request[User, Token]) -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'starlite_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_auth 'on_app_init' handler "
"to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Starlite(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/contrib/jwt.rst:0
msgid "Python 3.10+"
msgstr "Python 3.10+"

#: ../../../usage/contrib/jwt.rst:15
msgid ""
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Response,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.contrib.jwt import JWTAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# JWTAuth requires a retrieve handler callable that receives the JWT token "
"model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"ASGIConnection[Any, Any, Any]) -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    cached_value = await connection.cache.get(token.sub)\n"
"    if cached_value:\n"
"        return User(**cached_value)\n"
"    return None\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTAuth' we can create a login handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any]\", data: User) -> "
"Response[User]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"    response = jwt_auth.login(identifier=str(data.id), response_body=data)\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\")\n"
"def some_route_handler(request: Request[User, Token]) -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'starlite_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_auth 'on_app_init' handler "
"to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Starlite(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/contrib/jwt.rst:20
msgid "JWT Cookie Auth Backend"
msgstr ""

#: ../../../usage/contrib/jwt.rst:22
msgid ""
"This backend inherits from the :class:`JWTAuth <starlite.contrib.jwt."
"JWTAuth>` backend, with the difference being that instead of using a header "
"for the JWT Token, it uses a cookie."
msgstr ""

#: ../../../usage/contrib/jwt.rst:26
msgid "Using JWT Cookie Auth"
msgstr ""

#: ../../../usage/contrib/jwt.rst:26
msgid ""
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Response,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.contrib.jwt import JWTCookieAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# JWTCookieAuth requires a retrieve handler callable that receives the JWT "
"token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"ASGIConnection[Any, Any, Any]) -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    cached_value = await connection.cache.get(token.sub)\n"
"    if cached_value:\n"
"        return User(**cached_value)\n"
"    return None\n"
"\n"
"\n"
"jwt_cookie_auth = JWTCookieAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
"    # Tip: We can optionally supply cookie options to the configuration.  "
"Here is an example of enabling the secure cookie option\n"
"    # auth_cookie_options=CookieOptions(secure=True),\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTCookieAuth' we can create a login handler "
"function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any]\", data: User) -> "
"Response[User]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"    response = jwt_cookie_auth.login(identifier=str(data.id), "
"response_body=data)\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\")\n"
"def some_route_handler(request: Request[User, Token]) -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'starlite_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Starlite(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_cookie_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/contrib/jwt.rst:26
msgid ""
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Response,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.contrib.jwt import JWTCookieAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# JWTCookieAuth requires a retrieve handler callable that receives the JWT "
"token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"ASGIConnection[Any, Any, Any]) -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    cached_value = await connection.cache.get(token.sub)\n"
"    if cached_value:\n"
"        return User(**cached_value)\n"
"    return None\n"
"\n"
"\n"
"jwt_cookie_auth = JWTCookieAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
"    # Tip: We can optionally supply cookie options to the configuration.  "
"Here is an example of enabling the secure cookie option\n"
"    # auth_cookie_options=CookieOptions(secure=True),\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTCookieAuth' we can create a login handler "
"function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any]\", data: User) -> "
"Response[User]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"    response = jwt_cookie_auth.login(identifier=str(data.id), "
"response_body=data)\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\")\n"
"def some_route_handler(request: Request[User, Token]) -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'starlite_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Starlite(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_cookie_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/contrib/jwt.rst:31
msgid "OAuth2 Bearer Password Flow"
msgstr ""

#: ../../../usage/contrib/jwt.rst:33
msgid ""
"This backend inherits from the :class:`JWTCookieAuth <starlite.contrib.jwt."
"JWTCookieAuth>` backend. It works similarly to the ``JWTCookieAuth`` "
"backend, but is meant to be used for OAUTH2 Bearer password flows."
msgstr ""

#: ../../../usage/contrib/jwt.rst:37
msgid "Using OAUTH2 Bearer Password"
msgstr ""

#: ../../../usage/contrib/jwt.rst:37
msgid ""
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Response,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.contrib.jwt import OAuth2Login, OAuth2PasswordBearerAuth, "
"Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# OAuth2PasswordBearerAuth requires a retrieve handler callable that "
"receives the JWT token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"ASGIConnection[Any, Any, Any]) -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    cached_value = await connection.cache.get(token.sub)\n"
"    if cached_value:\n"
"        return User(**cached_value)\n"
"    return None\n"
"\n"
"\n"
"oauth2_auth = OAuth2PasswordBearerAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying the URL for retrieving a JWT access token\n"
"    token_url=\"/login\",\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'OAuth2PasswordBearerAuth' we can create a login "
"handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any]\", data: User) -> "
"Response[OAuth2Login]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"    # if we do not define a response body, the login process will return a "
"standard OAuth2 login response.  Note the `Response[OAuth2Login]` return "
"type.\n"
"    response = oauth2_auth.login(identifier=str(data.id))\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"@post(\"/login_custom\")\n"
"async def login_custom_response_handler(request: \"Request[Any, Any]\", "
"data: User) -> Response[User]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"\n"
"    # If you'd like to define a custom response body, use the "
"`response_body` parameter.  Note the `Response[User]` return type.\n"
"    response = oauth2_auth.login(identifier=str(data.id), "
"response_body=data)\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\")\n"
"def some_route_handler(request: Request[User, Token]) -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'starlite_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the oauth2_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Starlite(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[oauth2_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/contrib/jwt.rst:37
msgid ""
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Response,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.contrib.jwt import OAuth2Login, OAuth2PasswordBearerAuth, "
"Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# OAuth2PasswordBearerAuth requires a retrieve handler callable that "
"receives the JWT token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"ASGIConnection[Any, Any, Any]) -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    cached_value = await connection.cache.get(token.sub)\n"
"    if cached_value:\n"
"        return User(**cached_value)\n"
"    return None\n"
"\n"
"\n"
"oauth2_auth = OAuth2PasswordBearerAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying the URL for retrieving a JWT access token\n"
"    token_url=\"/login\",\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'OAuth2PasswordBearerAuth' we can create a login "
"handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any]\", data: User) -> "
"Response[OAuth2Login]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"    # if we do not define a response body, the login process will return a "
"standard OAuth2 login response.  Note the `Response[OAuth2Login]` return "
"type.\n"
"    response = oauth2_auth.login(identifier=str(data.id))\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"@post(\"/login_custom\")\n"
"async def login_custom_response_handler(request: \"Request[Any, Any]\", "
"data: User) -> Response[User]:\n"
"    await request.cache.set(str(data.id), data.dict())\n"
"\n"
"    # If you'd like to define a custom response body, use the "
"`response_body` parameter.  Note the `Response[User]` return type.\n"
"    response = oauth2_auth.login(identifier=str(data.id), "
"response_body=data)\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"\n"
"    return response\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\")\n"
"def some_route_handler(request: Request[User, Token]) -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'starlite_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the oauth2_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Starlite(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[oauth2_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""
