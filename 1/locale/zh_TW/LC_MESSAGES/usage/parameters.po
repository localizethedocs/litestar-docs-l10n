# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/parameters.rst:2
msgid "Parameters"
msgstr "參數"

#: ../../../usage/parameters.rst:5
msgid "Path Parameters"
msgstr ""

#: ../../../usage/parameters.rst:7
msgid ""
"Path parameters are parameters declared as part of the ``path`` component of "
"the URL. They are declared using a simple syntax ``{param_name:param_type}"
"`` :"
msgstr ""

#: ../../../usage/parameters.rst:11
msgid ""
"from pydantic import BaseModel\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"USER_DB = {1: {\"id\": 1, \"name\": \"John Doe\"}}\n"
"\n"
"\n"
"class User(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/user/{user_id:int}\")\n"
"def get_user(user_id: int) -> User:\n"
"    return User.parse_obj(USER_DB[user_id])\n"
"\n"
"\n"
"app = Starlite(route_handlers=[get_user])"
msgstr ""

#: ../../../usage/parameters.rst:15
msgid "In the above there are two components:"
msgstr ""

#: ../../../usage/parameters.rst:17
msgid ""
"The path parameter is defined in the ``@get`` decorator, which declares both "
"the parameter's name ``user_id``) and type ``int``."
msgstr ""

#: ../../../usage/parameters.rst:18
msgid ""
"The decorated function ``get_user`` defines a parameter with the same name "
"as the parameter defined in the ``path`` kwarg."
msgstr ""

#: ../../../usage/parameters.rst:20
msgid ""
"The correlation of parameter name ensures that the value of the path "
"parameter will be injected into the function when it's called."
msgstr ""

#: ../../../usage/parameters.rst:24
msgid "Supported Path Parameter Types"
msgstr ""

#: ../../../usage/parameters.rst:26
msgid "Currently, the following types are supported:"
msgstr ""

#: ../../../usage/parameters.rst:29
msgid "``date``: Accepts date strings and time stamps."
msgstr ""

#: ../../../usage/parameters.rst:30
msgid "``datetime``: Accepts date-time strings and time stamps."
msgstr ""

#: ../../../usage/parameters.rst:31
msgid "``decimal``: Accepts decimal values and floats."
msgstr ""

#: ../../../usage/parameters.rst:32
msgid "``float``: Accepts ints and floats."
msgstr ""

#: ../../../usage/parameters.rst:33
msgid "``int``: Accepts ints and floats."
msgstr ""

#: ../../../usage/parameters.rst:34
msgid "``path``: Accepts valid POSIX paths."
msgstr ""

#: ../../../usage/parameters.rst:35
msgid "``str``: Accepts all string values."
msgstr ""

#: ../../../usage/parameters.rst:36
msgid ""
"``time``: Accepts time strings with optional timezone compatible with "
"pydantic formats."
msgstr ""

#: ../../../usage/parameters.rst:37
msgid ""
"``timedelta``: Accepts duration strings compatible with the pydantic formats."
msgstr ""

#: ../../../usage/parameters.rst:38
msgid "``uuid``: Accepts all uuid values."
msgstr ""

#: ../../../usage/parameters.rst:40
msgid ""
"The types declared in the path parameter and the function do not need to "
"match 1:1 - as long as parameter inside the function declaration is typed "
"with a \"higher\" type to which the lower type can be coerced, this is fine. "
"For example, consider this:"
msgstr ""

#: ../../../usage/parameters.rst:0
msgid "Python 3.8+"
msgstr "Python 3.8+"

#: ../../../usage/parameters.rst:45
msgid ""
"from datetime import datetime, timezone\n"
"from typing import List\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"class Order(BaseModel):\n"
"    id: int\n"
"    customer_id: int\n"
"\n"
"\n"
"ORDERS_BY_DATETIME = {\n"
"    datetime.fromtimestamp(1667924386, tz=timezone.utc): [\n"
"        Order(id=1, customer_id=2),\n"
"        Order(id=2, customer_id=2),\n"
"    ]\n"
"}\n"
"\n"
"\n"
"@get(path=\"/orders/{from_date:int}\")\n"
"def get_orders(from_date: datetime) -> List[Order]:\n"
"    return ORDERS_BY_DATETIME[from_date]\n"
"\n"
"\n"
"app = Starlite(route_handlers=[get_orders])"
msgstr ""

#: ../../../usage/parameters.rst:0
msgid "Python 3.10+"
msgstr "Python 3.10+"

#: ../../../usage/parameters.rst:45
msgid ""
"from datetime import datetime, timezone\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"class Order(BaseModel):\n"
"    id: int\n"
"    customer_id: int\n"
"\n"
"\n"
"ORDERS_BY_DATETIME = {\n"
"    datetime.fromtimestamp(1667924386, tz=timezone.utc): [\n"
"        Order(id=1, customer_id=2),\n"
"        Order(id=2, customer_id=2),\n"
"    ]\n"
"}\n"
"\n"
"\n"
"@get(path=\"/orders/{from_date:int}\")\n"
"def get_orders(from_date: datetime) -> list[Order]:\n"
"    return ORDERS_BY_DATETIME[from_date]\n"
"\n"
"\n"
"app = Starlite(route_handlers=[get_orders])"
msgstr ""

#: ../../../usage/parameters.rst:0
msgid "Python 3.11+"
msgstr ""

#: ../../../usage/parameters.rst:45
msgid ""
"from datetime import datetime, UTC\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"class Order(BaseModel):\n"
"    id: int\n"
"    customer_id: int\n"
"\n"
"\n"
"ORDERS_BY_DATETIME = {\n"
"    datetime.fromtimestamp(1667924386, tz=UTC): [\n"
"        Order(id=1, customer_id=2),\n"
"        Order(id=2, customer_id=2),\n"
"    ]\n"
"}\n"
"\n"
"\n"
"@get(path=\"/orders/{from_date:int}\")\n"
"def get_orders(from_date: datetime) -> list[Order]:\n"
"    return ORDERS_BY_DATETIME[from_date]\n"
"\n"
"\n"
"app = Starlite(route_handlers=[get_orders])"
msgstr ""

#: ../../../usage/parameters.rst:49
msgid ""
"The parameter defined inside the ``path`` kwarg is typed as :class:`int` , "
"because the value passed as part of the request will be a timestamp in "
"milliseconds without any decimals. The parameter in the function declaration "
"though is typed as :class:`datetime.datetime`. This works because the int "
"value will be passed to a pydantic model representing the function "
"signature, which will coerce the int into a datetime. Thus, when the "
"function is called it will be called with a datetime typed parameter."
msgstr ""

#: ../../../usage/parameters.rst:57
msgid ""
"You only need to define the parameter in the function declaration if it's "
"actually used inside the function. If the path parameter is part of the "
"path, but the function doesn't use it, it's fine to omit it. It will still "
"be validated and added to the openapi schema correctly."
msgstr ""

#: ../../../usage/parameters.rst:63
msgid "Extra validation and documentation for path params"
msgstr ""

#: ../../../usage/parameters.rst:65
msgid ""
"If you want to add validation or enhance the OpenAPI documentation generated "
"for a given path parameter, you can do so using the `the parameter "
"function`_:"
msgstr ""

#: ../../../usage/parameters.rst:69
msgid ""
"from pydantic import BaseModel, Json, conint\n"
"from pydantic_openapi_schema.v3_1_0.example import Example\n"
"from pydantic_openapi_schema.v3_1_0.external_documentation import "
"ExternalDocumentation\n"
"\n"
"from starlite import Parameter, Starlite, get\n"
"\n"
"\n"
"class Version(BaseModel):\n"
"    id: conint(ge=1, le=10)  # type: ignore[valid-type]\n"
"    specs: Json\n"
"\n"
"\n"
"VERSIONS = {1: Version(id=1, specs='{\"some\": \"value\"}')}\n"
"\n"
"\n"
"@get(path=\"/versions/{version:int}\")\n"
"def get_product_version(\n"
"    version: int = Parameter(\n"
"        ge=1,\n"
"        le=10,\n"
"        title=\"Available Product Versions\",\n"
"        description=\"Get a specific version spec from the available "
"specs\",\n"
"        examples=[Example(value=1)],\n"
"        external_docs=ExternalDocumentation(\n"
"            url=\"https://mywebsite.com/documentation/product#versions\",  # "
"type: ignore[arg-type]\n"
"        ),\n"
"    )\n"
") -> Version:\n"
"    return VERSIONS[version]\n"
"\n"
"\n"
"app = Starlite(route_handlers=[get_product_version])"
msgstr ""

#: ../../../usage/parameters.rst:72
msgid ""
"In the above example, :class:`Parameter <.params.Parameter>` is used to "
"restrict the value of ``version`` to a range between 1 and 10, and then set "
"the ``title``, ``description``, ``examples`` and ``externalDocs`` sections "
"of the OpenAPI schema."
msgstr ""

#: ../../../usage/parameters.rst:78
msgid "Query Parameters"
msgstr ""

#: ../../../usage/parameters.rst:80
msgid ""
"Query parameters are defined as keyword arguments to handler functions. "
"Every keyword argument that is not otherwise specified (for example as a :"
"ref:`path parameter <usage/parameters:path parameters>`) will be interpreted "
"as a query parameter."
msgstr ""

#: ../../../usage/parameters.rst:85
msgid ""
"from typing import Dict\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: str) -> Dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"# run: /?param=foo\n"
"# run: /?param=bar"
msgstr ""

#: ../../../usage/parameters.rst:85
msgid ""
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: str) -> dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"# run: /?param=foo\n"
"# run: /?param=bar"
msgstr ""

#: ../../../usage/parameters.rst:88
msgid "Technical details"
msgstr ""

#: ../../../usage/parameters.rst:91
msgid ""
"These parameters will be parsed from the function signature and used to "
"generate a pydantic model. This model in turn will be used to validate the "
"parameters and generate the OpenAPI schema."
msgstr ""

#: ../../../usage/parameters.rst:94
msgid ""
"This means that you can also use any pydantic type in the signature, and it "
"will follow the same kind of validation and parsing as you would get from "
"pydantic."
msgstr ""

#: ../../../usage/parameters.rst:97
msgid "Query parameters come in three basic types:"
msgstr ""

#: ../../../usage/parameters.rst:100
msgid "Required"
msgstr ""

#: ../../../usage/parameters.rst:101
msgid "Required with a default value"
msgstr ""

#: ../../../usage/parameters.rst:102
msgid "Optional with a default value"
msgstr ""

#: ../../../usage/parameters.rst:104
msgid ""
"Query parameters are **required** by default. If one such a parameter has no "
"value, a :class:`ValidationException <.exceptions.http_exceptions."
"ValidationException>` will be raised."
msgstr ""

#: ../../../usage/parameters.rst:108
msgid "Settings defaults"
msgstr ""

#: ../../../usage/parameters.rst:110
msgid ""
"In this example, ``param`` will have the value ``\"hello\"`` if it's not "
"specified in the request. If it's passed as a query parameter however, it "
"will be overwritten:"
msgstr ""

#: ../../../usage/parameters.rst:114
msgid ""
"from typing import Dict\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: str = \"hello\") -> Dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"\n"
"# run: /\n"
"# run: /?param=john"
msgstr ""

#: ../../../usage/parameters.rst:114
msgid ""
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: str = \"hello\") -> dict[str, str]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"\n"
"# run: /\n"
"# run: /?param=john"
msgstr ""

#: ../../../usage/parameters.rst:118
msgid "Optional parameters"
msgstr ""

#: ../../../usage/parameters.rst:120
msgid ""
"Instead of only setting a default value, it's also possible to make a query "
"parameter entirely optional."
msgstr ""

#: ../../../usage/parameters.rst:123
msgid ""
"Here, we give a default value of ``None`` , but still declare the type of "
"the query parameter to be a string. This means that this parameter is not "
"required. If it is given, it has to be a string. If it is not given, it will "
"have a default value of ``None``"
msgstr ""

#: ../../../usage/parameters.rst:128
msgid ""
"from typing import Dict, Optional\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: Optional[str] = None) -> Dict[str, Optional[str]]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"\n"
"# run: /\n"
"# run: /?param=goodbye"
msgstr ""

#: ../../../usage/parameters.rst:128
msgid ""
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: str | None = None) -> dict[str, str | None]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"\n"
"# run: /\n"
"# run: /?param=goodbye"
msgstr ""

#: ../../../usage/parameters.rst:132
msgid "Type coercion"
msgstr ""

#: ../../../usage/parameters.rst:134
msgid ""
"It is possible to coerce query parameters into different types. A query "
"starts out as a string, but its values can be parsed into all kinds of "
"types. Since this is done by pydantic, everything that works there will work "
"for query parameters as well."
msgstr ""

#: ../../../usage/parameters.rst:139
msgid ""
"from datetime import datetime, timedelta\n"
"from typing import Any, Dict, List\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(\n"
"    date: datetime,\n"
"    number: int,\n"
"    floating_number: float,\n"
"    strings: List[str],\n"
") -> Dict[str, Any]:\n"
"    return {\n"
"        \"datetime\": date + timedelta(days=1),\n"
"        \"int\": number,\n"
"        \"float\": floating_number,\n"
"        \"list\": strings,\n"
"    }\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"\n"
"# run: /?"
"date=2022-11-28T13:22:06.916540&floating_number=0.1&number=42&strings=1&strings=2"
msgstr ""

#: ../../../usage/parameters.rst:139
msgid ""
"from datetime import datetime, timedelta\n"
"from typing import Any\n"
"\n"
"from starlite import Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(\n"
"    date: datetime,\n"
"    number: int,\n"
"    floating_number: float,\n"
"    strings: list[str],\n"
") -> dict[str, Any]:\n"
"    return {\n"
"        \"datetime\": date + timedelta(days=1),\n"
"        \"int\": number,\n"
"        \"float\": floating_number,\n"
"        \"list\": strings,\n"
"    }\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"\n"
"# run: /?"
"date=2022-11-28T13:22:06.916540&floating_number=0.1&number=42&strings=1&strings=2"
msgstr ""

#: ../../../usage/parameters.rst:144
msgid "Specifying alternative names and constraints"
msgstr ""

#: ../../../usage/parameters.rst:146
msgid ""
"Sometimes you might want to \"remap\" query parameters to allow a different "
"name in the URL than what's being used in the handler function. This can be "
"done by making use of :func:`Parameter <.params.Parameter>`."
msgstr ""

#: ../../../usage/parameters.rst:151
msgid ""
"from typing import Dict\n"
"\n"
"from starlite import Parameter, Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(snake_case: str = Parameter(query=\"camelCase\")) -> Dict[str, "
"str]:\n"
"    return {\"param\": snake_case}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"# run: /?camelCase=foo"
msgstr ""

#: ../../../usage/parameters.rst:151
msgid ""
"from starlite import Parameter, Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(snake_case: str = Parameter(query=\"camelCase\")) -> dict[str, "
"str]:\n"
"    return {\"param\": snake_case}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])\n"
"\n"
"# run: /?camelCase=foo"
msgstr ""

#: ../../../usage/parameters.rst:154
msgid ""
"Here, we remap from ``snake_case`` in the handler function to ``camelCase`` "
"in the URL. This means that for the URL ``http://127.0.0.1:8000?"
"camelCase=foo`` , the value of ``camelCase`` will be used for the value of "
"the ``snake_case`` parameter."
msgstr ""

#: ../../../usage/parameters.rst:158
msgid "``Parameter`` also allows us to define additional constraints:"
msgstr ""

#: ../../../usage/parameters.rst:161
msgid ""
"from typing import Dict\n"
"\n"
"from starlite import Parameter, Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: int = Parameter(gt=5)) -> Dict[str, int]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])"
msgstr ""

#: ../../../usage/parameters.rst:161
msgid ""
"from starlite import Parameter, Starlite, get\n"
"\n"
"\n"
"@get(\"/\")\n"
"def index(param: int = Parameter(gt=5)) -> dict[str, int]:\n"
"    return {\"param\": param}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[index])"
msgstr ""

#: ../../../usage/parameters.rst:164
msgid "In this case, ``param`` is validated to be an *integer larger than 5*."
msgstr ""

#: ../../../usage/parameters.rst:169
msgid "Header and Cookie Parameters"
msgstr ""

#: ../../../usage/parameters.rst:171
msgid ""
"Unlike *Query* parameters, *Header* and *Cookie* parameters have to be "
"declared using `the parameter function`_ , for example:"
msgstr ""

#: ../../../usage/parameters.rst:175
msgid ""
"from pydantic import BaseModel\n"
"\n"
"from starlite import NotAuthorizedException, Parameter, Starlite, get\n"
"\n"
"USER_DB = {\n"
"    1: {\n"
"        \"id\": 1,\n"
"        \"name\": \"John Doe\",\n"
"    },\n"
"}\n"
"\n"
"VALID_TOKEN = \"super-secret-secret\"\n"
"VALID_COOKIE_VALUE = \"cookie-secret\"\n"
"\n"
"\n"
"class User(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(path=\"/users/{user_id:int}/\")\n"
"async def get_user(\n"
"    user_id: int,\n"
"    token: str = Parameter(header=\"X-API-KEY\"),\n"
"    cookie: str = Parameter(cookie=\"my-cookie-param\"),\n"
") -> User:\n"
"    if not (token == VALID_TOKEN and cookie == VALID_COOKIE_VALUE):\n"
"        raise NotAuthorizedException\n"
"    return User.parse_obj(USER_DB[user_id])\n"
"\n"
"\n"
"app = Starlite(route_handlers=[get_user])"
msgstr ""

#: ../../../usage/parameters.rst:179
msgid ""
"As you can see in the above, header parameters are declared using the "
"``header`` kwargs and cookie parameters using the ``cookie`` kwarg. Aside "
"form this difference they work the same as query parameters."
msgstr ""

#: ../../../usage/parameters.rst:185
msgid "The Parameter Function"
msgstr ""

#: ../../../usage/parameters.rst:187
msgid ""
":class:`Parameter <.params.Parameter>` is a wrapper on top of the pydantic "
"`Field function <https://pydantic-docs.helpmanual.io/usage/schema/#field-"
"customization>`_ that extends it with a set of Starlite specific kwargs. As "
"such, you can use most of the kwargs of *Field* with Parameter and have the "
"same parsing and validation. The additional kwargs accepted by ``Parameter`` "
"are passed to the resulting pydantic ``FieldInfo`` as an ``extra`` "
"dictionary and have no effect on the working of pydantic itself."
msgstr ""

#: ../../../usage/parameters.rst:196
msgid "Layered Parameters"
msgstr ""

#: ../../../usage/parameters.rst:198
msgid ""
"As part of Starlite's \"layered\" architecture, you can declare parameters "
"not only as part of individual route handler functions, but also on other "
"layers of the application:"
msgstr ""

#: ../../../usage/parameters.rst:202
msgid ""
"from typing import Dict, Union\n"
"\n"
"from starlite import Controller, Parameter, Router, Starlite, get\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    parameters = {\n"
"        \"controller_param\": Parameter(int, lt=100),\n"
"    }\n"
"\n"
"    @get(\"/{path_param:int}\")\n"
"    def my_handler(\n"
"        self,\n"
"        path_param: int,\n"
"        local_param: str,\n"
"        router_param: str,\n"
"        controller_param: int = Parameter(int, lt=50),\n"
"    ) -> Dict[str, Union[str, int]]:\n"
"        return {\n"
"            \"path_param\": path_param,\n"
"            \"local_param\": local_param,\n"
"            \"router_param\": router_param,\n"
"            \"controller_param\": controller_param,\n"
"        }\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    parameters={\n"
"        \"router_param\": Parameter(str, regex=\"^[a-zA-Z]$\", "
"header=\"MyHeader\", required=False),\n"
"    },\n"
")\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[router],\n"
"    parameters={\n"
"        \"app_param\": Parameter(str, cookie=\"special-cookie\"),\n"
"    },\n"
")"
msgstr ""

#: ../../../usage/parameters.rst:202
msgid ""
"from starlite import Controller, Parameter, Router, Starlite, get\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    parameters = {\n"
"        \"controller_param\": Parameter(int, lt=100),\n"
"    }\n"
"\n"
"    @get(\"/{path_param:int}\")\n"
"    def my_handler(\n"
"        self,\n"
"        path_param: int,\n"
"        local_param: str,\n"
"        router_param: str,\n"
"        controller_param: int = Parameter(int, lt=50),\n"
"    ) -> dict[str, str | int]:\n"
"        return {\n"
"            \"path_param\": path_param,\n"
"            \"local_param\": local_param,\n"
"            \"router_param\": router_param,\n"
"            \"controller_param\": controller_param,\n"
"        }\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    parameters={\n"
"        \"router_param\": Parameter(str, regex=\"^[a-zA-Z]$\", "
"header=\"MyHeader\", required=False),\n"
"    },\n"
")\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[router],\n"
"    parameters={\n"
"        \"app_param\": Parameter(str, cookie=\"special-cookie\"),\n"
"    },\n"
")"
msgstr ""

#: ../../../usage/parameters.rst:206
msgid ""
"In the above we declare parameters on the app, router and controller levels "
"in addition to those declared in the route handler. Let's look at these "
"closer."
msgstr ""

#: ../../../usage/parameters.rst:210
msgid ""
"``app_param`` is a cookie param with the key ``special-cookie``. We type it "
"as ``str`` by passing this as an arg to the ``Parameter`` function. This is "
"required for us to get typing in the OpenAPI docs. Additionally, this "
"parameter is assumed to be required because it is not explicitly declared as "
"``required=False``. This is important because the route handler function "
"does not declare a parameter called ``app_param`` at all, but it will still "
"require this param to be sent as part of the request of validation will fail."
msgstr ""

#: ../../../usage/parameters.rst:215
msgid ""
"``router_param`` is a header param with the key ``MyHeader``. Because its "
"declared as ``required=False`` , it will not fail validation if not present "
"unless explicitly declared by a route handler - and in this case it is. "
"Thus, it is actually required for the router handler function that declares "
"it as an ``str`` and not an ``Optional[str]``. If a string value is "
"provided, it will be tested against the provided regex."
msgstr ""

#: ../../../usage/parameters.rst:219
msgid ""
"``controller_param`` is a query param with the key ``controller_param``. It "
"has an ``lt=100`` defined on the controller, which means the provided value "
"must be less than 100. Yet the route handler re-declares it with an "
"``lt=50`` , which means for the route handler this value must be less than "
"50."
msgstr ""

#: ../../../usage/parameters.rst:223
msgid ""
"``local_param`` is a route handler local query parameter, and ``path_param`` "
"is a path parameter."
msgstr ""

#: ../../../usage/parameters.rst:227
msgid ""
"You cannot declare path parameters in different application layers. The "
"reason for this is to ensure simplicity - otherwise parameter resolution "
"becomes very difficult to do correctly."
msgstr ""
