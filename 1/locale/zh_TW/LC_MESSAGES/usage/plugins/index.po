# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/plugins/index.rst:2
msgid "Plugins"
msgstr ""

#: ../../../usage/plugins/index.rst:4
msgid ""
"Starlite supports extension through plugins, which allow for the following:"
msgstr ""

#: ../../../usage/plugins/index.rst:7
msgid ""
"Updating the :doc:`Starlite application </usage/the-starlite-app>` during "
"the init process"
msgstr ""

#: ../../../usage/plugins/index.rst:8
msgid ""
"Serialization and deserialization of non-pydantic based 3rd party classes"
msgstr ""

#: ../../../usage/plugins/index.rst:9
msgid "Automatic OpenAPI schema creation for 3rd party classes"
msgstr ""

#: ../../../usage/plugins/index.rst:11
msgid ""
"Thus, plugins allow for a wide range of actions - from registering "
"middleware to the parsing and validation of incoming data using non-pydantic "
"classes. Additionally, they allow for seamless serialization and schema "
"generation."
msgstr ""

#: ../../../usage/plugins/index.rst:15
msgid "Creating Plugins"
msgstr ""

#: ../../../usage/plugins/index.rst:17
msgid ""
"A plugin is a class that implements the :class:`PluginProtocol <starlite."
"plugins.base.PluginProtocol>`."
msgstr ""

#: ../../../usage/plugins/index.rst:19
msgid ""
"If you wish to support the serialization and deserialization of none-"
"pydantic classes, you need to implement the following methods specified by "
"the:"
msgstr ""

#: ../../../usage/plugins/index.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/plugins/index.rst:23
msgid ""
"from typing import Type, Any, Dict\n"
"from starlite import PluginProtocol\n"
"from pydantic import BaseModel\n"
"\n"
"\n"
"class MyClass: ...\n"
"\n"
"\n"
"class MyPlugin(PluginProtocol[MyClass]):\n"
"    \"\"\"\n"
"    The class for which we create a plugin. For example, could be a base ORM "
"class such as \"Model\" or \"Document\" etc.\n"
"    \"\"\"\n"
"\n"
"    ...\n"
"\n"
"    def to_pydantic_model_class(\n"
"        self, model_class: Type[MyClass], **kwargs: Any\n"
"    ) -> Type[BaseModel]:\n"
"        \"\"\"\n"
"        Given a model_class, convert it to a subclass of the pydantic "
"BaseModel\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    @staticmethod\n"
"    def is_plugin_supported_type(value: Any) -> bool:\n"
"        \"\"\"\n"
"        Given a value of indeterminate type, determine if this value is "
"supported by the plugin by returning a bool.\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    def from_pydantic_model_instance(\n"
"        self, model_class: Type[MyClass], pydantic_model_instance: "
"BaseModel\n"
"    ) -> MyClass:\n"
"        \"\"\"\n"
"        Given an instance of a pydantic model created using a plugin's "
"``to_pydantic_model_class``,\n"
"        return an instance of the class from which that pydantic model has "
"been created.\n"
"\n"
"        This class is passed in as the ``model_class`` kwarg.\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    def to_dict(self, model_instance: MyClass) -> Dict[str, Any]:\n"
"        \"\"\"\n"
"        Given an instance of a model supported by the plugin, return a "
"dictionary of serializable values.\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    def from_dict(self, model_class: Type[MyClass], **kwargs: Any) -> "
"MyClass:\n"
"        \"\"\"\n"
"        Given a class supported by this plugin and a dict of values, create "
"an instance of the class\n"
"        \"\"\"\n"
"        ..."
msgstr ""

#: ../../../usage/plugins/index.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/plugins/index.rst:23
msgid ""
"from typing import Any\n"
"from starlite import PluginProtocol\n"
"from pydantic import BaseModel\n"
"\n"
"\n"
"class MyClass: ...\n"
"\n"
"\n"
"class MyPlugin(PluginProtocol[MyClass]):\n"
"    \"\"\"\n"
"    The class for which we create a plugin. For example, could be a base ORM "
"class such as \"Model\" or \"Document\" etc.\n"
"    \"\"\"\n"
"\n"
"    ...\n"
"\n"
"    def to_pydantic_model_class(\n"
"        self, model_class: type[MyClass], **kwargs: Any\n"
"    ) -> type[BaseModel]:\n"
"        \"\"\"\n"
"        Given a model_class, convert it to a subclass of the pydantic "
"BaseModel\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    @staticmethod\n"
"    def is_plugin_supported_type(value: Any) -> bool:\n"
"        \"\"\"\n"
"        Given a value of indeterminate type, determine if this value is "
"supported by the plugin by returning a bool.\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    def from_pydantic_model_instance(\n"
"        self, model_class: type[MyClass], pydantic_model_instance: "
"BaseModel\n"
"    ) -> MyClass:\n"
"        \"\"\"\n"
"        Given an instance of a pydantic model created using a plugin's "
"``to_pydantic_model_class``,\n"
"        return an instance of the class from which that pydantic model has "
"been created.\n"
"\n"
"        This class is passed in as the ``model_class`` kwarg.\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    def to_dict(self, model_instance: MyClass) -> dict[str, Any]:\n"
"        \"\"\"\n"
"        Given an instance of a model supported by the plugin, return a "
"dictionary of serializable values.\n"
"        \"\"\"\n"
"        ...\n"
"\n"
"    def from_dict(self, model_class: type[MyClass], **kwargs: Any) -> "
"MyClass:\n"
"        \"\"\"\n"
"        Given a class supported by this plugin and a dict of values, create "
"an instance of the class\n"
"        \"\"\"\n"
"        ..."
msgstr ""

#: ../../../usage/plugins/index.rst:77
msgid ""
"If you wish to register middlewares, guards, dependencies and so forth on "
"the application init, you need to implement the :meth:`on_app_init <starlite."
"plugins.base.PluginProtocol.on_app_init>` method:"
msgstr ""

#: ../../../usage/plugins/index.rst:81
msgid ""
"from typing import Any\n"
"from starlite import PluginProtocol, Starlite, get\n"
"\n"
"\n"
"@get(\"/some-path\")\n"
"def my_handler() -> None: ...\n"
"\n"
"\n"
"class MyPlugin(PluginProtocol[Any]):\n"
"    def on_app_init(self, app: Starlite) -> None:\n"
"        # register a route handler\n"
"        app.register(my_handler)\n"
"\n"
"        # update attributes of the application before init is finished.\n"
"        app.after_request = ...\n"
"        app.after_response = ...\n"
"        app.before_request = ...\n"
"        app.dependencies.update({...})\n"
"        app.exception_handlers.update({...})\n"
"        app.guards.extend(...)\n"
"        app.middleware.extend(...)\n"
"        app.on_shutdown.extend(...)\n"
"        app.on_startup.extend(...)\n"
"        app.parameters.update({...})\n"
"        app.response_class = ...\n"
"        app.response_cookies.extend(...)\n"
"        app.response_headers.update(...)\n"
"        app.tags.extend(...)"
msgstr ""
