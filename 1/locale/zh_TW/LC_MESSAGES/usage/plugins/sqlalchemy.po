# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/plugins/sqlalchemy.rst:2
msgid "SQLAlchemy Plugin"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:4
msgid ""
"Starlite comes with built-in support for `SQLAlchemy <https://docs."
"sqlalchemy.org/>`_ via the :class:`SQLAlchemyPlugin <starlite.plugins."
"sql_alchemy.SQLAlchemyPlugin>`."
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:8
msgid "Features"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:11
msgid ""
"Managed `sessions <https://docs.sqlalchemy.org/en/14/orm/session.html>`_ "
"(sync and async) including dependency injection"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:12
msgid "Automatic serialization of SQLAlchemy models powered pydantic"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:13
msgid "Data validation based on SQLAlchemy models powered pydantic"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:17
msgid ""
"The following examples use SQLAlchemy's \"2.0 Style\" introduced in "
"SQLAlchemy 1.4."
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:19
msgid ""
"If you are unfamiliar with it, you can find a comprehensive migration guide "
"in SQLAlchemy's documentation `here <https://docs.sqlalchemy.org/en/14/"
"changelog/migration_14.html#what-s-new-in-sqlalchemy-1-4>`_, and `a handy "
"table <https://docs.sqlalchemy.org/en/14/changelog/migration_20."
"html#migration-orm-usage>`_ comparing the ORM usage"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:26
msgid ""
"The :class:`SQLAlchemyPlugin <starlite.plugins.sql_alchemy."
"SQLAlchemyPlugin>` supports only `mapped classes <https://docs.sqlalchemy."
"org/en/14/tutorial/metadata.html#declaring-mapped-classes>`_. `Tables "
"<https://docs.sqlalchemy.org/en/14/tutorial/metadata.html#setting-up-"
"metadata-with-table-objects>`_ are currently not supported since they are "
"not easy to convert to pydantic models."
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:32
msgid "Basic Use"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:34
msgid ""
"You can simply pass an instance of :class:`SQLAlchemyPlugin` without passing "
"config to the Starlite constructor. This will extend support for "
"serialization, deserialization and DTO creation for SQLAlchemy declarative "
"models:"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:0
msgid "Async"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:43
#: ../../../usage/plugins/sqlalchemy.rst:51
msgid "sqlalchemy_plugin.py"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:43
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy import Column, Float, Integer, String, select\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import Mapped, declarative_base\n"
"\n"
"from starlite import DTOFactory, HTTPException, Starlite, get, post\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"Base = declarative_base()\n"
"\n"
"sqlalchemy_config = SQLAlchemyConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"dependency_key=\"async_session\"\n"
")\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"dto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n"
"\n"
"\n"
"class Company(Base):  # pyright: ignore\n"
"    __tablename__ = \"company\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    worth: Mapped[float] = Column(Float)\n"
"\n"
"\n"
"CreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, "
"exclude=[\"id\"])\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    async with sqlalchemy_config.engine.begin() as conn:  # type: ignore\n"
"        await conn.run_sync(Base.metadata.create_all)  # pyright: ignore\n"
"\n"
"\n"
"@post(path=\"/companies\")\n"
"async def create_company(\n"
"    data: CreateCompanyDTO,  # type: ignore[valid-type]\n"
"    async_session: AsyncSession,\n"
") -> Company:\n"
"    \"\"\"Create a new company and return it.\"\"\"\n"
"    company: Company = data.to_model_instance()  # type: ignore[attr-"
"defined]\n"
"    async_session.add(company)\n"
"    await async_session.commit()\n"
"    return company\n"
"\n"
"\n"
"@get(path=\"/companies/{company_id:int}\")\n"
"async def get_company(company_id: int, async_session: AsyncSession) -> "
"Company:\n"
"    \"\"\"Get a company by its ID and return it.\n"
"\n"
"    If a company with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    result = await async_session.scalars(select(Company).where(Company.id == "
"company_id))\n"
"    company: Optional[Company] = result.one_or_none()\n"
"    if not company:\n"
"        raise HTTPException(detail=f\"Company with ID {company_id} not "
"found\", status_code=HTTP_404_NOT_FOUND)\n"
"    return company\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[create_company, get_company],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:43
msgid ""
"from sqlalchemy import Column, Float, Integer, String, select\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import Mapped, declarative_base\n"
"\n"
"from starlite import DTOFactory, HTTPException, Starlite, get, post\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"Base = declarative_base()\n"
"\n"
"sqlalchemy_config = SQLAlchemyConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"dependency_key=\"async_session\"\n"
")\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"dto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n"
"\n"
"\n"
"class Company(Base):  # pyright: ignore\n"
"    __tablename__ = \"company\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    worth: Mapped[float] = Column(Float)\n"
"\n"
"\n"
"CreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, "
"exclude=[\"id\"])\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    async with sqlalchemy_config.engine.begin() as conn:  # type: ignore\n"
"        await conn.run_sync(Base.metadata.create_all)  # pyright: ignore\n"
"\n"
"\n"
"@post(path=\"/companies\")\n"
"async def create_company(\n"
"    data: CreateCompanyDTO,  # type: ignore[valid-type]\n"
"    async_session: AsyncSession,\n"
") -> Company:\n"
"    \"\"\"Create a new company and return it.\"\"\"\n"
"    company: Company = data.to_model_instance()  # type: ignore[attr-"
"defined]\n"
"    async_session.add(company)\n"
"    await async_session.commit()\n"
"    return company\n"
"\n"
"\n"
"@get(path=\"/companies/{company_id:int}\")\n"
"async def get_company(company_id: int, async_session: AsyncSession) -> "
"Company:\n"
"    \"\"\"Get a company by its ID and return it.\n"
"\n"
"    If a company with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    result = await async_session.scalars(select(Company).where(Company.id == "
"company_id))\n"
"    company: Company | None = result.one_or_none()\n"
"    if not company:\n"
"        raise HTTPException(detail=f\"Company with ID {company_id} not "
"found\", status_code=HTTP_404_NOT_FOUND)\n"
"    return company\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[create_company, get_company],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:0
msgid "Sync"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:51
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy import Column, Float, Integer, String, select\n"
"from sqlalchemy.orm import Mapped, Session, declarative_base\n"
"\n"
"from starlite import DTOFactory, HTTPException, Starlite, get, post\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"Base = declarative_base()\n"
"\n"
"sqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+pysqlite:///"
"test.sqlite\", use_async_engine=False)\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"dto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n"
"\n"
"\n"
"class Company(Base):  # pyright: ignore\n"
"    __tablename__ = \"company\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    worth: Mapped[float] = Column(Float)\n"
"\n"
"\n"
"CreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, "
"exclude=[\"id\"])\n"
"\n"
"\n"
"def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    Base.metadata.create_all(sqlalchemy_config.engine)  # type: ignore\n"
"\n"
"\n"
"@post(path=\"/companies\")\n"
"def create_company(\n"
"    data: CreateCompanyDTO,  # type: ignore[valid-type]\n"
"    db_session: Session,\n"
") -> Company:\n"
"    \"\"\"Create a new company and return it.\"\"\"\n"
"    company: Company = data.to_model_instance()  # type: ignore[attr-"
"defined]\n"
"    db_session.add(company)\n"
"    db_session.commit()\n"
"    return company\n"
"\n"
"\n"
"@get(path=\"/companies/{company_id:int}\")\n"
"def get_company(company_id: str, db_session: Session) -> Company:\n"
"    \"\"\"Get a company by its ID and return it.\n"
"\n"
"    If a company with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    company: Optional[Company] = db_session.scalars(select(Company)."
"where(Company.id == company_id)).one_or_none()\n"
"    if not company:\n"
"        raise HTTPException(detail=f\"Company with ID {company_id} not "
"found\", status_code=HTTP_404_NOT_FOUND)\n"
"    return company\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[create_company, get_company],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:51
msgid ""
"from sqlalchemy import Column, Float, Integer, String, select\n"
"from sqlalchemy.orm import Mapped, Session, declarative_base\n"
"\n"
"from starlite import DTOFactory, HTTPException, Starlite, get, post\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"Base = declarative_base()\n"
"\n"
"sqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+pysqlite:///"
"test.sqlite\", use_async_engine=False)\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"dto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n"
"\n"
"\n"
"class Company(Base):  # pyright: ignore\n"
"    __tablename__ = \"company\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    worth: Mapped[float] = Column(Float)\n"
"\n"
"\n"
"CreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, "
"exclude=[\"id\"])\n"
"\n"
"\n"
"def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    Base.metadata.create_all(sqlalchemy_config.engine)  # type: ignore\n"
"\n"
"\n"
"@post(path=\"/companies\")\n"
"def create_company(\n"
"    data: CreateCompanyDTO,  # type: ignore[valid-type]\n"
"    db_session: Session,\n"
") -> Company:\n"
"    \"\"\"Create a new company and return it.\"\"\"\n"
"    company: Company = data.to_model_instance()  # type: ignore[attr-"
"defined]\n"
"    db_session.add(company)\n"
"    db_session.commit()\n"
"    return company\n"
"\n"
"\n"
"@get(path=\"/companies/{company_id:int}\")\n"
"def get_company(company_id: str, db_session: Session) -> Company:\n"
"    \"\"\"Get a company by its ID and return it.\n"
"\n"
"    If a company with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    company: Company | None = db_session.scalars(select(Company)."
"where(Company.id == company_id)).one_or_none()\n"
"    if not company:\n"
"        raise HTTPException(detail=f\"Company with ID {company_id} not "
"found\", status_code=HTTP_404_NOT_FOUND)\n"
"    return company\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[create_company, get_company],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:55
msgid "Using imperative mappings"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:58
msgid ""
"`Imperative mappings <https://docs.sqlalchemy.org/en/14/orm/mapping_styles."
"html#imperative-mapping>`_ are supported as well, just make sure to use a "
"mapped class instead of the table itself"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:62
msgid ""
"company_table = Table(\n"
"    \"company\",\n"
"    Base.registry.metadata,\n"
"    Column(\"id\", Integer, primary_key=True),\n"
"    Column(\"name\", String),\n"
"    Column(\"worth\", Float),\n"
")\n"
"\n"
"\n"
"class Company:\n"
"    pass\n"
"\n"
"\n"
"Base.registry.map_imperatively(Company, company_table)"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:80
msgid "Relationships"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:84
msgid ""
"Currently only to-one relationships are supported because of the way the "
"SQLAlchemy plugin handles relationships. Since it recursively traverses "
"relationships, a cyclic reference will result in an endless loop. To prevent "
"this, these relationships will be type as :class:`typing.Any` in the "
"pydantic model Relationships are typed as :class:`typing.Optional` in the "
"pydantic model by default so sending incomplete models won't cause any "
"issues."
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:92
msgid "Simple relationships"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:94
msgid "Simple relationships can be handled by the plugin automatically:"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:97
msgid "sqlalchemy_relationships.py"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:97
msgid ""
"from typing import Optional\n"
"\n"
"from sqlalchemy import Column, Float, ForeignKey, Integer, String, "
"create_engine, select\n"
"from sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n"
"\n"
"from starlite import HTTPException, Starlite, get\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"engine = create_engine(\"sqlite+pysqlite://\")\n"
"sqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, "
"use_async_engine=False)\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"\n"
"Base = declarative_base()\n"
"\n"
"\n"
"class Company(Base):  # pyright: ignore\n"
"    __tablename__ = \"company\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    worth: Mapped[float] = Column(Float)\n"
"\n"
"\n"
"class User(Base):\n"
"    __tablename__ = \"user\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    company_id: Mapped[int] = Column(Integer, ForeignKey(\"company.id\"))\n"
"    company: Mapped[Company] = relationship(\"Company\", uselist=False)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    Base.metadata.create_all(engine)\n"
"    with Session(engine) as session:\n"
"        peter = User(id=1, name=\"Peter\", company=Company(name=\"Peter Co."
"\", worth=0.0))\n"
"        session.add(peter)\n"
"        session.commit()\n"
"\n"
"\n"
"@get(path=\"/user/{user_id:int}\")\n"
"def get_user(user_id: int, db_session: Session) -> User:\n"
"    \"\"\"Get a user by its ID and return it.\n"
"\n"
"    If a user with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    user: Optional[User] = db_session.scalars(select(User).where(User.id == "
"user_id)).one_or_none()\n"
"    if not user:\n"
"        raise HTTPException(detail=f\"User with ID {user} not found\", "
"status_code=HTTP_404_NOT_FOUND)\n"
"    return user\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[get_user],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:97
msgid ""
"from sqlalchemy import Column, Float, ForeignKey, Integer, String, "
"create_engine, select\n"
"from sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n"
"\n"
"from starlite import HTTPException, Starlite, get\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"engine = create_engine(\"sqlite+pysqlite://\")\n"
"sqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, "
"use_async_engine=False)\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"\n"
"Base = declarative_base()\n"
"\n"
"\n"
"class Company(Base):  # pyright: ignore\n"
"    __tablename__ = \"company\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    worth: Mapped[float] = Column(Float)\n"
"\n"
"\n"
"class User(Base):\n"
"    __tablename__ = \"user\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    company_id: Mapped[int] = Column(Integer, ForeignKey(\"company.id\"))\n"
"    company: Mapped[Company] = relationship(\"Company\", uselist=False)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    Base.metadata.create_all(engine)\n"
"    with Session(engine) as session:\n"
"        peter = User(id=1, name=\"Peter\", company=Company(name=\"Peter Co."
"\", worth=0.0))\n"
"        session.add(peter)\n"
"        session.commit()\n"
"\n"
"\n"
"@get(path=\"/user/{user_id:int}\")\n"
"def get_user(user_id: int, db_session: Session) -> User:\n"
"    \"\"\"Get a user by its ID and return it.\n"
"\n"
"    If a user with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    user: User | None = db_session.scalars(select(User).where(User.id == "
"user_id)).one_or_none()\n"
"    if not user:\n"
"        raise HTTPException(detail=f\"User with ID {user} not found\", "
"status_code=HTTP_404_NOT_FOUND)\n"
"    return user\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[get_user],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:101
#: ../../../usage/plugins/sqlalchemy.rst:132
msgid "Example"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:104
msgid ""
"Run the above with ``uvicorn sqlalchemy_relationships:app``, navigate your "
"browser to `http://127.0.0.0:8000/user/1 <http://127.0.0.0:8000/user/1>`_ "
"and you will see:"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:108
msgid ""
"{\n"
"  \"id\": 1,\n"
"  \"name\": \"Peter\",\n"
"  \"company_id\": 1,\n"
"  \"company\": {\n"
"    \"id\": 1,\n"
"    \"name\": \"Peter Co.\",\n"
"    \"worth\": 0\n"
"  }\n"
"}"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:123
msgid "To-Many relationships and circular references"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:125
msgid ""
"For to-many relationships or those that contain circular references you need "
"to define the pydantic models yourself:"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:128
msgid "sqlalchemy_relationships_to_many"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:128
msgid ""
"from typing import List, Optional\n"
"\n"
"from pydantic import BaseModel\n"
"from sqlalchemy import Column, ForeignKey, Integer, String, create_engine, "
"select\n"
"from sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n"
"\n"
"from starlite import HTTPException, Starlite, get\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"engine = create_engine(\"sqlite+pysqlite:///test.sqlite\")\n"
"sqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, "
"use_async_engine=False)\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"\n"
"Base = declarative_base()\n"
"\n"
"\n"
"class Pet(Base):\n"
"    __tablename__ = \"pet\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    owner: Mapped[\"User\"] = relationship(\"User\", "
"back_populates=\"pets\", uselist=True)\n"
"    owner_id: Mapped[int] = Column(ForeignKey(\"user.id\"))\n"
"\n"
"\n"
"class User(Base):\n"
"    __tablename__ = \"user\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String, default=\"moishe\")\n"
"    pets: Mapped[List[Pet]] = relationship(\"Pet\", uselist=True, "
"back_populates=\"owner\")\n"
"\n"
"\n"
"class PetModel(BaseModel):\n"
"    class Config:\n"
"        orm_mode = True\n"
"\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"class UserModel(BaseModel):\n"
"    class Config:\n"
"        orm_mode = True\n"
"\n"
"    id: int\n"
"    name: str\n"
"    pets: List[PetModel]\n"
"\n"
"\n"
"def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    Base.metadata.create_all(engine)\n"
"    with Session(engine) as session:\n"
"        peter = User(id=1, name=\"Peter\", pets=[Pet(id=1, name=\"Paul\")])\n"
"        session.add(peter)\n"
"        session.commit()\n"
"\n"
"\n"
"@get(path=\"/user/{user_id:int}\")\n"
"def get_user(user_id: int, db_session: Session) -> UserModel:\n"
"    \"\"\"Get a user by its ID and return it.\n"
"\n"
"    If a user with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    user: Optional[User] = db_session.scalars(select(User).where(User.id == "
"user_id)).one_or_none()\n"
"    if not user:\n"
"        raise HTTPException(detail=f\"User with ID {user} not found\", "
"status_code=HTTP_404_NOT_FOUND)\n"
"    return UserModel.from_orm(user)\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[get_user],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:128
msgid ""
"from pydantic import BaseModel\n"
"from sqlalchemy import Column, ForeignKey, Integer, String, create_engine, "
"select\n"
"from sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n"
"\n"
"from starlite import HTTPException, Starlite, get\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"from starlite.status_codes import HTTP_404_NOT_FOUND\n"
"\n"
"engine = create_engine(\"sqlite+pysqlite:///test.sqlite\")\n"
"sqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, "
"use_async_engine=False)\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"\n"
"Base = declarative_base()\n"
"\n"
"\n"
"class Pet(Base):\n"
"    __tablename__ = \"pet\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"    owner: Mapped[\"User\"] = relationship(\"User\", "
"back_populates=\"pets\", uselist=True)\n"
"    owner_id: Mapped[int] = Column(ForeignKey(\"user.id\"))\n"
"\n"
"\n"
"class User(Base):\n"
"    __tablename__ = \"user\"\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String, default=\"moishe\")\n"
"    pets: Mapped[list[Pet]] = relationship(\"Pet\", uselist=True, "
"back_populates=\"owner\")\n"
"\n"
"\n"
"class PetModel(BaseModel):\n"
"    class Config:\n"
"        orm_mode = True\n"
"\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"class UserModel(BaseModel):\n"
"    class Config:\n"
"        orm_mode = True\n"
"\n"
"    id: int\n"
"    name: str\n"
"    pets: list[PetModel]\n"
"\n"
"\n"
"def on_startup() -> None:\n"
"    \"\"\"Initialize the database.\"\"\"\n"
"    Base.metadata.create_all(engine)\n"
"    with Session(engine) as session:\n"
"        peter = User(id=1, name=\"Peter\", pets=[Pet(id=1, name=\"Paul\")])\n"
"        session.add(peter)\n"
"        session.commit()\n"
"\n"
"\n"
"@get(path=\"/user/{user_id:int}\")\n"
"def get_user(user_id: int, db_session: Session) -> UserModel:\n"
"    \"\"\"Get a user by its ID and return it.\n"
"\n"
"    If a user with that ID does not exist, return a 404 response\n"
"    \"\"\"\n"
"    user: User | None = db_session.scalars(select(User).where(User.id == "
"user_id)).one_or_none()\n"
"    if not user:\n"
"        raise HTTPException(detail=f\"User with ID {user} not found\", "
"status_code=HTTP_404_NOT_FOUND)\n"
"    return UserModel.from_orm(user)\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[get_user],\n"
"    on_startup=[on_startup],\n"
"    plugins=[sqlalchemy_plugin],\n"
")"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:135
msgid ""
"Run the above with ``uvicorn sqlalchemy_relationships_to_many:app``, "
"navigate your browser to `http://127.0.0.0:8000/user/1`_ and you will see:"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:138
msgid ""
"{\n"
"  \"id\": 1,\n"
"  \"name\": \"Peter\",\n"
"  \"pets\": [\n"
"    {\n"
"      \"id\": 1,\n"
"      \"name\": \"Paul\"\n"
"    }\n"
"  ]\n"
"}"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:153
msgid "Configuration"
msgstr ""

#: ../../../usage/plugins/sqlalchemy.rst:155
msgid ""
"You can configure the Plugin using the :class:`SQLAlchemyConfig <starlite."
"plugins.sql_alchemy.SQLAlchemyConfig>` object."
msgstr ""
