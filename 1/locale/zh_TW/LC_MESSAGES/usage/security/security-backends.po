# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/security/security-backends.rst:2
msgid "Security Backends"
msgstr ""

#: ../../../usage/security/security-backends.rst:5
msgid "AbstractSecurityConfig"
msgstr ""

#: ../../../usage/security/security-backends.rst:7
msgid ""
":doc:`/reference/security/index` includes an :class:`AbstractSecurityConfig "
"<.security.base.AbstractSecurityConfig>` class that serves as a basis for "
"all the security backends offered by Starlite, and is also meant to be used "
"as a basis for custom security backends created by users."
msgstr ""

#: ../../../usage/security/security-backends.rst:12
msgid "Session Auth Backend"
msgstr ""

#: ../../../usage/security/security-backends.rst:14
msgid ""
"Starlite offers a builtin session auth backend that can be used out of the "
"box with any of the :ref:`session backends <usage/middleware/builtin-"
"middleware:session middleware>` supported by the Starlite session middleware."
msgstr ""

#: ../../../usage/security/security-backends.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/security/security-backends.rst:19
msgid "Using Session Auth"
msgstr ""

#: ../../../usage/security/security-backends.rst:19
msgid ""
"from typing import Any, Dict, Literal, Optional\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr, SecretStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    NotAuthorizedException,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.middleware.session.memory_backend import MemoryBackendConfig\n"
"from starlite.security.session_auth import SessionAuth\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n"
"# a representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# we also have pydantic types for two different\n"
"# kinds of POST request bodies: one for creating\n"
"# a user, e.g. \"sign-up\", and the other for logging\n"
"# an existing user in.\n"
"class UserCreatePayload(BaseModel):\n"
"    name: str\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"class UserLoginPayload(BaseModel):\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"# The SessionAuth class requires a handler callable\n"
"# that takes the session dictionary, and returns the\n"
"# 'User' instance correlating to it.\n"
"#\n"
"# The session dictionary itself is a value the user decides\n"
"# upon. So for example, it might be a simple dictionary\n"
"# that holds a user id, for example: { \"id\": \"abcd123\" }\n"
"#\n"
"# Note: The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(session: Dict[str, Any], connection: "
"ASGIConnection) -> Optional[User]:\n"
"    # we retrieve the user instance based on session data\n"
"    value = await connection.cache.get(session.get(\"user_id\", \"\"))\n"
"    if value:\n"
"        return User(**value)\n"
"    return None\n"
"\n"
"\n"
"@post(\"/login\")\n"
"async def login(data: UserLoginPayload, request: Request) -> User:\n"
"    # we received log-in data via post.\n"
"    # our login handler should retrieve from persistence (a db etc.)\n"
"    # the user data and verify that the login details\n"
"    # are correct. If we are using passwords, we should check that\n"
"    # the password hashes match etc. We will simply assume that we\n"
"    # have done all of that we now have a user value:\n"
"    user_id = await request.cache.get(data.email)\n"
"\n"
"    if not user_id:\n"
"        raise NotAuthorizedException\n"
"\n"
"    user_data = await request.cache.get(user_id)\n"
"\n"
"    # once verified we can create a session.\n"
"    # to do this we simply need to call the Starlite\n"
"    # 'Request.set_session' method, which accepts either dictionaries\n"
"    # or pydantic models. In our case, we can simply record a\n"
"    # simple dictionary with the user ID value:\n"
"    request.set_session({\"user_id\": user_id})\n"
"\n"
"    # you can do whatever we want here. In this case, we will simply return "
"the user data:\n"
"    return User(**user_data)\n"
"\n"
"\n"
"@post(\"/signup\")\n"
"async def signup(data: UserCreatePayload, request: Request) -> User:\n"
"    # this is similar to the login handler, except here we should\n"
"    # insert into persistence - after doing whatever extra\n"
"    # validation we might require. We will assume that this is done,\n"
"    # and we now have a user instance with an assigned ID value:\n"
"    user = User(name=data.name, email=data.email, id=uuid4())\n"
"\n"
"    await request.cache.set(data.email, str(user.id))\n"
"    await request.cache.set(str(user.id), user.dict())\n"
"    # we are creating a session the same as we do in the\n"
"    # 'login_handler' above:\n"
"    request.set_session({\"user_id\": str(user.id)})\n"
"\n"
"    # and again, you can add whatever logic is required here, we\n"
"    # will simply return the user:\n"
"    return user\n"
"\n"
"\n"
"# the endpoint below requires the user to be already authenticated\n"
"# to be able to access it.\n"
"@get(\"/user\")\n"
"def get_user(request: Request[User, Dict[Literal[\"user_id\"], str]]) -> "
"Any:\n"
"    # because this route requires authentication, we can access\n"
"    # `request.user`, which is the authenticated user returned\n"
"    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n"
"    return request.user\n"
"\n"
"\n"
"# We add the session security schema to the OpenAPI config.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"session_auth = SessionAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    # we must pass a config for a session backend.\n"
"    # all session backends are supported\n"
"    session_backend_config=MemoryBackendConfig(),\n"
"    # exclude any URLs that should not have authentication.\n"
"    # We exclude the documentation URLs, signup and login.\n"
"    exclude=[\"/login\", \"/signup\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# We initialize the app instance, passing to it the 'session_auth."
"on_app_init' and the 'openapi_config'.\n"
"app = Starlite(\n"
"    route_handlers=[login, signup, get_user],\n"
"    on_app_init=[session_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/security-backends.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/security/security-backends.rst:19
msgid ""
"from typing import Any, Literal\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr, SecretStr\n"
"\n"
"from starlite import (\n"
"    ASGIConnection,\n"
"    NotAuthorizedException,\n"
"    OpenAPIConfig,\n"
"    Request,\n"
"    Starlite,\n"
"    get,\n"
"    post,\n"
")\n"
"from starlite.middleware.session.memory_backend import MemoryBackendConfig\n"
"from starlite.security.session_auth import SessionAuth\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n"
"# a representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"# we also have pydantic types for two different\n"
"# kinds of POST request bodies: one for creating\n"
"# a user, e.g. \"sign-up\", and the other for logging\n"
"# an existing user in.\n"
"class UserCreatePayload(BaseModel):\n"
"    name: str\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"class UserLoginPayload(BaseModel):\n"
"    email: EmailStr\n"
"    password: SecretStr\n"
"\n"
"\n"
"# The SessionAuth class requires a handler callable\n"
"# that takes the session dictionary, and returns the\n"
"# 'User' instance correlating to it.\n"
"#\n"
"# The session dictionary itself is a value the user decides\n"
"# upon. So for example, it might be a simple dictionary\n"
"# that holds a user id, for example: { \"id\": \"abcd123\" }\n"
"#\n"
"# Note: The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(session: dict[str, Any], connection: "
"ASGIConnection) -> User | None:\n"
"    # we retrieve the user instance based on session data\n"
"    value = await connection.cache.get(session.get(\"user_id\", \"\"))\n"
"    if value:\n"
"        return User(**value)\n"
"    return None\n"
"\n"
"\n"
"@post(\"/login\")\n"
"async def login(data: UserLoginPayload, request: Request) -> User:\n"
"    # we received log-in data via post.\n"
"    # our login handler should retrieve from persistence (a db etc.)\n"
"    # the user data and verify that the login details\n"
"    # are correct. If we are using passwords, we should check that\n"
"    # the password hashes match etc. We will simply assume that we\n"
"    # have done all of that we now have a user value:\n"
"    user_id = await request.cache.get(data.email)\n"
"\n"
"    if not user_id:\n"
"        raise NotAuthorizedException\n"
"\n"
"    user_data = await request.cache.get(user_id)\n"
"\n"
"    # once verified we can create a session.\n"
"    # to do this we simply need to call the Starlite\n"
"    # 'Request.set_session' method, which accepts either dictionaries\n"
"    # or pydantic models. In our case, we can simply record a\n"
"    # simple dictionary with the user ID value:\n"
"    request.set_session({\"user_id\": user_id})\n"
"\n"
"    # you can do whatever we want here. In this case, we will simply return "
"the user data:\n"
"    return User(**user_data)\n"
"\n"
"\n"
"@post(\"/signup\")\n"
"async def signup(data: UserCreatePayload, request: Request) -> User:\n"
"    # this is similar to the login handler, except here we should\n"
"    # insert into persistence - after doing whatever extra\n"
"    # validation we might require. We will assume that this is done,\n"
"    # and we now have a user instance with an assigned ID value:\n"
"    user = User(name=data.name, email=data.email, id=uuid4())\n"
"\n"
"    await request.cache.set(data.email, str(user.id))\n"
"    await request.cache.set(str(user.id), user.dict())\n"
"    # we are creating a session the same as we do in the\n"
"    # 'login_handler' above:\n"
"    request.set_session({\"user_id\": str(user.id)})\n"
"\n"
"    # and again, you can add whatever logic is required here, we\n"
"    # will simply return the user:\n"
"    return user\n"
"\n"
"\n"
"# the endpoint below requires the user to be already authenticated\n"
"# to be able to access it.\n"
"@get(\"/user\")\n"
"def get_user(request: Request[User, dict[Literal[\"user_id\"], str]]) -> "
"Any:\n"
"    # because this route requires authentication, we can access\n"
"    # `request.user`, which is the authenticated user returned\n"
"    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n"
"    return request.user\n"
"\n"
"\n"
"# We add the session security schema to the OpenAPI config.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"session_auth = SessionAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    # we must pass a config for a session backend.\n"
"    # all session backends are supported\n"
"    session_backend_config=MemoryBackendConfig(),\n"
"    # exclude any URLs that should not have authentication.\n"
"    # We exclude the documentation URLs, signup and login.\n"
"    exclude=[\"/login\", \"/signup\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# We initialize the app instance, passing to it the 'session_auth."
"on_app_init' and the 'openapi_config'.\n"
"app = Starlite(\n"
"    route_handlers=[login, signup, get_user],\n"
"    on_app_init=[session_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/security-backends.rst:24
msgid "JWT Auth"
msgstr ""

#: ../../../usage/security/security-backends.rst:26
msgid ""
"Starlite also includes several JWT security backends under the contrib "
"package, checkout the :doc:`jwt contrib documentation </usage/contrib/jwt>` "
"for more details."
msgstr ""
