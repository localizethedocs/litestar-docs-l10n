# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/responses.rst:2
msgid "Responses"
msgstr ""

#: ../../../usage/responses.rst:4
msgid ""
"Starlite allows for several ways in which HTTP responses can be specified "
"and handled, each fitting a different use case. The base pattern though is "
"straightforward - simply return a value from a route handler function and "
"let Starlite take care of the rest:"
msgstr ""

#: ../../../usage/responses.rst:9
msgid ""
"from pydantic import BaseModel\n"
"from starlite import get\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\")\n"
"def retrieve_resource() -> Resource:\n"
"    return Resource(id=1, name=\"my resource\")"
msgstr ""

#: ../../../usage/responses.rst:23
msgid ""
"In the example above, the route handler function returns an instance of the "
"``Resource`` pydantic class. This value will then be used by Starlite to "
"construct an instance of the :class:`Response <starlite.response.Response>` "
"class using defaults values: the response status code will be set to ``200`` "
"and it's ``Content-Type`` header will be set to ``application/json``. The "
"``Resource`` instance will be serialized into JSON and set as the response "
"body."
msgstr ""

#: ../../../usage/responses.rst:31
msgid "Media Type"
msgstr ""

#: ../../../usage/responses.rst:33
msgid ""
"You do not have to specify the ``media_type`` kwarg in the route handler "
"function if the response should be JSON. But if you wish to return a "
"response other than JSON, you should specify this value. You can use the :"
"class:`MediaType <starlite.enums.MediaType>` enum for this purpose:"
msgstr ""

#: ../../../usage/responses.rst:38
msgid ""
"from starlite import MediaType, get\n"
"\n"
"\n"
"@get(\"/resources\", media_type=MediaType.TEXT)\n"
"def retrieve_resource() -> str:\n"
"    return \"The rumbling rabbit ran around the rock\""
msgstr ""

#: ../../../usage/responses.rst:46
msgid ""
"The value of the ``media_type`` kwarg affects both the serialization of "
"response data and the generation of OpenAPI docs. The above example will "
"cause Starlite to serialize the response as a simple bytes string with a "
"``Content-Type`` header value of ``text/plain``. It will also set the "
"corresponding values in the OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:50
msgid "MediaType has the following members:"
msgstr ""

#: ../../../usage/responses.rst:53
msgid "MediaType.JSON: ``application/json``"
msgstr ""

#: ../../../usage/responses.rst:54
msgid "MediaType.MessagePack: ``application/x-msgpack``"
msgstr ""

#: ../../../usage/responses.rst:55
msgid "MediaType.TEXT: ``text/plain``"
msgstr ""

#: ../../../usage/responses.rst:56
msgid "MediaType.HTML: ``text/html``"
msgstr ""

#: ../../../usage/responses.rst:58
msgid ""
"You can also set any `IANA referenced <https://www.iana.org/assignments/"
"media-types/media-types.xhtml>`_ media type string as the ``media_type``. "
"While this will still affect the OpenAPI generation as expected, you might "
"need to handle serialization using either a :ref:`custom response <usage/"
"responses:Custom Responses>` with serializer or by serializing the value in "
"the route handler function."
msgstr ""

#: ../../../usage/responses.rst:64
msgid "JSON responses"
msgstr ""

#: ../../../usage/responses.rst:66
msgid ""
"As previously mentioned, the default ``media_type`` is ``MediaType.JSON``. "
"which supports the following values:"
msgstr ""

#: ../../../usage/responses.rst:68
msgid ":doc:`dataclasses <python:library/dataclasses>`"
msgstr ""

#: ../../../usage/responses.rst:69
msgid "`pydantic dataclasses <https://docs.pydantic.dev/usage/dataclasses/>`_"
msgstr ""

#: ../../../usage/responses.rst:70
msgid "`pydantic models <https://docs.pydantic.dev/usage/models/>`_"
msgstr ""

#: ../../../usage/responses.rst:71
msgid "models from libraries that extend pydantic models"
msgstr ""

#: ../../../usage/responses.rst:72
msgid ":class:`UUIDs <uuid.UUID>`"
msgstr ""

#: ../../../usage/responses.rst:73
msgid ":doc:`datetime objects <python:library/datetime>`"
msgstr ""

#: ../../../usage/responses.rst:74
msgid "`msgspec.Struct <https://jcristharif.com/msgspec/structs.html>`_"
msgstr ""

#: ../../../usage/responses.rst:75
msgid ""
"container types such as :class:`dict` or :class:`list` containing supported "
"types"
msgstr ""

#: ../../../usage/responses.rst:77
msgid ""
"If you need to return other values and would like to extend serialization "
"you can do this :ref:`custom responses <usage/responses:Custom Responses>`."
msgstr ""

#: ../../../usage/responses.rst:81
msgid "MessagePack responses"
msgstr ""

#: ../../../usage/responses.rst:83
msgid ""
"In addition to JSON, Starlite offers support for the `MessagePack <https://"
"msgpack.org/>`_ format which can be a time and space efficient alternative "
"to JSON."
msgstr ""

#: ../../../usage/responses.rst:86
msgid ""
"It supports all the same types as JSON serialization. To send a "
"``MessagePack`` response, simply specify the media type as ``MediaType."
"MESSAGEPACK``\\ :"
msgstr ""

#: ../../../usage/responses.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/responses.rst:90
msgid ""
"from typing import Dict\n"
"from starlite import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.MESSAGEPACK)\n"
"def health_check() -> Dict[str, str]:\n"
"    return {\"hello\": \"world\"}"
msgstr ""

#: ../../../usage/responses.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/responses.rst:90
msgid ""
"from starlite import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.MESSAGEPACK)\n"
"def health_check() -> dict[str, str]:\n"
"    return {\"hello\": \"world\"}"
msgstr ""

#: ../../../usage/responses.rst:100
msgid "Plaintext responses"
msgstr ""

#: ../../../usage/responses.rst:102
msgid ""
"For ``MediaType.TEXT``, route handlers should return a :class:`str` or :"
"class:`bytes` value:"
msgstr ""

#: ../../../usage/responses.rst:105
msgid ""
"from starlite import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT)\n"
"def health_check() -> str:\n"
"    return \"healthy\""
msgstr ""

#: ../../../usage/responses.rst:114
msgid "HTML responses"
msgstr ""

#: ../../../usage/responses.rst:116
msgid ""
"For ``MediaType.HTML``, route handlers should return a :class:`str` or :"
"class:`bytes` value that contains HTML:"
msgstr ""

#: ../../../usage/responses.rst:119
msgid ""
"from starlite import get, MediaType\n"
"\n"
"\n"
"@get(path=\"/page\", media_type=MediaType.HTML)\n"
"def health_check() -> str:\n"
"    return \"\"\"\n"
"    <html>\n"
"        <body>\n"
"            <div>\n"
"                <span>Hello World!</span>\n"
"            </div>\n"
"        </body>\n"
"    </html>\n"
"    \"\"\""
msgstr ""

#: ../../../usage/responses.rst:137
msgid ""
"It's a good idea to use a :ref:`template engine <usage/templating:template "
"engines>` for more complex HTML responses and to write the template itself "
"in a separate file rather than a string."
msgstr ""

#: ../../../usage/responses.rst:142
msgid "Status Codes"
msgstr ""

#: ../../../usage/responses.rst:144
msgid ""
"You can control the response ``status_code`` by setting the corresponding "
"kwarg to the desired value:"
msgstr ""

#: ../../../usage/responses.rst:147
msgid ""
"from pydantic import BaseModel\n"
"from starlite import get\n"
"from starlite.status_codes import HTTP_202_ACCEPTED\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\", status_code=HTTP_202_ACCEPTED)\n"
"def retrieve_resource() -> Resource:\n"
"    return Resource(id=1, name=\"my resource\")"
msgstr ""

#: ../../../usage/responses.rst:162
msgid ""
"If ``status_code`` is not set by the user, the following defaults are used:"
msgstr ""

#: ../../../usage/responses.rst:165
msgid "POST: 201 (Created)"
msgstr ""

#: ../../../usage/responses.rst:166
msgid "DELETE: 204 (No Content)"
msgstr ""

#: ../../../usage/responses.rst:167
msgid "GET, PATCH, PUT: 200 (Ok)"
msgstr ""

#: ../../../usage/responses.rst:171
msgid ""
"For status codes < 100 or 204, 304 statuses, no response body is allowed. If "
"you specify a return annotation other than ``None``, an :class:"
"`ImproperlyConfiguredException <starlite.exceptions."
"ImproperlyConfiguredException>` will be raised."
msgstr ""

#: ../../../usage/responses.rst:176
msgid ""
"When using the ``route`` decorator with multiple http methods, the default "
"status code is ``200``. The default for ``delete`` is ``204`` because by "
"default it is assumed that delete operations return no data. This though "
"might not be the case in your implementation - so take care of setting it as "
"you see fit."
msgstr ""

#: ../../../usage/responses.rst:182
msgid ""
"While you can write integers as the value for ``status_code``, e.g. ``200``, "
"it's best practice to use constants (also in tests). Starlite includes easy "
"to use statuses that are exported from ``starlite.status_codes``, e.g. "
"``HTTP_200_OK`` and ``HTTP_201_CREATED``. Another option is the :class:`http."
"HTTPStatus` enum from the standard library, which also offers extra "
"functionality."
msgstr ""

#: ../../../usage/responses.rst:189
msgid "Returning responses"
msgstr ""

#: ../../../usage/responses.rst:191
msgid ""
"While the default response handling fits most use cases, in some cases you "
"need to be able to return a response instance directly."
msgstr ""

#: ../../../usage/responses.rst:194
msgid ""
"Starlite allows you to return any class inheriting from the :class:`Response "
"<starlite.response.Response>` class. Thus, the below example will work "
"perfectly fine:"
msgstr ""

#: ../../../usage/responses.rst:198
msgid ""
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Starlite, get\n"
"from starlite.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"MY-HEADER\": \"xyz\"},\n"
"        cookies=[Cookie(key=\"my-cookie\", value=\"abc\")],\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:203
msgid ""
"In the case of the builtin :class:`TemplateResponse <starlite.response."
"TemplateResponse>`, :class:`FileResponse <starlite.response.FileResponse>`, :"
"class:`StreamingResponse <starlite.response.StreamingResponse>` and :class:"
"`RedirectResponse <starlite.response.RedirectResponse>` you should use the "
"response \"response containers\", otherwise OpenAPI documentation will not "
"be generated correctly. For more details see the respective documentation "
"sections:"
msgstr ""

#: ../../../usage/responses.rst:208
msgid "`Template responses`_"
msgstr ""

#: ../../../usage/responses.rst:209
msgid "`File responses`_"
msgstr ""

#: ../../../usage/responses.rst:210
msgid "`Streaming responses`_"
msgstr ""

#: ../../../usage/responses.rst:211
msgid "`Redirect responses`_"
msgstr ""

#: ../../../usage/responses.rst:215
msgid "Annotating responses"
msgstr ""

#: ../../../usage/responses.rst:217
msgid ""
"As you can see above, the :class:`Response <starlite.response.Response>` "
"class accepts a generic argument. This allows Starlite to infer the response "
"body when generating the OpenAPI docs."
msgstr ""

#: ../../../usage/responses.rst:222
msgid ""
"If the generic argument is not provided, and thus defaults to ``Any``, the "
"OpenAPI docs will be imprecise. So make sure to type this argument even when "
"returning an empty or ``null`` body, i.e. use ``None``."
msgstr ""

#: ../../../usage/responses.rst:226
msgid "Returning ASGI Applications"
msgstr ""

#: ../../../usage/responses.rst:228
msgid ""
"Starlite also supports returning ASGI applications directly, as you would "
"responses. For example:"
msgstr ""

#: ../../../usage/responses.rst:231
msgid ""
"from starlite import get\n"
"from starlite.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"@get(\"/\")\n"
"def handler() -> ASGIApp:\n"
"    async def my_asgi_app(scope: Scope, receive: Receive, send: Send) -> "
"None: ...\n"
"\n"
"    return my_asgi_app"
msgstr ""

#: ../../../usage/responses.rst:243
msgid "What is an ASGI Application?"
msgstr ""

#: ../../../usage/responses.rst:245
msgid ""
"An ASGI application in this context is any async callable (function, class "
"method or simply a class that implements that special :meth:`__call__` "
"dunder method) that accepts the three ASGI arguments: ``scope``, ``receive`` "
"and ``send``."
msgstr ""

#: ../../../usage/responses.rst:248
msgid "For example, all the following examples are ASGI applications:"
msgstr ""

#: ../../../usage/responses.rst:251
msgid "Function ASGI Application"
msgstr ""

#: ../../../usage/responses.rst:254
msgid ""
"from starlite.types import Receive, Scope, Send\n"
"\n"
"\n"
"async def my_asgi_app_function(scope: Scope, receive: Receive, send: Send) -"
"> None:\n"
"    # do something here\n"
"    ..."
msgstr ""

#: ../../../usage/responses.rst:263
msgid "Method ASGI Application"
msgstr ""

#: ../../../usage/responses.rst:266
msgid ""
"from starlite.types import Receive, Scope, Send\n"
"\n"
"\n"
"class MyClass:\n"
"    async def my_asgi_app_method(\n"
"        self, scope: Scope, receive: Receive, send: Send\n"
"    ) -> None:\n"
"        # do something here\n"
"        ..."
msgstr ""

#: ../../../usage/responses.rst:278
msgid "Class ASGI Application"
msgstr ""

#: ../../../usage/responses.rst:281
msgid ""
"from starlite.types import Receive, Scope, Send\n"
"\n"
"\n"
"class ASGIApp:\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ..."
msgstr ""

#: ../../../usage/responses.rst:291
msgid "Returning other library responses"
msgstr ""

#: ../../../usage/responses.rst:293
msgid ""
"Because you can return any ASGI Application from a route handler, you can "
"also use any ASGI application from other libraries. For example, you can "
"return the response classes from Starlette or FastAPI directly from route "
"handlers:"
msgstr ""

#: ../../../usage/responses.rst:297
msgid ""
"from starlette.responses import JSONResponse\n"
"\n"
"from starlite import get\n"
"from starlite.types import ASGIApp\n"
"\n"
"\n"
"@get(\"/\")\n"
"def handler() -> ASGIApp:\n"
"    return JSONResponse(content={\"hello\": \"world\"})  # type: ignore"
msgstr ""

#: ../../../usage/responses.rst:310
msgid ""
"Starlite offers strong typing for the ASGI arguments. Other libraries often "
"offer less strict typing, which might cause type checkers to complain when "
"using ASGI apps from them inside Starlite. For the time being, the only "
"solution is to add ``# type: ignore`` comments in the pertinent places. "
"Nonetheless, the above example will work perfectly fine."
msgstr ""

#: ../../../usage/responses.rst:317
msgid "Response Headers"
msgstr ""

#: ../../../usage/responses.rst:319
msgid ""
"Starlite allows you to define response headers by using the "
"``response_headers`` kwarg. This kwarg is available on all layers of the app "
"- individual route handlers, controllers, routers and the app itself:"
msgstr ""

#: ../../../usage/responses.rst:324
msgid ""
"from starlite import Controller, MediaType, Router, Starlite, get\n"
"from starlite.datastructures import ResponseHeader\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller-path\"\n"
"    response_headers = {\n"
"        \"controller-level-header\": ResponseHeader(value=\"controller "
"header\", description=\"controller level header\")\n"
"    }\n"
"\n"
"    @get(\n"
"        path=\"/handler-path\",\n"
"        response_headers={\"my-local-header\": ResponseHeader(value=\"local "
"header\", description=\"local level header\")},\n"
"        media_type=MediaType.TEXT,\n"
"    )\n"
"    def my_route_handler(self) -> str:\n"
"        return \"hello world\"\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[MyController],\n"
"    response_headers={\"router-level-header\": ResponseHeader(value=\"router "
"header\", description=\"router level header\")},\n"
")\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[router],\n"
"    response_headers={\"app-level-header\": ResponseHeader(value=\"app "
"header\", description=\"app level header\")},\n"
")"
msgstr ""

#: ../../../usage/responses.rst:327
msgid ""
"In the above example the response returned from ``my_route_handler`` will "
"have headers set from each layer of the application using the given "
"key+value combinations. I.e. it will be a dictionary equal to this:"
msgstr ""

#: ../../../usage/responses.rst:330
msgid ""
"{\n"
"  \"my-local-header\": \"local header\",\n"
"  \"controller-level-header\": \"controller header\",\n"
"  \"router-level-header\": \"router header\",\n"
"  \"app-level-header\": \"app header\"\n"
"}"
msgstr ""

#: ../../../usage/responses.rst:339
msgid "The respective descriptions will be used for the OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:342
msgid "Dynamic Headers"
msgstr ""

#: ../../../usage/responses.rst:344
msgid ""
"The above detailed scheme works great for statically configured headers, but "
"how would you go about handling dynamically setting headers? Starlite allows "
"you to set headers dynamically in several ways and below we will detail the "
"two primary patterns."
msgstr ""

#: ../../../usage/responses.rst:349
msgid "Setting Response Headers Using Annotated Responses"
msgstr ""

#: ../../../usage/responses.rst:351
msgid ""
"We can simply return a response instance directly from the route handler and "
"set the headers dictionary manually as you see fit, e.g.:"
msgstr ""

#: ../../../usage/responses.rst:355
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Starlite, get\n"
"from starlite.datastructures import ResponseHeader\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_headers={\n"
"        \"Random-Header\": ResponseHeader(description=\"a random number in "
"the range 1 - 100\", documentation_only=True)\n"
"    },\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"Random-Header\": str(randint(1, 100))},\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:358
msgid ""
"In the above we use the ``response_headers`` kwarg to pass the ``name`` and "
"``description`` parameters for the ``Random-Header`` to the OpenAPI "
"documentation, but we set the value dynamically in as part of the :ref:"
"`annotated response <usage/responses:annotating responses>` we return. To "
"this end we do not set a ``value`` for it and we designate it as "
"``documentation_only=True``."
msgstr ""

#: ../../../usage/responses.rst:364
msgid "Setting Response Headers Using the After Request Hook"
msgstr ""

#: ../../../usage/responses.rst:366
msgid ""
"An alternative pattern would be to use an :ref:`after request handler "
"<after_request>`. We can define the handler on different layers of the "
"application as explained in the pertinent docs. We should take care to "
"document the headers on the corresponding layer:"
msgstr ""

#: ../../../usage/responses.rst:371
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Router, Starlite, get\n"
"from starlite.datastructures import ResponseHeader\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_headers={\n"
"        \"Random-Header\": ResponseHeader(\n"
"            description=\"a random number in the range 100 - 1000\",\n"
"            documentation_only=True,\n"
"        )\n"
"    },\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"Random-Header\": str(randint(100, 1000))},\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.headers.update({\"Random-Header\": str(randint(1, 100))})\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_headers={\n"
"        \"Random-Header\": ResponseHeader(\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    },\n"
")\n"
"\n"
"\n"
"app = Starlite(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:374
msgid ""
"In the above we set the response header using an ``after_request_handler`` "
"function on the router level. Because the handler function is applied on the "
"router, we also set the documentation for it on the router."
msgstr ""

#: ../../../usage/responses.rst:377
msgid ""
"We can use this pattern to fine-tune the OpenAPI documentation more "
"granularly by overriding header specification as required. For example, lets "
"say we have a router level header being set and a local header with the same "
"key but a different value range:"
msgstr ""

#: ../../../usage/responses.rst:382
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Router, Starlite, get\n"
"from starlite.datastructures import ResponseHeader\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_headers={\n"
"        \"Random-Header\": ResponseHeader(\n"
"            description=\"a random number in the range 100 - 1000\",\n"
"            documentation_only=True,\n"
"        )\n"
"    },\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        headers={\"Random-Header\": str(randint(100, 1000))},\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.headers.update({\"Random-Header\": str(randint(1, 100))})\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_headers={\n"
"        \"Random-Header\": ResponseHeader(description=\"a random number in "
"the range 1 - 100\", documentation_only=True)\n"
"    },\n"
")\n"
"\n"
"app = Starlite(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:386
msgid "Specific Headers Implementation"
msgstr ""

#: ../../../usage/responses.rst:388
msgid ""
"Starlite has a dedicated implementation for a few headers that are commonly "
"used. These headers can be set separately with dedicated keyword arguments "
"or as class attributes on all layers of the app (individual route handlers, "
"controllers, routers and the app itself). Each layer overrides the layer "
"above it - thus, the headers defined for a specific route handler will "
"override those defined on its router, which will in turn override those "
"defined on the app level."
msgstr ""

#: ../../../usage/responses.rst:393
msgid ""
"These header implementations allow easy creating, serialization and parsing "
"according to the associated header specifications."
msgstr ""

#: ../../../usage/responses.rst:397
msgid "Cache Control"
msgstr ""

#: ../../../usage/responses.rst:399
msgid ""
":class:`CacheControlHeader <starlite.datastructures.headers."
"CacheControlHeader>` represents a `Cache-Control Header <https://developer."
"mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control>`_."
msgstr ""

#: ../../../usage/responses.rst:402
msgid "Here is a simple example that shows how to use it:"
msgstr ""

#: ../../../usage/responses.rst:405
msgid "Cache Control Header"
msgstr ""

#: ../../../usage/responses.rst:405
msgid ""
"import time\n"
"\n"
"from starlite import Controller, Starlite, get\n"
"from starlite.datastructures import CacheControlHeader\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    cache_control = CacheControlHeader(max_age=86_400, public=True)\n"
"\n"
"    @get(\"/chance_of_rain\")\n"
"    def get_chance_of_rain(self) -> float:\n"
"        \"\"\"This endpoint uses the cache control value defined in the "
"controller which overrides the app value.\"\"\"\n"
"        return 0.5\n"
"\n"
"    @get(\"/timestamp\", cache_control=CacheControlHeader(no_store=True))\n"
"    def get_server_time(self) -> float:\n"
"        \"\"\"This endpoint overrides the cache control value defined in the "
"controller.\"\"\"\n"
"        return time.time()\n"
"\n"
"\n"
"@get(\"/population\")\n"
"def get_population_count() -> int:\n"
"    \"\"\"This endpoint will use the cache control defined in the app."
"\"\"\"\n"
"    return 100000\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[MyController, get_population_count],\n"
"    cache_control=CacheControlHeader(max_age=2_628_288, public=True),\n"
")"
msgstr ""

#: ../../../usage/responses.rst:409
msgid ""
"In this example we have a ``cache-control`` with ``max-age`` of 1 month for "
"the whole app, a ``max-age`` of 1 day for all routes within ``MyController`` "
"and ``no-store`` for one specific route ``get_server_time``. Here are the "
"cache control values that will be returned from each endpoint:"
msgstr ""

#: ../../../usage/responses.rst:414
msgid ""
"When calling ``/population`` the response will have ``cache-control`` with "
"``max-age=2628288`` (1 month)."
msgstr ""

#: ../../../usage/responses.rst:415
msgid ""
"When calling ``/chance_of_rain`` the response will have ``cache-control`` "
"with ``max-age=86400`` (1 day)."
msgstr ""

#: ../../../usage/responses.rst:416
msgid ""
"When calling ``/timestamp`` the response will have ``cache-control`` with "
"``no-store`` which means don't store the result in any cache."
msgstr ""

#: ../../../usage/responses.rst:420
msgid "ETag"
msgstr ""

#: ../../../usage/responses.rst:422
msgid ""
":class:`ETag <.datastructures.headers.ETag>` represents an `ETag header "
"<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag>`_."
msgstr ""

#: ../../../usage/responses.rst:425
msgid "Here are some usage examples:"
msgstr ""

#: ../../../usage/responses.rst:428
msgid "Returning ETag headers"
msgstr ""

#: ../../../usage/responses.rst:428
msgid ""
"import random\n"
"import time\n"
"\n"
"from starlite import Controller, Starlite, get\n"
"from starlite.datastructures import ETag\n"
"from starlite.enums import MediaType\n"
"from starlite.response import Response\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    etag = ETag(value=\"foo\")\n"
"\n"
"    @get(\"/chance_of_rain\")\n"
"    def get_chance_of_rain(self) -> float:\n"
"        \"\"\"This endpoint uses the etag value in the controller which "
"overrides the app value.\n"
"\n"
"        The returned header will be `etag: \"foo\"`\n"
"        \"\"\"\n"
"        return 0.5\n"
"\n"
"    @get(\"/timestamp\", etag=ETag(value=\"bar\"))\n"
"    def get_server_time(self) -> float:\n"
"        \"\"\"This endpoint overrides the etag defined in the controller.\n"
"\n"
"        The returned header will be `etag: W/\"bar\"`\n"
"        \"\"\"\n"
"        return time.time()\n"
"\n"
"\n"
"@get(\"/population\")\n"
"def get_population_count() -> int:\n"
"    \"\"\"This endpoint will use the etag defined in the app.\n"
"\n"
"    The returned header will be `etag: \"bar\"`\n"
"    \"\"\"\n"
"    return 100000\n"
"\n"
"\n"
"@get(\"/population-dynamic\", etag=ETag(documentation_only=True))\n"
"def get_population_count_dynamic() -> Response[str]:\n"
"    \"\"\"The etag defined in this route handler will not be returned, and "
"does not need a value.\n"
"\n"
"    It will only be used for OpenAPI generation.\n"
"    \"\"\"\n"
"    population_count = random.randint(0, 1000)\n"
"    return Response(\n"
"        content=str(population_count),\n"
"        headers={\"etag\": ETag(value=str(population_count))},\n"
"        media_type=MediaType.TEXT,\n"
"        status_code=200,\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[MyController, get_population_count], "
"etag=ETag(value=\"bar\"))"
msgstr ""

#: ../../../usage/responses.rst:433
msgid "Parsing ETag headers"
msgstr ""

#: ../../../usage/responses.rst:433
msgid ""
"from starlite.datastructures import ETag\n"
"\n"
"assert ETag.from_header('\"foo\"') == ETag(value=\"foo\")\n"
"assert ETag.from_header('W/\"foo\"') == ETag(value=\"foo\", weak=True)"
msgstr ""

#: ../../../usage/responses.rst:438
msgid "Response Cookies"
msgstr ""

#: ../../../usage/responses.rst:440
msgid ""
"Starlite allows you to define response cookies by using the "
"``response_cookies`` kwarg. This kwarg is available on all layers of the app "
"- individual route handlers, controllers, routers and the app itself:"
msgstr ""

#: ../../../usage/responses.rst:445
msgid ""
"from starlite import Controller, MediaType, Router, Starlite, get\n"
"from starlite.datastructures import Cookie\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller-path\"\n"
"    response_cookies = [\n"
"        Cookie(\n"
"            key=\"controller-cookie\",\n"
"            value=\"controller value\",\n"
"            description=\"controller level cookie\",\n"
"        )\n"
"    ]\n"
"\n"
"    @get(\n"
"        path=\"/\",\n"
"        response_cookies=[\n"
"            Cookie(\n"
"                key=\"local-cookie\",\n"
"                value=\"local value\",\n"
"                description=\"route handler level cookie\",\n"
"            )\n"
"        ],\n"
"        media_type=MediaType.TEXT,\n"
"    )\n"
"    def my_route_handler(self) -> str:\n"
"        return \"hello world\"\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[MyController],\n"
"    response_cookies=[Cookie(key=\"router-cookie\", value=\"router value\", "
"description=\"router level cookie\")],\n"
")\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[router],\n"
"    response_cookies=[Cookie(key=\"app-cookie\", value=\"app value\", "
"description=\"app level cookie\")],\n"
")"
msgstr ""

#: ../../../usage/responses.rst:448
msgid ""
"In the above example, the response returned by ``my_route_handler`` will "
"have cookies set by each layer of the application. Cookies are set using the "
"`Set-Cookie header <https://developer.mozilla.org/en-US/docs/Web/HTTP/"
"Headers/Set-Cookie>`_ and with above resulting in:"
msgstr ""

#: ../../../usage/responses.rst:453
msgid ""
"Set-Cookie: local-cookie=local value; Path=/; SameSite=lax\n"
"Set-Cookie: controller-cookie=controller value; Path=/; SameSite=lax\n"
"Set-Cookie: router-cookie=router value; Path=/; SameSite=lax\n"
"Set-Cookie: app-cookie=app value; Path=/; SameSite=lax"
msgstr ""

#: ../../../usage/responses.rst:460
msgid ""
"You can easily override cookies declared in higher levels by re-declaring a "
"cookie with the same key in a lower level, e.g.:"
msgstr ""

#: ../../../usage/responses.rst:464
msgid ""
"from starlite import Controller, MediaType, Starlite, get\n"
"from starlite.datastructures import Cookie\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller-path\"\n"
"    response_cookies = [Cookie(key=\"my-cookie\", value=\"123\")]\n"
"\n"
"    @get(\n"
"        path=\"/\",\n"
"        response_cookies=[Cookie(key=\"my-cookie\", value=\"456\")],\n"
"        media_type=MediaType.TEXT,\n"
"    )\n"
"    def my_route_handler(self) -> str:\n"
"        return \"hello world\"\n"
"\n"
"\n"
"app = Starlite(route_handlers=[MyController])"
msgstr ""

#: ../../../usage/responses.rst:467
msgid ""
"Of the two declarations of ``my-cookie`` only the route handler one will be "
"used, because its lower level:"
msgstr ""

#: ../../../usage/responses.rst:469
msgid "Set-Cookie: my-cookie=456; Path=/; SameSite=lax"
msgstr ""

#: ../../../usage/responses.rst:475
msgid ":class:`Cookie reference <starlite.datastructures.cookie.Cookie>`"
msgstr ""

#: ../../../usage/responses.rst:479
msgid "Dynamic Cookies"
msgstr ""

#: ../../../usage/responses.rst:481
msgid ""
"While the above scheme works great for static cookie values, it doesn't "
"allow for dynamic cookies. Because cookies are fundamentally a type of "
"response header, we can utilize the same patterns we use for setting :ref:"
"`dynamic headers <usage/responses:dynamic headers>` also here."
msgstr ""

#: ../../../usage/responses.rst:486
msgid "Setting Response Cookies Using Annotated Responses"
msgstr ""

#: ../../../usage/responses.rst:488
msgid ""
"We can simply return a response instance directly from the route handler and "
"set the cookies list manually as you see fit, e.g.:"
msgstr ""

#: ../../../usage/responses.rst:492
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Starlite, get\n"
"from starlite.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        cookies=[Cookie(key=\"Random-Cookie\", value=str(randint(1, "
"100)))],\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[retrieve_resource])"
msgstr ""

#: ../../../usage/responses.rst:495
msgid ""
"In the above we use the ``response_cookies`` kwarg to pass the ``key`` and "
"``description`` parameters for the ``Random-Header`` to the OpenAPI "
"documentation, but we set the value dynamically in as part of the :ref:"
"`annotated response <usage/responses:annotating responses>` we return. To "
"this end we do not set a ``value`` for it and we designate it as "
"``documentation_only=True``."
msgstr ""

#: ../../../usage/responses.rst:501
msgid "Setting Response Cookies Using the After Request Hook"
msgstr ""

#: ../../../usage/responses.rst:503
msgid ""
"An alternative pattern would be to use an :ref:`after request handler "
"<after_request>`. We can define the handler on different layers of the "
"application as explained in the pertinent docs. We should take care to "
"document the cookies on the corresponding layer:"
msgstr ""

#: ../../../usage/responses.rst:508
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Router, Starlite, get\n"
"from starlite.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\"/resources\")\n"
"def retrieve_resource() -> Resource:\n"
"    return Resource(\n"
"        id=1,\n"
"        name=\"my resource\",\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.set_cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"\n"
"app = Starlite(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:511
msgid ""
"In the above we set the cookie using an ``after_request_handler`` function "
"on the router level. Because the handler function is applied on the router, "
"we also set the documentation for it on the router."
msgstr ""

#: ../../../usage/responses.rst:514
msgid ""
"We can use this pattern to fine-tune the OpenAPI documentation more granular "
"by overriding cookie specification as required. For example, lets say we "
"have a router level cookie being set and a local cookie with the same key "
"but a different value range:"
msgstr ""

#: ../../../usage/responses.rst:519
msgid ""
"from random import randint\n"
"\n"
"from pydantic import BaseModel\n"
"\n"
"from starlite import Response, Router, Starlite, get\n"
"from starlite.datastructures import Cookie\n"
"\n"
"\n"
"class Resource(BaseModel):\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@get(\n"
"    \"/resources\",\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 100 - 1000\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"def retrieve_resource() -> Response[Resource]:\n"
"    return Response(\n"
"        Resource(\n"
"            id=1,\n"
"            name=\"my resource\",\n"
"        ),\n"
"        cookies=[Cookie(key=\"Random-Cookie\", value=str(randint(100, "
"1000)))],\n"
"    )\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    response.set_cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))\n"
"    return response\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router-path\",\n"
"    route_handlers=[retrieve_resource],\n"
"    after_request=after_request_handler,\n"
"    response_cookies=[\n"
"        Cookie(\n"
"            key=\"Random-Cookie\",\n"
"            description=\"a random number in the range 1 - 100\",\n"
"            documentation_only=True,\n"
"        )\n"
"    ],\n"
")\n"
"\n"
"app = Starlite(route_handlers=[router])"
msgstr ""

#: ../../../usage/responses.rst:523
msgid "Redirect Responses"
msgstr ""

#: ../../../usage/responses.rst:525
msgid ""
"Redirect responses are `special HTTP responses <https://developer.mozilla."
"org/en-US/docs/Web/HTTP/Redirections>`_ with a status code in the 30x range."
msgstr ""

#: ../../../usage/responses.rst:528
msgid "In Starlite, a redirect response looks like this:"
msgstr ""

#: ../../../usage/responses.rst:531
msgid ""
"from starlite.status_codes import HTTP_307_TEMPORARY_REDIRECT\n"
"from starlite import Redirect, get\n"
"\n"
"\n"
"@get(path=\"/some-path\", status_code=HTTP_307_TEMPORARY_REDIRECT)\n"
"def redirect() -> Redirect:\n"
"    # do some stuff here\n"
"    # ...\n"
"    # finally return redirect\n"
"    return Redirect(path=\"/other-path\")"
msgstr ""

#: ../../../usage/responses.rst:543
msgid "To return a redirect response you should do the following:"
msgstr ""

#: ../../../usage/responses.rst:546
msgid ""
"set an appropriate status code for the route handler (301, 302, 303, 307, "
"308)"
msgstr ""

#: ../../../usage/responses.rst:547
msgid ""
"annotate the return value of the route handler as returning ``Redirect``"
msgstr ""

#: ../../../usage/responses.rst:548
msgid ""
"return an instance of the ``Redirect`` class with the desired redirect path"
msgstr ""

#: ../../../usage/responses.rst:551
msgid "The Redirect Class"
msgstr ""

#: ../../../usage/responses.rst:553
msgid ""
"``Redirect`` is a container class used to generate redirect responses and "
"their respective OpenAPI documentation. See the :class:`API Reference "
"<starlite.datastructures.Redirect>` for full details on the ``Redirect`` "
"class and the kwargs it accepts."
msgstr ""

#: ../../../usage/responses.rst:559
msgid "File Responses"
msgstr ""

#: ../../../usage/responses.rst:561
msgid "File responses send a file:"
msgstr ""

#: ../../../usage/responses.rst:564
msgid ""
"from pathlib import Path\n"
"from starlite import File, get\n"
"\n"
"\n"
"@get(path=\"/file-download\")\n"
"def handle_file_download() -> File:\n"
"    return File(\n"
"        path=Path(Path(__file__).resolve().parent, \"report\")."
"with_suffix(\".pdf\"),\n"
"        filename=\"repost.pdf\",\n"
"    )"
msgstr ""

#: ../../../usage/responses.rst:576
msgid ""
"The :class:`File <starlite.datastructures.file.File>` class expects two "
"kwargs:"
msgstr ""

#: ../../../usage/responses.rst:579
msgid "``path``: path of the file to download."
msgstr ""

#: ../../../usage/responses.rst:580
msgid ""
"``filename``: the filename to set in the response `Content-Disposition "
"<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-"
"Disposition>`_ attachment."
msgstr ""

#: ../../../usage/responses.rst:586
msgid ""
"When a route handler's return value is annotated with :class:`File <."
"starlite.datastructure.file.File>`, the default ``media_type`` for the "
"route_handler is switched from :class:`MediaType.JSON <.enums.MediaType>` "
"to :class:`MediaType.TEXT <.enums.MediaType>` (i.e. ``\"text/plain\"``). If "
"the file being sent has an `IANA media type <https://developer.mozilla.org/"
"en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types>`_, you should set it as the "
"value for ``media_type`` instead."
msgstr ""

#: ../../../usage/responses.rst:592
msgid "For example:"
msgstr ""

#: ../../../usage/responses.rst:595
msgid ""
"from pathlib import Path\n"
"from starlite import File, get\n"
"\n"
"\n"
"@get(path=\"/file-download\", media_type=\"application/pdf\")\n"
"def handle_file_download() -> File:\n"
"    return File(\n"
"        path=Path(Path(__file__).resolve().parent, \"report\")."
"with_suffix(\".pdf\"),\n"
"        filename=\"repost.pdf\",\n"
"    )"
msgstr ""

#: ../../../usage/responses.rst:609
msgid "Streaming Responses"
msgstr ""

#: ../../../usage/responses.rst:611
msgid ""
"To return a streaming response use the :class:`Stream <starlite."
"datastructures.Stream>` class. The Stream class receives a single required "
"kwarg - ``iterator``:"
msgstr ""

#: ../../../usage/responses.rst:615
msgid ""
"from asyncio import sleep\n"
"from datetime import datetime\n"
"from typing import AsyncGenerator\n"
"\n"
"from starlite import Starlite, Stream, get\n"
"from starlite.utils.serialization import encode_json\n"
"\n"
"\n"
"async def my_generator() -> AsyncGenerator[bytes, None]:\n"
"    while True:\n"
"        await sleep(0.01)\n"
"        yield encode_json({\"current_time\": datetime.now()})\n"
"\n"
"\n"
"@get(path=\"/time\")\n"
"def stream_time() -> Stream:\n"
"    return Stream(iterator=my_generator())\n"
"\n"
"\n"
"app = Starlite(route_handlers=[stream_time])"
msgstr ""

#: ../../../usage/responses.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/responses.rst:615
msgid ""
"from asyncio import sleep\n"
"from datetime import datetime\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from starlite import Starlite, Stream, get\n"
"from starlite.utils.serialization import encode_json\n"
"\n"
"\n"
"async def my_generator() -> AsyncGenerator[bytes, None]:\n"
"    while True:\n"
"        await sleep(0.01)\n"
"        yield encode_json({\"current_time\": datetime.now()})\n"
"\n"
"\n"
"@get(path=\"/time\")\n"
"def stream_time() -> Stream:\n"
"    return Stream(iterator=my_generator())\n"
"\n"
"\n"
"app = Starlite(route_handlers=[stream_time])"
msgstr ""

#: ../../../usage/responses.rst:620
msgid ""
"You can use different kinds of values of the `iterator` keyword - it can be "
"a callable returning a sync or async generator. The generator itself. A sync "
"or async iterator class, or and instance of this class."
msgstr ""

#: ../../../usage/responses.rst:626
msgid "Template Responses"
msgstr ""

#: ../../../usage/responses.rst:628
msgid ""
"Template responses are used to render templates into HTML. To use a template "
"response you must first :ref:`register a template engine <usage/templating:"
"registering a template engine>` on the application level. Once an engine is "
"in place, you can use a template response like so:"
msgstr ""

#: ../../../usage/responses.rst:633
msgid ""
"from starlite import Template, Request, get\n"
"\n"
"\n"
"@get(path=\"/info\")\n"
"def info(request: Request) -> Template:\n"
"    return Template(name=\"info.html\", context={\"user\": request.user})"
msgstr ""

#: ../../../usage/responses.rst:641
msgid ""
"In the above :class:`API Reference <starlite.datastructures.Template>` is "
"passed the template name, which is a path like value, and a context "
"dictionary that maps string keys into values that will be rendered in the "
"template."
msgstr ""

#: ../../../usage/responses.rst:647
msgid "Custom Responses"
msgstr ""

#: ../../../usage/responses.rst:649
msgid ""
"While Starlite supports the serialization of many types by default, "
"sometimes you want to return something that's not supported. In those cases "
"it's convenient to make use of a custom response class."
msgstr ""

#: ../../../usage/responses.rst:653
msgid ""
"The example below illustrates how to deal with :class:`MultiDict <."
"datastructures.MultiDict>` instances."
msgstr ""

#: ../../../usage/responses.rst:657
msgid ""
"from starlite import Response, Starlite, get\n"
"from starlite.datastructures import MultiDict\n"
"\n"
"\n"
"class MultiDictResponse(Response):\n"
"    type_encoders = {MultiDict: lambda d: d.dict()}\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def index() -> MultiDict:\n"
"    return MultiDict([(\"foo\", \"bar\"), (\"foo\", \"baz\")])\n"
"\n"
"\n"
"app = Starlite([index], response_class=MultiDictResponse)\n"
"\n"
"\n"
"# run: /"
msgstr ""

#: ../../../usage/responses.rst:660
msgid "Layered architecture  :class: seealso"
msgstr ""

#: ../../../usage/responses.rst:664
msgid ""
"Response classes are part of Starlite's layered architecture, which means "
"you can set a response class on every layer of the application. If you have "
"set a response class on multiple layers, the layer closes to the route "
"handler will take precedence."
msgstr ""

#: ../../../usage/responses.rst:668
msgid ""
"You can read more about this here: :ref:`usage/the-starlite-app:layered "
"architecture`"
msgstr ""

#: ../../../usage/responses.rst:673
msgid "Background Tasks"
msgstr ""

#: ../../../usage/responses.rst:675
msgid ""
"All Starlite responses and response containers (e.g. ``File``, ``Template``, "
"etc.) allow passing in a ``background`` kwarg. This kwarg accepts either an "
"instance of :class:`BackgroundTask <.datastructures.background_tasks."
"BackgroundTask>` or an instance of :class:`BackgroundTasks <.datastructures."
"background_tasks.BackgroundTasks>`, which wraps an iterable of :class:"
"`BackgroundTask <.datastructures.background_tasks.BackgroundTask>` instances."
msgstr ""

#: ../../../usage/responses.rst:680
msgid ""
"A background task is a sync or async callable (function, method or class "
"that implements the :meth:`__call__` dunder method) that will be called "
"after the response finishes sending the data."
msgstr ""

#: ../../../usage/responses.rst:683
msgid ""
"Thus, in the following example the passed in background task will be "
"executed after the response sends:"
msgstr ""

#: ../../../usage/responses.rst:686
msgid "Background Task Passed into Response"
msgstr ""

#: ../../../usage/responses.rst:686
msgid ""
"import logging\n"
"from typing import Dict\n"
"\n"
"from starlite import BackgroundTask, Response, Starlite, get\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\")\n"
"def greeter(name: str) -> Response[Dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTask(logging_task, \"greeter\", message=f\"was "
"called with name {name}\"),\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:686
msgid ""
"import logging\n"
"\n"
"from starlite import BackgroundTask, Response, Starlite, get\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\")\n"
"def greeter(name: str) -> Response[dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTask(logging_task, \"greeter\", message=f\"was "
"called with name {name}\"),\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:690
msgid ""
"When the ``greeter`` handler is called, the logging task will be called with "
"any ``*args`` and ``**kwargs`` passed into the :class:`BackgroundTask <."
"datastructures.background_tasks.BackgroundTask>`."
msgstr ""

#: ../../../usage/responses.rst:695
msgid ""
"In the above example ``\"greeter\"`` is an arg and ``message=f\"was called "
"with name {name}\"`` is a kwarg. The function signature of ``logging_task`` "
"allows for this, so this should pose no problem. :class:`BackgroundTask "
"<starlite.datastructures.background_tasks.BackgroundTask>` is typed with :"
"class:`ParamSpec <typing.ParamSpec>`, enabling correct type checking for "
"arguments and keyword arguments passed to it."
msgstr ""

#: ../../../usage/responses.rst:700
msgid ""
"Route decorators (e.g. ``@get``, ``@post``, etc.) also allow passing in a "
"background task with the ``background`` kwarg:"
msgstr ""

#: ../../../usage/responses.rst:703
msgid "Background Task Passed into Decorator"
msgstr ""

#: ../../../usage/responses.rst:703
msgid ""
"import logging\n"
"from typing import Dict\n"
"\n"
"from starlite import BackgroundTask, Starlite, get\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\", background=BackgroundTask(logging_task, \"greeter\", "
"message=\"was called\"))\n"
"def greeter() -> Dict[str, str]:\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:703
msgid ""
"import logging\n"
"\n"
"from starlite import BackgroundTask, Starlite, get\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"async def logging_task(identifier: str, message: str) -> None:\n"
"    logger.info(\"%s: %s\", identifier, message)\n"
"\n"
"\n"
"@get(\"/\", background=BackgroundTask(logging_task, \"greeter\", "
"message=\"was called\"))\n"
"def greeter() -> dict[str, str]:\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Starlite(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:709
msgid ""
"Route handler arguments cannot be passed into background tasks when they are "
"passed into decorators."
msgstr ""

#: ../../../usage/responses.rst:713
msgid "Executing Multiple Background Tasks"
msgstr ""

#: ../../../usage/responses.rst:715
msgid ""
"You can also use the :class:`BackgroundTasks <starlite.datastructures."
"background_tasks.BackgroundTasks>` class and pass to it an iterable (:class:"
"`list`, :class:`tuple`, etc.) of :class:`BackgroundTask <starlite."
"datastructures.background_tasks.BackgroundTask>` instances:"
msgstr ""

#: ../../../usage/responses.rst:720
msgid "Multiple Background Tasks"
msgstr ""

#: ../../../usage/responses.rst:720
msgid ""
"import logging\n"
"from typing import Dict\n"
"\n"
"from starlite import BackgroundTask, BackgroundTasks, Response, Starlite, "
"get\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"greeted = set()\n"
"\n"
"\n"
"async def logging_task(name: str) -> None:\n"
"    logger.info(\"%s was greeted\", name)\n"
"\n"
"\n"
"async def saving_task(name: str) -> None:\n"
"    greeted.add(name)\n"
"\n"
"\n"
"@get(\"/\")\n"
"def greeter(name: str) -> Response[Dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTasks(\n"
"            [\n"
"                BackgroundTask(logging_task, name),\n"
"                BackgroundTask(saving_task, name),\n"
"            ]\n"
"        ),\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:720
msgid ""
"import logging\n"
"\n"
"from starlite import BackgroundTask, BackgroundTasks, Response, Starlite, "
"get\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"greeted = set()\n"
"\n"
"\n"
"async def logging_task(name: str) -> None:\n"
"    logger.info(\"%s was greeted\", name)\n"
"\n"
"\n"
"async def saving_task(name: str) -> None:\n"
"    greeted.add(name)\n"
"\n"
"\n"
"@get(\"/\")\n"
"def greeter(name: str) -> Response[dict[str, str]]:\n"
"    return Response(\n"
"        {\"hello\": name},\n"
"        background=BackgroundTasks(\n"
"            [\n"
"                BackgroundTask(logging_task, name),\n"
"                BackgroundTask(saving_task, name),\n"
"            ]\n"
"        ),\n"
"    )\n"
"\n"
"\n"
"app = Starlite(route_handlers=[greeter])"
msgstr ""

#: ../../../usage/responses.rst:724
msgid ""
":class:`BackgroundTasks <starlite.datastructures.background_tasks."
"BackgroundTasks>` class accepts an optional keyword argument "
"``run_in_task_group`` with a default value of ``False``. Setting this to "
"``True`` allows background tasks to run concurrently, using an `anyio."
"task_group <https://anyio.readthedocs.io/en/stable/tasks.html>`_."
msgstr ""

#: ../../../usage/responses.rst:730
msgid ""
"Setting ``run_in_task_group`` to ``True`` will not preserve execution order."
msgstr ""

#: ../../../usage/responses.rst:735
msgid "Pagination"
msgstr ""

#: ../../../usage/responses.rst:737
msgid ""
"When you need to return a large number of items from an endpoint it is "
"common practice to use pagination to ensure clients can request a specific "
"subset or \"page\" from the total dataset. Starlite supports three types of "
"pagination out of the box:"
msgstr ""

#: ../../../usage/responses.rst:741
msgid "classic pagination"
msgstr ""

#: ../../../usage/responses.rst:742
msgid "limit / offset pagination"
msgstr ""

#: ../../../usage/responses.rst:743
msgid "cursor pagination"
msgstr ""

#: ../../../usage/responses.rst:746 ../../../usage/responses.rst:751
msgid "Classic Pagination"
msgstr ""

#: ../../../usage/responses.rst:748
msgid ""
"In classic pagination the dataset is divided into pages of a specific size "
"and the consumer then requests a specific page."
msgstr ""

#: ../../../usage/responses.rst:751
msgid ""
"from typing import List\n"
"\n"
"from pydantic import BaseModel\n"
"from pydantic_factories import ModelFactory\n"
"\n"
"from starlite import AbstractSyncClassicPaginator, ClassicPagination, "
"Starlite, get\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonClassicPaginator(AbstractSyncClassicPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self, page_size: int) -> int:\n"
"        return round(len(self.data) / page_size)\n"
"\n"
"    def get_items(self, page_size: int, current_page: int) -> List[Person]:\n"
"        return [self.data[i : i + page_size] for i in range(0, len(self."
"data), page_size)][current_page - 1]\n"
"\n"
"\n"
"paginator = PersonClassicPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'page_size' and 'current_page', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\")\n"
"def people_handler(page_size: int, current_page: int) -> "
"ClassicPagination[Person]:\n"
"    return paginator(page_size=page_size, current_page=current_page)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:751
msgid ""
"from pydantic import BaseModel\n"
"from pydantic_factories import ModelFactory\n"
"\n"
"from starlite import AbstractSyncClassicPaginator, ClassicPagination, "
"Starlite, get\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonClassicPaginator(AbstractSyncClassicPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self, page_size: int) -> int:\n"
"        return round(len(self.data) / page_size)\n"
"\n"
"    def get_items(self, page_size: int, current_page: int) -> list[Person]:\n"
"        return [self.data[i : i + page_size] for i in range(0, len(self."
"data), page_size)][current_page - 1]\n"
"\n"
"\n"
"paginator = PersonClassicPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'page_size' and 'current_page', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\")\n"
"def people_handler(page_size: int, current_page: int) -> "
"ClassicPagination[Person]:\n"
"    return paginator(page_size=page_size, current_page=current_page)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:755
msgid ""
"The data container for this pagination is called :class:`ClassicPagination "
"<starlite.datastructures.pagination.ClassicPagination>`, which is what will "
"be returned by the paginator in the above example This will also generate "
"the corresponding OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:759
msgid ""
"If you require async logic, you can implement the :class:"
"`AbstractAsyncClassicPaginator <starlite.datastructures.pagination."
"AbstractAsyncClassicPaginator>` instead of the :class:"
"`AbstractSyncClassicPaginator <starlite.datastructures.pagination."
"AbstractSyncClassicPaginator>`."
msgstr ""

#: ../../../usage/responses.rst:764 ../../../usage/responses.rst:770
msgid "Offset Pagination"
msgstr ""

#: ../../../usage/responses.rst:766
msgid ""
"In offset pagination the consumer requests a number of items specified by "
"``limit`` and the ``offset`` from the beginning of the dataset. For example, "
"given a list of 50 items, you could request ``limit=10``, ``offset=39`` to "
"request items 40-50."
msgstr ""

#: ../../../usage/responses.rst:770
msgid ""
"from itertools import islice\n"
"from typing import List\n"
"\n"
"from pydantic import BaseModel\n"
"from pydantic_factories import ModelFactory\n"
"\n"
"from starlite import AbstractSyncOffsetPaginator, OffsetPagination, "
"Starlite, get\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractSyncOffsetPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self) -> int:\n"
"        return len(self.data)\n"
"\n"
"    def get_items(self, limit: int, offset: int) -> List[Person]:\n"
"        return list(islice(islice(self.data, offset, None), limit))\n"
"\n"
"\n"
"paginator = PersonOffsetPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'limit' and 'offset', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\")\n"
"def people_handler(limit: int, offset: int) -> OffsetPagination[Person]:\n"
"    return paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:770
msgid ""
"from itertools import islice\n"
"\n"
"from pydantic import BaseModel\n"
"from pydantic_factories import ModelFactory\n"
"\n"
"from starlite import AbstractSyncOffsetPaginator, OffsetPagination, "
"Starlite, get\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement two methods "
"'get_total' and 'get_items'\n"
"# we would usually use a database for this, but for our case we will "
"\"fake\" the dataset using a factory.\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractSyncOffsetPaginator[Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_total(self) -> int:\n"
"        return len(self.data)\n"
"\n"
"    def get_items(self, limit: int, offset: int) -> list[Person]:\n"
"        return list(islice(islice(self.data, offset, None), limit))\n"
"\n"
"\n"
"paginator = PersonOffsetPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive two query "
"parameters - 'limit' and 'offset', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\")\n"
"def people_handler(limit: int, offset: int) -> OffsetPagination[Person]:\n"
"    return paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:774
msgid ""
"The data container for this pagination is called :class:`OffsetPagination "
"<starlite.datastructures.pagination.OffsetPagination>`, which is what will "
"be returned by the paginator in the above example This will also generate "
"the corresponding OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:778
msgid ""
"If you require async logic, you can implement the :class:"
"`AbstractAsyncOffsetPaginator <starlite.datastructures.pagination."
"AbstractAsyncOffsetPaginator>` instead of the :class:"
"`AbstractSyncOffsetPaginator <starlite.datastructures.pagination."
"AbstractSyncOffsetPaginator>`."
msgstr ""

#: ../../../usage/responses.rst:783 ../../../usage/responses.rst:790
msgid "Offset Pagination With SQLAlchemy"
msgstr ""

#: ../../../usage/responses.rst:785
msgid ""
"When retrieving paginated data from the database using SQLAlchemy, the "
"Paginator instance requires an SQLAlchemy session instance to make queries. "
"This can be achieved with :ref:`dependency injection <usage/dependency-"
"injection:dependency kwargs>`"
msgstr ""

#: ../../../usage/responses.rst:790
msgid ""
"from typing import List, TYPE_CHECKING\n"
"\n"
"from sqlalchemy import Column, Integer, String, func, select\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import Mapped, declarative_base\n"
"\n"
"from starlite import AbstractAsyncOffsetPaginator, OffsetPagination, "
"Provide, Starlite, get\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"\n"
"Base = declarative_base()\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.engine.result import ScalarResult\n"
"\n"
"\n"
"class Person(Base):\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractAsyncOffsetPaginator[Person]):\n"
"    def __init__(self, async_session: AsyncSession) -> None:  # "
"'async_session' dependency will be injected here.\n"
"        self.async_session = async_session\n"
"\n"
"    async def get_total(self) -> int:\n"
"        return await self.async_session.scalar(select(func.count(Person."
"id)))\n"
"\n"
"    async def get_items(self, limit: int, offset: int) -> List[Person]:\n"
"        people: \"ScalarResult\" = await self.async_session."
"scalars(select(Person).slice(offset, limit))\n"
"        return list(people.all())\n"
"\n"
"\n"
"# Create a route handler. The handler will receive two query parameters - "
"'limit' and 'offset', which is passed\n"
"# to the paginator instance. Also create a dependency 'paginator' which will "
"be injected into the handler.\n"
"@get(\"/people\", dependencies={\"paginator\": "
"Provide(PersonOffsetPaginator)})\n"
"async def people_handler(paginator: PersonOffsetPaginator, limit: int, "
"offset: int) -> OffsetPagination[Person]:\n"
"    return await paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"sqlalchemy_config = SQLAlchemyConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"dependency_key=\"async_session\"\n"
")  # Create 'async_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler], on_startup=[on_startup], "
"plugins=[sqlalchemy_plugin])"
msgstr ""

#: ../../../usage/responses.rst:790
msgid ""
"from typing import TYPE_CHECKING\n"
"\n"
"from sqlalchemy import Column, Integer, String, func, select\n"
"from sqlalchemy.ext.asyncio import AsyncSession\n"
"from sqlalchemy.orm import Mapped, declarative_base\n"
"\n"
"from starlite import AbstractAsyncOffsetPaginator, OffsetPagination, "
"Provide, Starlite, get\n"
"from starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n"
"\n"
"Base = declarative_base()\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.engine.result import ScalarResult\n"
"\n"
"\n"
"class Person(Base):\n"
"    id: Mapped[int] = Column(Integer, primary_key=True)\n"
"    name: Mapped[str] = Column(String)\n"
"\n"
"\n"
"class PersonOffsetPaginator(AbstractAsyncOffsetPaginator[Person]):\n"
"    def __init__(self, async_session: AsyncSession) -> None:  # "
"'async_session' dependency will be injected here.\n"
"        self.async_session = async_session\n"
"\n"
"    async def get_total(self) -> int:\n"
"        return await self.async_session.scalar(select(func.count(Person."
"id)))\n"
"\n"
"    async def get_items(self, limit: int, offset: int) -> list[Person]:\n"
"        people: \"ScalarResult\" = await self.async_session."
"scalars(select(Person).slice(offset, limit))\n"
"        return list(people.all())\n"
"\n"
"\n"
"# Create a route handler. The handler will receive two query parameters - "
"'limit' and 'offset', which is passed\n"
"# to the paginator instance. Also create a dependency 'paginator' which will "
"be injected into the handler.\n"
"@get(\"/people\", dependencies={\"paginator\": "
"Provide(PersonOffsetPaginator)})\n"
"async def people_handler(paginator: PersonOffsetPaginator, limit: int, "
"offset: int) -> OffsetPagination[Person]:\n"
"    return await paginator(limit=limit, offset=offset)\n"
"\n"
"\n"
"sqlalchemy_config = SQLAlchemyConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"dependency_key=\"async_session\"\n"
")  # Create 'async_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.engine.begin() as conn:\n"
"        await conn.run_sync(Base.metadata.create_all)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler], on_startup=[on_startup], "
"plugins=[sqlalchemy_plugin])"
msgstr ""

#: ../../../usage/responses.rst:794
msgid ""
"See :ref:`SQLAlchemy plugin <usage/plugins/sqlalchemy:SQLAlchemy Plugin>` "
"for sqlalchemy integration."
msgstr ""

#: ../../../usage/responses.rst:797 ../../../usage/responses.rst:803
msgid "Cursor Pagination"
msgstr ""

#: ../../../usage/responses.rst:799
msgid ""
"In cursor pagination the consumer requests a number of items specified by "
"``results_per_page`` and a ``cursor`` after which results are given. Cursor "
"is unique identifier within the dataset that serves as a way to point the "
"starting position."
msgstr ""

#: ../../../usage/responses.rst:803
msgid ""
"from typing import List, Optional, Tuple\n"
"\n"
"from pydantic import BaseModel\n"
"from pydantic_factories import ModelFactory\n"
"\n"
"from starlite import AbstractSyncCursorPaginator, CursorPagination, "
"Starlite, get\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement the method "
"'get_items'.\n"
"\n"
"\n"
"class PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_items(self, cursor: Optional[str], results_per_page: int) -> "
"Tuple[List[Person], Optional[str]]:\n"
"        results = self.data[:results_per_page]\n"
"        return results, results[-1].id\n"
"\n"
"\n"
"paginator = PersonCursorPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive a single query "
"parameter - 'cursor', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\")\n"
"def people_handler(cursor: Optional[str], results_per_page: int) -> "
"CursorPagination[str, Person]:\n"
"    return paginator(cursor=cursor, results_per_page=results_per_page)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:803
msgid ""
"from pydantic import BaseModel\n"
"from pydantic_factories import ModelFactory\n"
"\n"
"from starlite import AbstractSyncCursorPaginator, CursorPagination, "
"Starlite, get\n"
"\n"
"\n"
"class Person(BaseModel):\n"
"    id: str\n"
"    name: str\n"
"\n"
"\n"
"class PersonFactory(ModelFactory[Person]):\n"
"    __model__ = Person\n"
"\n"
"\n"
"# we will implement a paginator - the paginator must implement the method "
"'get_items'.\n"
"\n"
"\n"
"class PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n"
"    def __init__(self) -> None:\n"
"        self.data = PersonFactory.batch(50)\n"
"\n"
"    def get_items(self, cursor: str | None, results_per_page: int) -> "
"tuple[list[Person], str | None]:\n"
"        results = self.data[:results_per_page]\n"
"        return results, results[-1].id\n"
"\n"
"\n"
"paginator = PersonCursorPaginator()\n"
"\n"
"\n"
"# we now create a regular handler. The handler will receive a single query "
"parameter - 'cursor', which\n"
"# we will pass to the paginator.\n"
"@get(\"/people\")\n"
"def people_handler(cursor: str | None, results_per_page: int) -> "
"CursorPagination[str, Person]:\n"
"    return paginator(cursor=cursor, results_per_page=results_per_page)\n"
"\n"
"\n"
"app = Starlite(route_handlers=[people_handler])"
msgstr ""

#: ../../../usage/responses.rst:807
msgid ""
"The data container for this pagination is called :class:`CursorPagination "
"<starlite.datastructures.pagination.CursorPagination>`, which is what will "
"be returned by the paginator in the above example This will also generate "
"the corresponding OpenAPI documentation."
msgstr ""

#: ../../../usage/responses.rst:811
msgid ""
"If you require async logic, you can implement the :class:"
"`AbstractAsyncCursorPaginator <starlite.datastructures.pagination."
"AbstractAsyncCursorPaginator>` instead of the :class:"
"`AbstractSyncCursorPaginator <starlite.datastructures.pagination."
"AbstractSyncCursorPaginator>`."
msgstr ""
