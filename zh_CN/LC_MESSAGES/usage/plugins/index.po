# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/plugins/index.rst:5
msgid "Plugins"
msgstr ""

#: ../../../usage/plugins/index.rst:7
msgid ""
"Litestar supports a plugin system that allows you to extend the "
"functionality of the framework."
msgstr ""

#: ../../../usage/plugins/index.rst:11
msgid ":doc:`/usage/databases/sqlalchemy/plugins/index`"
msgstr ""

#: ../../../usage/plugins/index.rst:13
msgid ""
"Plugins are defined by protocols, and any type that satisfies a protocol can "
"be included in the ``plugins`` argument of the :class:`app <litestar.app."
"Litestar>`."
msgstr ""

#: ../../../usage/plugins/index.rst:18
msgid "InitPlugin"
msgstr ""

#: ../../../usage/plugins/index.rst:20
msgid ""
"``InitPlugin`` defines an interface that allows for customization of the "
"application's initialization process. Init plugins can define dependencies, "
"add route handlers, configure middleware, and much more!"
msgstr ""

#: ../../../usage/plugins/index.rst:23
msgid ""
"Implementations of these plugins must define a single method: :meth:"
"`on_app_init(self, app_config: AppConfig) -> AppConfig: <litestar.plugins."
"InitPlugin.on_app_init>`"
msgstr ""

#: ../../../usage/plugins/index.rst:26
msgid ""
"The method accepts and must return an :class:`AppConfig <litestar.config.app."
"AppConfig>` instance, which can be modified and is later used to instantiate "
"the application."
msgstr ""

#: ../../../usage/plugins/index.rst:29
msgid ""
"This method is invoked after any ``on_app_init`` hooks have been called, and "
"each plugin is invoked in the order that they are provided in the "
"``plugins`` argument of the :class:`app <litestar.app.Litestar>`. Because of "
"this, plugin authors should make it clear in their documentation if their "
"plugin should be invoked before or after other plugins."
msgstr ""

#: ../../../usage/plugins/index.rst:34 ../../../usage/plugins/index.rst:74
#: ../../../usage/plugins/index.rst:140
msgid "Example"
msgstr ""

#: ../../../usage/plugins/index.rst:36
msgid ""
"The following example shows a simple plugin that adds a route handler, and a "
"dependency to the application."
msgstr ""

#: ../../../usage/plugins/index.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/plugins/index.rst:39
msgid "``InitPlugin`` implementation example"
msgstr ""

#: ../../../usage/plugins/index.rst:39
msgid ""
"from typing import Dict\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.config.app import AppConfig\n"
"from litestar.di import Provide\n"
"from litestar.plugins import InitPlugin\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def route_handler(name: str) -> Dict[str, str]:\n"
"    return {\"hello\": name}\n"
"\n"
"\n"
"def get_name() -> str:\n"
"    return \"world\"\n"
"\n"
"\n"
"class MyPlugin(InitPlugin):\n"
"    def on_app_init(self, app_config: AppConfig) -> AppConfig:\n"
"        app_config.dependencies[\"name\"] = Provide(get_name, "
"sync_to_thread=False)\n"
"        app_config.route_handlers.append(route_handler)\n"
"        return app_config\n"
"\n"
"\n"
"app = Litestar(plugins=[MyPlugin()])"
msgstr ""

#: ../../../usage/plugins/index.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/plugins/index.rst:39
msgid ""
"from litestar import Litestar, get\n"
"from litestar.config.app import AppConfig\n"
"from litestar.di import Provide\n"
"from litestar.plugins import InitPlugin\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def route_handler(name: str) -> dict[str, str]:\n"
"    return {\"hello\": name}\n"
"\n"
"\n"
"def get_name() -> str:\n"
"    return \"world\"\n"
"\n"
"\n"
"class MyPlugin(InitPlugin):\n"
"    def on_app_init(self, app_config: AppConfig) -> AppConfig:\n"
"        app_config.dependencies[\"name\"] = Provide(get_name, "
"sync_to_thread=False)\n"
"        app_config.route_handlers.append(route_handler)\n"
"        return app_config\n"
"\n"
"\n"
"app = Litestar(plugins=[MyPlugin()])"
msgstr ""

#: ../../../usage/plugins/index.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"{\"hello\":\"world\"}"
msgstr ""

#: ../../../usage/plugins/index.rst:42
msgid ""
"The ``MyPlugin`` class is an implementation of the :class:`InitPlugin "
"<litestar.plugins.InitPlugin>`. It defines a single method, "
"``on_app_init()``, which takes an :class:`AppConfig <litestar.config.app."
"AppConfig>` instance as an argument and returns same."
msgstr ""

#: ../../../usage/plugins/index.rst:46
msgid ""
"In the ``on_app_init()`` method, the dependency mapping is updated to "
"include a new dependency named ``\"name\"``, which is provided by the "
"``get_name()`` function, and ``route_handlers`` is updated to include the "
"``route_handler()`` function. The modified :class:`AppConfig <litestar."
"config.app.AppConfig>` instance is then returned."
msgstr ""

#: ../../../usage/plugins/index.rst:51
msgid "SerializationPluginProtocol"
msgstr ""

#: ../../../usage/plugins/index.rst:53
msgid ""
"The SerializationPluginProtocol defines a contract for plugins that provide "
"serialization functionality for data types that are otherwise unsupported by "
"the framework."
msgstr ""

#: ../../../usage/plugins/index.rst:56
msgid "Implementations of these plugins must define the following methods."
msgstr ""

#: ../../../usage/plugins/index.rst:58
msgid ""
":meth:`supports_type(self, field_definition: FieldDefinition) -> bool: "
"<litestar.plugins.SerializationPluginProtocol>`"
msgstr ""

#: ../../../usage/plugins/index.rst:60
msgid ""
"The method takes a :class:`FieldDefinition <litestar.typing."
"FieldDefinition>` instance as an argument and returns a :class:`bool` "
"indicating whether the plugin supports serialization for that type."
msgstr ""

#: ../../../usage/plugins/index.rst:63
msgid ""
":meth:`create_dto_for_type(self, field_definition: FieldDefinition) -> "
"type[AbstractDTO]: <litestar.plugins.SerializationPluginProtocol."
"create_dto_for_type>`"
msgstr ""

#: ../../../usage/plugins/index.rst:65
msgid ""
"This method accepts a :class:`FieldDefinition <litestar.typing."
"FieldDefinition>` instance as an argument and must return a :class:"
"`AbstractDTO <litestar.dto.base_dto.AbstractDTO>` implementation that can be "
"used to serialize and deserialize the type."
msgstr ""

#: ../../../usage/plugins/index.rst:69
msgid ""
"During application startup, if a data or return annotation is encountered "
"that is not a supported type, is supported by the plugin, and doesn't "
"otherwise have a ``dto`` or ``return_dto`` defined, the plugin is used to "
"create a DTO type for that annotation."
msgstr ""

#: ../../../usage/plugins/index.rst:76
msgid ""
"The following example shows the actual implementation of the "
"``SerializationPluginProtocol`` for `SQLAlchemy <https://www.sqlalchemy.org/"
">`_ models that is is provided in ``advanced_alchemy``."
msgstr ""

#: ../../../usage/plugins/index.rst:80
msgid "``SerializationPluginProtocol`` implementation example"
msgstr ""

#: ../../../usage/plugins/index.rst:80
msgid ""
"from __future__ import annotations\n"
"\n"
"from typing import TYPE_CHECKING\n"
"\n"
"from litestar.utils import warn_deprecation\n"
"\n"
"__all__ = (\"SQLAlchemySerializationPlugin\",)\n"
"\n"
"\n"
"def __getattr__(attr_name: str) -> object:\n"
"    if attr_name in __all__:\n"
"        warn_deprecation(\n"
"            deprecated_name=f\"litestar.contrib.sqlalchemy.plugins."
"serialization.{attr_name}\",\n"
"            version=\"2.12\",\n"
"            kind=\"import\",\n"
"            removal_in=\"3.0\",\n"
"            info=f\"importing {attr_name} from 'litestar.contrib.sqlalchemy."
"plugins.serialization' is deprecated, please \"\n"
"            \"import it from 'litestar.plugins.sqlalchemy' instead\",\n"
"        )\n"
"        from advanced_alchemy.extensions.litestar import "
"SQLAlchemySerializationPlugin\n"
"\n"
"        value = globals()[attr_name] = SQLAlchemySerializationPlugin\n"
"        return value\n"
"\n"
"    raise AttributeError(f\"module {__name__!r} has no attribute {attr_name!"
"r}\")  # pragma: no cover\n"
"\n"
"\n"
"if TYPE_CHECKING:\n"
"    from advanced_alchemy.extensions.litestar import "
"SQLAlchemySerializationPlugin"
msgstr ""

#: ../../../usage/plugins/index.rst:83
msgid ""
":meth:`supports_type(self, field_definition: FieldDefinition) -> bool: "
"<advanced_alchemy.extensions.litestar.SQLAlchemySerializationPlugin."
"supports_type>` returns a :class:`bool` indicating whether the plugin "
"supports serialization for the given type. Specifically, we return ``True`` "
"if the parsed type is either a collection of SQLAlchemy models or a single "
"SQLAlchemy model."
msgstr ""

#: ../../../usage/plugins/index.rst:87
msgid ""
":meth:`create_dto_for_type(self, field_definition: FieldDefinition) -> "
"type[AbstractDTO]: <advanced_alchemy.extensions.litestar."
"SQLAlchemySerializationPlugin.create_dto_for_type>` takes a :class:"
"`FieldDefinition <litestar.typing.FieldDefinition>` instance as an argument "
"and returns a :class:`SQLAlchemyDTO <advanced_alchemy.extensions.litestar."
"dto.SQLAlchemyDTO>` subclass and includes some logic that may be interesting "
"to potential serialization plugin authors."
msgstr ""

#: ../../../usage/plugins/index.rst:92
msgid ""
"The first thing the method does is check if the parsed type is a collection "
"of SQLAlchemy models or a single SQLAlchemy model, retrieves the model type "
"in either case and assigns it to the ``annotation`` variable."
msgstr ""

#: ../../../usage/plugins/index.rst:95
msgid ""
"The method then checks if ``annotation`` is already in the ``_type_dto_map`` "
"dictionary. If it is, it returns the corresponding DTO type. This is done to "
"ensure that multiple :class:`SQLAlchemyDTO <advanced_alchemy.extensions."
"litestar.dto.SQLAlchemyDTO>` subtypes are not created for the same model."
msgstr ""

#: ../../../usage/plugins/index.rst:99
msgid ""
"If the annotation is not in the ``_type_dto_map`` dictionary, the method "
"creates a new DTO type for the annotation, adds it to the ``_type_dto_map`` "
"dictionary, and returns it."
msgstr ""

#: ../../../usage/plugins/index.rst:104
msgid "DIPlugin"
msgstr ""

#: ../../../usage/plugins/index.rst:106
msgid ""
":class:`~litestar.plugins.DIPlugin` can be used to extend Litestar's "
"dependency injection by providing information about injectable types."
msgstr ""

#: ../../../usage/plugins/index.rst:109
msgid ""
"Its main purpose it to facilitate the injection of callables with unknown "
"signatures, for example Pydantic's ``BaseModel`` classes; These are not "
"supported natively since, while they are callables, their type information "
"is not contained within their callable signature (their :func:`__init__` "
"method)."
msgstr ""

#: ../../../usage/plugins/index.rst:116
msgid "Dynamically generating signature information for a custom type"
msgstr ""

#: ../../../usage/plugins/index.rst:116
msgid ""
"from inspect import Parameter, Signature\n"
"from typing import Any, Dict, Tuple\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.di import Provide\n"
"from litestar.plugins import DIPlugin\n"
"\n"
"\n"
"class MyBaseType:\n"
"    def __init__(self, param):\n"
"        self.param = param\n"
"\n"
"\n"
"class MyDIPlugin(DIPlugin):\n"
"    def has_typed_init(self, type_: Any) -> bool:\n"
"        return issubclass(type_, MyBaseType)\n"
"\n"
"    def get_typed_init(self, type_: Any) -> Tuple[Signature, Dict[str, "
"Any]]:\n"
"        signature = Signature([Parameter(name=\"param\", kind=Parameter."
"POSITIONAL_OR_KEYWORD)])\n"
"        annotations = {\"param\": str}\n"
"        return signature, annotations\n"
"\n"
"\n"
"@get(\"/\", dependencies={\"injected\": Provide(MyBaseType, "
"sync_to_thread=False)})\n"
"async def handler(injected: MyBaseType) -> str:\n"
"    return injected.param\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler], plugins=[MyDIPlugin()])"
msgstr ""

#: ../../../usage/plugins/index.rst:116
msgid ""
"from inspect import Parameter, Signature\n"
"from typing import Any\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.di import Provide\n"
"from litestar.plugins import DIPlugin\n"
"\n"
"\n"
"class MyBaseType:\n"
"    def __init__(self, param):\n"
"        self.param = param\n"
"\n"
"\n"
"class MyDIPlugin(DIPlugin):\n"
"    def has_typed_init(self, type_: Any) -> bool:\n"
"        return issubclass(type_, MyBaseType)\n"
"\n"
"    def get_typed_init(self, type_: Any) -> tuple[Signature, dict[str, "
"Any]]:\n"
"        signature = Signature([Parameter(name=\"param\", kind=Parameter."
"POSITIONAL_OR_KEYWORD)])\n"
"        annotations = {\"param\": str}\n"
"        return signature, annotations\n"
"\n"
"\n"
"@get(\"/\", dependencies={\"injected\": Provide(MyBaseType, "
"sync_to_thread=False)})\n"
"async def handler(injected: MyBaseType) -> str:\n"
"    return injected.param\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler], plugins=[MyDIPlugin()])"
msgstr ""

#: ../../../usage/plugins/index.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/?param=hello\n"
"hello"
msgstr ""

#: ../../../usage/plugins/index.rst:127
msgid "ReceiveRoutePlugin"
msgstr ""

#: ../../../usage/plugins/index.rst:129
msgid ""
":class:`~litestar.plugins.ReceiveRoutePlugin` allows you to receive routes "
"as they are registered on the application. This can be useful for plugins "
"that need to perform actions based on the routes being added, such as "
"generating documentation, validating route configurations, or tracking route "
"statistics."
msgstr ""

#: ../../../usage/plugins/index.rst:133
msgid ""
"Implementations of this plugin must define a single method: :meth:"
"`receive_route(self, route: BaseRoute) -> None: <litestar.plugins."
"ReceiveRoutePlugin.receive_route>`"
msgstr ""

#: ../../../usage/plugins/index.rst:136
msgid ""
"The method receives a :class:`BaseRoute <litestar.routes.BaseRoute>` "
"instance as routes are registered on the application. This happens during "
"the application initialization process, after routes are created but before "
"the application starts."
msgstr ""

#: ../../../usage/plugins/index.rst:142
msgid ""
"The following example shows a simple plugin that logs information about each "
"route as it's registered:"
msgstr ""

#: ../../../usage/plugins/index.rst:145
msgid ""
"from litestar.plugins import ReceiveRoutePlugin\n"
"from litestar.routes import BaseRoute\n"
"\n"
"class RouteLoggerPlugin(ReceiveRoutePlugin):\n"
"    def receive_route(self, route: BaseRoute) -> None:\n"
"        print(f\"Route registered: {route.path} [{', '.join(route."
"methods)}]\")"
msgstr ""
