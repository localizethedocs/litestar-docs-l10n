# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/middleware/creating-middleware.rst:3
msgid "Creating Middleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:5
msgid ""
"As mentioned in :ref:`using middleware <using-middleware>`, a middleware in "
"Litestar is **any callable** that takes a kwarg called ``app``, which is the "
"next ASGI handler, i.e. an :class:`~litestar.types.ASGIApp`, and returns an "
"``ASGIApp``."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:9
msgid "The example previously given was using a factory function, i.e.:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:12
msgid ""
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:26
msgid "Extending ``ASGIMiddleware``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:28
msgid ""
"While using functions is a perfectly viable approach, the recommended way to "
"handle this is by using the :class:`~litestar.middleware.ASGIMiddleware` "
"abstract base class, which also includes functionality to dynamically skip "
"the middleware based on ASGI ``scope[\"type\"]``, handler ``opt`` keys or "
"path patterns and a simple way to pass configuration to middlewares; It does "
"not implement an ``__init__`` method, so subclasses are free to use it to "
"customize the middleware's configuration."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:37
msgid "Modifying Requests and Responses"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:39
msgid ""
"Middlewares can not only be used to execute *around* other ASGI callable, "
"they can also intercept and modify both incoming and outgoing data in a "
"request / response cycle by \"wrapping\" the respective ``receive`` and "
"``send`` ASGI callables."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:43
msgid ""
"The following demonstrates how to add a request timing header with a "
"timestamp to all outgoing responses:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:47
msgid ""
"import time\n"
"\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Message, Receive, Scope, Send\n"
"\n"
"\n"
"class ProcessTimeHeader(ASGIMiddleware):\n"
"    scopes = (ScopeType.HTTP, ScopeType.ASGI)\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: Message) -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await next_app(scope, receive, send_wrapper)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:52
msgid "Migrating from ``MiddlewareProtocol`` / ``AbstractMiddleware``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:54
msgid ""
":class:`~litestar.middleware.ASGIMiddleware` was introduced in Litestar "
"2.15. If you've been using ``MiddlewareProtocol`` / ``AbstractMiddleware`` "
"to implement your middlewares before, there's a simple migration path to "
"using ``ASGIMiddleware``."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:58
msgid "**From MiddlewareProtocol**"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:65
msgid ""
"from litestar.middleware import MiddlewareProtocol\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do stuff\n"
"        await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "ASGIMiddleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:70
msgid ""
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(ASGIMiddleware):\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        # do stuff\n"
"        await next_app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:74
msgid "**From AbstractMiddleware**"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:81
msgid ""
"import anyio\n"
"\n"
"from litestar import Litestar\n"
"from litestar.middleware import AbstractMiddleware, DefineMiddleware\n"
"from litestar.types import ASGIApp, Receive, Scope, Scopes, Send\n"
"\n"
"\n"
"class TimeoutMiddleware(AbstractMiddleware):\n"
"    def __init__(\n"
"        self,\n"
"        app: ASGIApp,\n"
"        timeout: float,\n"
"        exclude: str | list[str] | None = None,\n"
"        exclude_opt_key: str | None = None,\n"
"        scopes: Scopes | None = None,\n"
"    ):\n"
"        self.timeout = timeout\n"
"        super().__init__(app=app, exclude=exclude, "
"exclude_opt_key=exclude_opt_key, scopes=scopes)\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        with anyio.move_on_after(self.timeout):\n"
"            await self.app(scope, receive, send)\n"
"\n"
"\n"
"app = Litestar(\n"
"    middleware=[\n"
"        DefineMiddleware(\n"
"            TimeoutMiddleware,\n"
"            timeout=5,\n"
"        )\n"
"    ]\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:86
msgid ""
"import anyio\n"
"\n"
"from litestar import Litestar\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"class TimeoutMiddleware(ASGIMiddleware):\n"
"    def __init__(self, timeout: float):\n"
"        self.timeout = timeout\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        with anyio.move_on_after(self.timeout):\n"
"            await next_app(scope, receive, send)\n"
"\n"
"\n"
"app = Litestar(middleware=[TimeoutMiddleware(timeout=5)])"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:94
msgid "Using MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:96
msgid ""
"The :class:`~litestar.middleware.base.MiddlewareProtocol` class is a `PEP "
"544 Protocol <https://peps.python.org/pep-0544/>`_ that specifies the "
"minimal implementation of a middleware as follows:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:101
msgid ""
"from typing import Protocol, Any\n"
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"class MiddlewareProtocol(Protocol):\n"
"    def __init__(self, app: ASGIApp, **kwargs: Any) -> None: ...\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None: ..."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:111
msgid ""
"The ``__init__`` method receives and sets \"app\". *It's important to "
"understand* that app is not an instance of Litestar in this case, but rather "
"the next middleware in the stack, which is also an ASGI app."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:114
msgid ""
"The ``__call__`` method makes this class into a ``callable``, i.e. once "
"instantiated this class acts like a function, that has the signature of an "
"ASGI app: The three parameters, ``scope, receive, send`` are specified by "
"`the ASGI specification <https://asgi.readthedocs.io/en/latest/index."
"html>`_, and their values originate with the ASGI server (e.g. "
"``uvicorn``\\ ) used to run Litestar."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:119
msgid ""
"To use this protocol as a basis, simply subclass it - as you would any other "
"class, and implement the two methods it specifies:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:123
msgid ""
"import logging\n"
"\n"
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"from litestar import Request\n"
"from litestar.middleware.base import MiddlewareProtocol\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"class MyRequestLoggingMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:  # can have other parameters "
"as well\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if scope[\"type\"] == \"http\":\n"
"            request = Request(scope)\n"
"            logger.info(\"Got request: %s - %s\", request.method, request."
"url)\n"
"        await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:145
msgid ""
"Although ``scope`` is used to create an instance of request by passing it to "
"the :class:`~litestar.connection.Request` constructor, which makes it "
"simpler to access because it does some parsing for you already, the actual "
"source of truth remains ``scope`` - not the request. If you need to modify "
"the data of the request you must modify the scope object, not any ephemeral "
"request objects created as in the above."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:152
msgid "Responding using the MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:154
msgid ""
"Once a middleware finishes doing whatever its doing, it should pass "
"``scope``, ``receive``, and ``send`` to an ASGI app and await it. This is "
"what's happening in the above example with: ``await self.app(scope, receive, "
"send)``. Let's explore another example - redirecting the request to a "
"different url from a middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:159
msgid ""
"from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"from litestar.response.redirect import ASGIRedirectResponse\n"
"from litestar import Request\n"
"from litestar.middleware.base import MiddlewareProtocol\n"
"\n"
"\n"
"class RedirectMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if Request(scope).session is None:\n"
"            response = ASGIRedirectResponse(path=\"/login\")\n"
"            await response(scope, receive, send)\n"
"        else:\n"
"            await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:178
msgid ""
"As you can see in the above, given some condition (``request.session`` being "
"``None``) we create a :class:`~litestar.response.redirect."
"ASGIRedirectResponse` and then await it. Otherwise, we await ``self.app``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:182
msgid "Modifying ASGI Requests and Responses using the MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:186
msgid ""
"If you'd like to modify a :class:`~litestar.response.Response` object after "
"it was created for a route handler function but before the actual response "
"message is transmitted, the correct place to do this is using the special "
"life-cycle hook called :ref:`after_request <after_request>`. The "
"instructions in this section are for how to modify the ASGI response message "
"itself, which is a step further in the response process."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:191
msgid ""
"Using the :class:`~litestar.middleware.base.MiddlewareProtocol` you can "
"intercept and modifying both the incoming and outgoing data in a request / "
"response cycle by \"wrapping\" that respective ``receive`` and ``send`` ASGI "
"functions."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:195
msgid ""
"To demonstrate this, let's say we want to append a header with a timestamp "
"to all outgoing responses. We could achieve this by doing the following:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:199
msgid ""
"import time\n"
"\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.types import Message, Receive, Scope, Send\n"
"from litestar.middleware.base import MiddlewareProtocol\n"
"from litestar.types import ASGIApp\n"
"\n"
"\n"
"class ProcessTimeHeader(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        super().__init__(app)\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if scope[\"type\"] == \"http\":\n"
"            start_time = time.monotonic()\n"
"\n"
"            async def send_wrapper(message: Message) -> None:\n"
"                if message[\"type\"] == \"http.response.start\":\n"
"                    process_time = time.monotonic() - start_time\n"
"                    headers = MutableScopeHeaders."
"from_message(message=message)\n"
"                    headers[\"X-Process-Time\"] = str(process_time)\n"
"                await send(message)\n"
"\n"
"            await self.app(scope, receive, send_wrapper)\n"
"        else:\n"
"            await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:229
msgid "Inheriting AbstractMiddleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:231
msgid ""
"Litestar offers an :class:`~litestar.middleware.base.AbstractMiddleware` "
"class that can be extended to create middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:235
msgid ""
"import time\n"
"\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import AbstractMiddleware\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.types import Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(AbstractMiddleware):\n"
"    scopes = {ScopeType.HTTP}\n"
"    exclude = [\"first_path\", \"second_path\"]\n"
"    exclude_opt_key = \"exclude_from_middleware\"\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await self.app(scope, receive, send_wrapper)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:261
msgid ""
"The three class variables defined in the above example ``scopes``, "
"``exclude``, and ``exclude_opt_key`` can be used to fine-tune for which "
"routes and request types the middleware is called:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:265
msgid ""
"The scopes variable is a set that can include either or both : ``ScopeType."
"HTTP`` and ``ScopeType.WEBSOCKET`` , with the default being both."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:266
msgid ""
"``exclude`` accepts either a single string or list of strings that are "
"compiled into a regex against which the request's ``path`` is checked."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:267
msgid ""
"``exclude_opt_key`` is the key to use for in a route handler's :class:"
"`Router.opt <litestar.router.Router>` dict for a boolean, whether to omit "
"from the middleware."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:269
msgid ""
"Thus, in the following example, the middleware will only run against the "
"handler called ``not_excluded_handler`` for ``/greet`` route:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:272
msgid ""
"import time\n"
"from typing import Dict\n"
"\n"
"from litestar import Litestar, WebSocket, get, websocket\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(ASGIMiddleware):\n"
"    scopes = (ScopeType.HTTP,)\n"
"    exclude_path_pattern = (\"first_path\", \"second_path\")\n"
"    exclude_opt_key = \"exclude_from_my_middleware\"\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await next_app(scope, receive, send_wrapper)\n"
"\n"
"\n"
"@websocket(\"/my-websocket\")\n"
"async def websocket_handler(socket: WebSocket) -> None:\n"
"    \"\"\"\n"
"    Websocket handler - is excluded because the middleware scopes includes "
"'ScopeType.HTTP'\n"
"    \"\"\"\n"
"    await socket.accept()\n"
"    await socket.send_json({\"hello\": \"websocket\"})\n"
"    await socket.close()\n"
"\n"
"\n"
"@get(\"/first_path\", sync_to_thread=False)\n"
"def first_handler() -> Dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"first_path\"."
"\"\"\"\n"
"    return {\"hello\": \"first\"}\n"
"\n"
"\n"
"@get(\"/second_path\", sync_to_thread=False)\n"
"def second_handler() -> Dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"second_path\"."
"\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/third_path\", exclude_from_my_middleware=True, "
"sync_to_thread=False)\n"
"def third_handler() -> Dict[str, str]:\n"
"    \"\"\"Handler is excluded due to the opt key "
"'exclude_from_my_middleware' matching the middleware 'exclude_opt_key'."
"\"\"\"\n"
"    return {\"hello\": \"third\"}\n"
"\n"
"\n"
"@get(\"/greet\", sync_to_thread=False)\n"
"def not_excluded_handler() -> Dict[str, str]:\n"
"    \"\"\"This handler is not excluded, and thus the middleware will execute "
"on every incoming request to it.\"\"\"\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[\n"
"        websocket_handler,\n"
"        first_handler,\n"
"        second_handler,\n"
"        third_handler,\n"
"        not_excluded_handler,\n"
"    ],\n"
"    middleware=[MyMiddleware()],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:272
msgid ""
"import time\n"
"\n"
"from litestar import Litestar, WebSocket, get, websocket\n"
"from litestar.datastructures import MutableScopeHeaders\n"
"from litestar.enums import ScopeType\n"
"from litestar.middleware import ASGIMiddleware\n"
"from litestar.types import ASGIApp, Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(ASGIMiddleware):\n"
"    scopes = (ScopeType.HTTP,)\n"
"    exclude_path_pattern = (\"first_path\", \"second_path\")\n"
"    exclude_opt_key = \"exclude_from_my_middleware\"\n"
"\n"
"    async def handle(self, scope: Scope, receive: Receive, send: Send, "
"next_app: ASGIApp) -> None:\n"
"        start_time = time.monotonic()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time.monotonic() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"            await send(message)\n"
"\n"
"        await next_app(scope, receive, send_wrapper)\n"
"\n"
"\n"
"@websocket(\"/my-websocket\")\n"
"async def websocket_handler(socket: WebSocket) -> None:\n"
"    \"\"\"\n"
"    Websocket handler - is excluded because the middleware scopes includes "
"'ScopeType.HTTP'\n"
"    \"\"\"\n"
"    await socket.accept()\n"
"    await socket.send_json({\"hello\": \"websocket\"})\n"
"    await socket.close()\n"
"\n"
"\n"
"@get(\"/first_path\", sync_to_thread=False)\n"
"def first_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"first_path\"."
"\"\"\"\n"
"    return {\"hello\": \"first\"}\n"
"\n"
"\n"
"@get(\"/second_path\", sync_to_thread=False)\n"
"def second_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"second_path\"."
"\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/third_path\", exclude_from_my_middleware=True, "
"sync_to_thread=False)\n"
"def third_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to the opt key "
"'exclude_from_my_middleware' matching the middleware 'exclude_opt_key'."
"\"\"\"\n"
"    return {\"hello\": \"third\"}\n"
"\n"
"\n"
"@get(\"/greet\", sync_to_thread=False)\n"
"def not_excluded_handler() -> dict[str, str]:\n"
"    \"\"\"This handler is not excluded, and thus the middleware will execute "
"on every incoming request to it.\"\"\"\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[\n"
"        websocket_handler,\n"
"        first_handler,\n"
"        second_handler,\n"
"        third_handler,\n"
"        not_excluded_handler,\n"
"    ],\n"
"    middleware=[MyMiddleware()],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:276
msgid ""
"Using ``/`` as an exclude pattern, will disable this middleware for all "
"routes, since, as a regex, it matches *every* path"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:281
msgid "Using DefineMiddleware to pass arguments"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:283
msgid ""
"Litestar offers a simple way to pass positional arguments (``*args``) and "
"keyword arguments (``**kwargs``) to middleware using the :class:`~litestar."
"middleware.base.DefineMiddleware` class. Let's extend the factory function "
"used in the examples above to take some args and kwargs and then use "
"``DefineMiddleware`` to pass these values to our middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:289
msgid ""
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"from litestar import Litestar\n"
"from litestar.middleware import DefineMiddleware\n"
"\n"
"\n"
"def middleware_factory(my_arg: int, *, app: ASGIApp, my_kwarg: str) -> "
"ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # here we can use my_arg and my_kwarg for some purpose\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[...],\n"
"    middleware=[DefineMiddleware(middleware_factory, 1, my_kwarg=\"abc\")],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:309
msgid ""
"The ``DefineMiddleware`` is a simple container - it takes a middleware "
"callable as a first parameter, and then any positional arguments, followed "
"by key word arguments. The middleware callable will be called with these "
"values as well as the kwarg ``app`` as mentioned above."
msgstr ""
