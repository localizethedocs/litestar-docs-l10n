# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/middleware/creating-middleware.rst:3
msgid "Creating Middleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:5
msgid ""
"As mentioned in :doc:`using middleware </usage/middleware/using-"
"middleware>`, a middleware in Starlite is **any callable** that takes a "
"kwarg called ``app``, which is the next ASGI handler, i.e. an :class:"
"`ASGIApp <starlite.types.ASGIApp>`, and returns an ``ASGIApp``."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:9
msgid "The example previously given was using a factory function, i.e.:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:12
msgid ""
"from starlite.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:24
msgid ""
"While using functions is a perfectly viable approach, you can also use "
"classes to do the same. See the next sections on two base classes you can "
"use for this purpose - the :class:`MiddlewareProtocol <.middleware.base."
"MiddlewareProtocol>` , which gives a bare-bones type, or the :class:"
"`AbstractMiddleware <.middleware.base.AbstractMiddleware>` that offers a "
"base class with some built in functionality."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:30
msgid "Using MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:32
msgid ""
"The :class:`MiddlewareProtocol <starlite.middleware.base."
"MiddlewareProtocol>` class is a `PEP 544 Protocol <https://peps.python.org/"
"pep-0544/>`_ that specifies the minimal implementation of a middleware as "
"follows:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:37
msgid ""
"from typing import Protocol, Any\n"
"from starlite.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"class MiddlewareProtocol(Protocol):\n"
"    def __init__(self, app: ASGIApp, **kwargs: Any) -> None: ...\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None: ..."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:47
msgid ""
"The ``__init__`` method receives and sets \"app\". *It's important to "
"understand* that app is not an instance of Starlite in this case, but rather "
"the next middleware in the stack, which is also an ASGI app."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:50
msgid ""
"The ``__call__`` method makes this class into a ``callable``, i.e. once "
"instantiated this class acts like a function, that has the signature of an "
"ASGI app: The three parameters, ``scope, receive, send`` are specified by "
"`the ASGI specification <https://asgi.readthedocs.io/en/latest/index."
"html>`_, and their values originate with the ASGI server (e.g. *uvicorn*\\ ) "
"used to run Starlite."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:55
msgid ""
"To use this protocol as a basis, simply subclass it - as you would any other "
"class, and implement the two methods it specifies:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:59
msgid ""
"import logging\n"
"\n"
"from starlite.types import ASGIApp, Receive, Scope, Send\n"
"from starlite import Request\n"
"from starlite.middleware.base import MiddlewareProtocol\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"class MyRequestLoggingMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        super().__init__(app)\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if scope[\"type\"] == \"http\":\n"
"            request = Request(scope)\n"
"            logger.info(\"%s - %s\" % request.method, request.url)\n"
"        await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:82
msgid ""
"Although ``scope`` is used to create an instance of request by passing it to "
"the :class:`Request <.connection.Request>` constructor, which makes it "
"simpler to access because it does some parsing for you already, the actual "
"source of truth remains ``scope`` - not the request. If you need to modify "
"the data of the request you must modify the scope object, not any ephemeral "
"request objects created as in the above."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:89
msgid "Responding using the MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:91
msgid ""
"Once a middleware finishes doing whatever its doing, it should pass "
"``scope``, ``receive`` and ``send`` to an ASGI app and await it. This is "
"what's happening in the above example with: ``await self.app(scope, receive, "
"send)``. Let's explore another example - redirecting the request to a "
"different url from a middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:96
msgid ""
"from starlite.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"from starlite.response import RedirectResponse\n"
"from starlite import Request\n"
"from starlite.middleware.base import MiddlewareProtocol\n"
"\n"
"\n"
"class RedirectMiddleware(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        super().__init__(app)\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if Request(scope).session is None:\n"
"            response = RedirectResponse(url=\"/login\")\n"
"            await response(scope, receive, send)\n"
"        else:\n"
"            await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:116
msgid ""
"As you can see in the above, given some condition (request.session being "
"None) we create a :class:`RedirectResponse <starlite.response."
"RedirectResponse>` and then await it. Otherwise, we await ``self.app``"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:121
msgid "Modifying ASGI Requests and Responses using the MiddlewareProtocol"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:125
msgid ""
"If you'd like to modify a :class:`Response <.response.Response>` object "
"after it was created for a route handler function but before the actual "
"response message is transmitted, the correct place to do this is using the "
"special life-cycle hook called :ref:`after_request <after_request>`. The "
"instructions in this section are for how to modify the ASGI response message "
"itself, which is a step further in the response process."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:130
msgid ""
"Using the :class:`MiddlewareProtocol <.middleware.base.MiddlewareProtocol>` "
"you can intercept and modifying both the incoming and outgoing data in a "
"request / response cycle by \"wrapping\" that respective ``receive`` and "
"``send`` ASGI functions."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:134
msgid ""
"To demonstrate this, lets say we want to append a header with a timestamp to "
"all outgoing responses. We could achieve this by doing the following:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:138
msgid ""
"import time\n"
"\n"
"from starlite.datastructures import MutableScopeHeaders\n"
"from starlite.types import Message, Receive, Scope, Send\n"
"from starlite.middleware.base import MiddlewareProtocol\n"
"from starlite.types import ASGIApp\n"
"\n"
"\n"
"class ProcessTimeHeader(MiddlewareProtocol):\n"
"    def __init__(self, app: ASGIApp) -> None:\n"
"        super().__init__(app)\n"
"        self.app = app\n"
"\n"
"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        if scope[\"type\"] == \"http\":\n"
"            start_time = time.time()\n"
"\n"
"            async def send_wrapper(message: Message) -> None:\n"
"                if message[\"type\"] == \"http.response.start\":\n"
"                    process_time = time.time() - start_time\n"
"                    headers = MutableScopeHeaders."
"from_message(message=message)\n"
"                    headers[\"X-Process-Time\"] = str(process_time)\n"
"                await send(message)\n"
"\n"
"            await self.app(scope, receive, send_wrapper)\n"
"        else:\n"
"            await self.app(scope, receive, send)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:168
msgid "Inheriting AbstractMiddleware"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:170
msgid ""
"Starlite offers an :class:`AbstractMiddleware <.middleware.base."
"AbstractMiddleware>` class that can be extended to create middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:174
msgid ""
"from typing import TYPE_CHECKING\n"
"from time import time\n"
"\n"
"from starlite import AbstractMiddleware, ScopeType\n"
"from starlite.datastructures import MutableScopeHeaders\n"
"\n"
"\n"
"if TYPE_CHECKING:\n"
"    from starlite.types import Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(AbstractMiddleware):\n"
"    scopes = {ScopeType.HTTP}\n"
"    exclude = [\"first_path\", \"second_path\"]\n"
"    exclude_opt_key = \"exclude_from_middleware\"\n"
"\n"
"    async def __call__(self, scope: \"Scope\", receive: \"Receive\", send: "
"\"Send\") -> None:\n"
"        start_time = time()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"                await send(message)\n"
"\n"
"        await self.app(scope, receive, send_wrapper)"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:203
msgid ""
"The three class variables defined in the above example ``scopes``, "
"``exclude`` and ``exclude_opt_key`` can be used to fine-tune for which "
"routes and request types the middleware is called:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:207
msgid ""
"The scopes variable is a set that can include either or both ``ScopeType."
"HTTP`` and ``ScopeType.WEBSOCKET`` , with the default being both."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:208
msgid ""
"``exclude`` accepts either a single string or list of strings that are "
"compiled into a regex against which the request's ``path`` is checked."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:209
msgid ""
"``exclude_opt_key`` is the key to use for in a route handler's ``opt`` dict "
"for a boolean, whether to omit from the middleware."
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:211
msgid ""
"Thus, in the following example, the middleware will only run against the "
"route handler called ``not_excluded_handler``:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:214
msgid ""
"from time import time\n"
"from typing import TYPE_CHECKING, Dict\n"
"\n"
"from starlite import AbstractMiddleware, ScopeType, Starlite, get, "
"websocket\n"
"from starlite.datastructures import MutableScopeHeaders\n"
"\n"
"if TYPE_CHECKING:\n"
"    from starlite import WebSocket\n"
"    from starlite.types import Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(AbstractMiddleware):\n"
"    scopes = {ScopeType.HTTP}\n"
"    exclude = [\"first_path\", \"second_path\"]\n"
"    exclude_opt_key = \"exclude_from_middleware\"\n"
"\n"
"    async def __call__(\n"
"        self,\n"
"        scope: \"Scope\",\n"
"        receive: \"Receive\",\n"
"        send: \"Send\",\n"
"    ) -> None:\n"
"        start_time = time()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"                await send(message)\n"
"\n"
"        await self.app(scope, receive, send_wrapper)\n"
"\n"
"\n"
"@websocket(\"/my-websocket\")\n"
"async def websocket_handler(socket: \"WebSocket\") -> None:\n"
"    \"\"\"\n"
"    Websocket handler - is excluded because the middleware scopes includes "
"'ScopeType.HTTP'\n"
"    \"\"\"\n"
"    await socket.accept()\n"
"    await socket.send_json({\"hello websocket\"})\n"
"    await socket.close()\n"
"\n"
"\n"
"@get(\"/first_path\")\n"
"def first_handler() -> Dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"first_path\"."
"\"\"\"\n"
"    return {\"hello\": \"first\"}\n"
"\n"
"\n"
"@get(\"/second_path\")\n"
"def second_handler() -> Dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"second_path\"."
"\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/third_path\", exclude_from_middleware=True)\n"
"def third_handler() -> Dict[str, str]:\n"
"    \"\"\"Handler is excluded due to the opt key 'exclude_from_middleware' "
"matching the middleware 'exclude_opt_key'.\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/greet\")\n"
"def not_excluded_handler() -> Dict[str, str]:\n"
"    \"\"\"This handler is not excluded, and thus the middleware will execute "
"on every incoming request to it.\"\"\"\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[\n"
"        websocket_handler,\n"
"        first_handler,\n"
"        second_handler,\n"
"        third_handler,\n"
"        not_excluded_handler,\n"
"    ],\n"
"    middleware=[MyMiddleware],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:214
msgid ""
"from time import time\n"
"from typing import TYPE_CHECKING\n"
"\n"
"from starlite import AbstractMiddleware, ScopeType, Starlite, get, "
"websocket\n"
"from starlite.datastructures import MutableScopeHeaders\n"
"\n"
"if TYPE_CHECKING:\n"
"    from starlite import WebSocket\n"
"    from starlite.types import Message, Receive, Scope, Send\n"
"\n"
"\n"
"class MyMiddleware(AbstractMiddleware):\n"
"    scopes = {ScopeType.HTTP}\n"
"    exclude = [\"first_path\", \"second_path\"]\n"
"    exclude_opt_key = \"exclude_from_middleware\"\n"
"\n"
"    async def __call__(\n"
"        self,\n"
"        scope: \"Scope\",\n"
"        receive: \"Receive\",\n"
"        send: \"Send\",\n"
"    ) -> None:\n"
"        start_time = time()\n"
"\n"
"        async def send_wrapper(message: \"Message\") -> None:\n"
"            if message[\"type\"] == \"http.response.start\":\n"
"                process_time = time() - start_time\n"
"                headers = MutableScopeHeaders.from_message(message=message)\n"
"                headers[\"X-Process-Time\"] = str(process_time)\n"
"                await send(message)\n"
"\n"
"        await self.app(scope, receive, send_wrapper)\n"
"\n"
"\n"
"@websocket(\"/my-websocket\")\n"
"async def websocket_handler(socket: \"WebSocket\") -> None:\n"
"    \"\"\"\n"
"    Websocket handler - is excluded because the middleware scopes includes "
"'ScopeType.HTTP'\n"
"    \"\"\"\n"
"    await socket.accept()\n"
"    await socket.send_json({\"hello websocket\"})\n"
"    await socket.close()\n"
"\n"
"\n"
"@get(\"/first_path\")\n"
"def first_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"first_path\"."
"\"\"\"\n"
"    return {\"hello\": \"first\"}\n"
"\n"
"\n"
"@get(\"/second_path\")\n"
"def second_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to regex pattern matching \"second_path\"."
"\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/third_path\", exclude_from_middleware=True)\n"
"def third_handler() -> dict[str, str]:\n"
"    \"\"\"Handler is excluded due to the opt key 'exclude_from_middleware' "
"matching the middleware 'exclude_opt_key'.\"\"\"\n"
"    return {\"hello\": \"second\"}\n"
"\n"
"\n"
"@get(\"/greet\")\n"
"def not_excluded_handler() -> dict[str, str]:\n"
"    \"\"\"This handler is not excluded, and thus the middleware will execute "
"on every incoming request to it.\"\"\"\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[\n"
"        websocket_handler,\n"
"        first_handler,\n"
"        second_handler,\n"
"        third_handler,\n"
"        not_excluded_handler,\n"
"    ],\n"
"    middleware=[MyMiddleware],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:219
msgid "Using DefineMiddleware to pass arguments"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:221
msgid ""
"Starlite offers a simple way to pass positional arguments (``*args``) and "
"key-word arguments (``**kwargs``) to middleware using the :class:"
"`DefineMiddleware <starlite.middleware.base.DefineMiddleware>` class. Let's "
"extend the factory function used in the examples above to take some args and "
"kwargs and then use ``DefineMiddleware`` to pass these values to our "
"middleware:"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:227
msgid ""
"from starlite.types import ASGIApp, Scope, Receive, Send\n"
"from starlite import Starlite, DefineMiddleware\n"
"\n"
"\n"
"def middleware_factory(my_arg: int, *, app: ASGIApp, my_kwarg: str) -> "
"ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # here we can use my_arg and my_kwarg for some purpose\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware\n"
"\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[...],\n"
"    middleware=[DefineMiddleware(middleware_factory, 1, my_kwarg=\"abc\")],\n"
")"
msgstr ""

#: ../../../usage/middleware/creating-middleware.rst:246
msgid ""
"The ``DefineMiddleware`` is a simple container - it takes a middleware "
"callable as a first parameter, and then any positional arguments, followed "
"by key word arguments. The middleware callable will be called with these "
"values as well as the kwarg ``app`` as mentioned above."
msgstr ""
