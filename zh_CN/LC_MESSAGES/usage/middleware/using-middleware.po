# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Starlite-API
# This file is distributed under the same license as the Starlite package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Starlite 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/middleware/using-middleware.rst:2
msgid "Using Middleware"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:4
msgid ""
"A middleware in Starlite is any callable that receives at least one kwarg "
"called ``app`` and returns an :class:`ASGIApp <starlite.types.ASGIApp>`. An "
"``ASGIApp`` is nothing but an async function that receives the ASGI "
"primitives ``scope`` , ``receive`` and ``send`` , and either calls the next "
"``ASGIApp`` or returns a response / handles the websocket connection."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:9
msgid ""
"For example, the following function can be used as a middleware because it "
"receives the ``app`` kwarg and returns an ``ASGIApp``:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:13
msgid ""
"from starlite.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:25
msgid ""
"We can then pass this middleware to the :class:`Starlite <.app.Starlite>` "
"instance, where it will be called on every request:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:29
msgid ""
"from starlite.types import ASGIApp, Scope, Receive, Send\n"
"from starlite import Starlite\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware\n"
"\n"
"\n"
"app = Starlite(route_handlers=[...], middleware=[middleware_factory])"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:45
msgid ""
"In the above example, Starlite will call the ``middleware_factory`` function "
"and pass to it ``app``. It's important to understand that this kwarg does "
"not designate the Starlite application but rather the next ``ASGIApp`` in "
"the stack. It will then insert the returned ``my_middleware`` function into "
"the stack of every route in the application - because we declared it on the "
"application level."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:50
msgid "Layered architecture"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:53
msgid ""
"Middlewares are part of Starlite's layered architecture* which means you can "
"set them on every layer of the application."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:56
msgid ""
"You can read more about this here: :ref:`usage/the-starlite-app:layered "
"architecture`"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:60
msgid "Middleware Call Order"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:62
msgid ""
"Since it's also possible to define multiple middlewares on every layer, the "
"call order for middlewares will be **top to bottom** and **left to right**. "
"This means for each layer, the middlewares will be called in the order they "
"have been passed, while the layers will be traversed in the usual order:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:74
msgid ""
"from typing import TYPE_CHECKING, List, Type\n"
"\n"
"from starlite import Controller, MiddlewareProtocol, Router, Starlite, "
"State, get\n"
"\n"
"if TYPE_CHECKING:\n"
"    from starlite.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"def create_test_middleware(middleware_id: int) -> Type[MiddlewareProtocol]:\n"
"    class TestMiddleware(MiddlewareProtocol):\n"
"        def __init__(self, app: \"ASGIApp\") -> None:\n"
"            self.app = app\n"
"\n"
"        async def __call__(self, scope: \"Scope\", receive: \"Receive\", "
"send: \"Send\") -> None:\n"
"            starlite_app = scope[\"app\"]\n"
"            starlite_app.state.setdefault(\"middleware_calls\", [])\n"
"            starlite_app.state[\"middleware_calls\"].append(middleware_id)\n"
"            await self.app(scope, receive, send)\n"
"\n"
"    return TestMiddleware\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    middleware = [create_test_middleware(4), create_test_middleware(5)]\n"
"\n"
"    @get(\n"
"        \"/handler\",\n"
"        middleware=[create_test_middleware(6), create_test_middleware(7)],\n"
"    )\n"
"    async def my_handler(self, state: State) -> List[int]:\n"
"        return state[\"middleware_calls\"]  # type: ignore\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    middleware=[create_test_middleware(2), create_test_middleware(3)],\n"
")\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[router],\n"
"    middleware=[create_test_middleware(0), create_test_middleware(1)],\n"
")\n"
"\n"
"\n"
"# run: /router/controller/handler"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:74
msgid ""
"from typing import TYPE_CHECKING\n"
"\n"
"from starlite import Controller, MiddlewareProtocol, Router, Starlite, "
"State, get\n"
"\n"
"if TYPE_CHECKING:\n"
"    from starlite.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"def create_test_middleware(middleware_id: int) -> type[MiddlewareProtocol]:\n"
"    class TestMiddleware(MiddlewareProtocol):\n"
"        def __init__(self, app: \"ASGIApp\") -> None:\n"
"            self.app = app\n"
"\n"
"        async def __call__(self, scope: \"Scope\", receive: \"Receive\", "
"send: \"Send\") -> None:\n"
"            starlite_app = scope[\"app\"]\n"
"            starlite_app.state.setdefault(\"middleware_calls\", [])\n"
"            starlite_app.state[\"middleware_calls\"].append(middleware_id)\n"
"            await self.app(scope, receive, send)\n"
"\n"
"    return TestMiddleware\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    middleware = [create_test_middleware(4), create_test_middleware(5)]\n"
"\n"
"    @get(\n"
"        \"/handler\",\n"
"        middleware=[create_test_middleware(6), create_test_middleware(7)],\n"
"    )\n"
"    async def my_handler(self, state: State) -> list[int]:\n"
"        return state[\"middleware_calls\"]  # type: ignore\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    middleware=[create_test_middleware(2), create_test_middleware(3)],\n"
")\n"
"\n"
"app = Starlite(\n"
"    route_handlers=[router],\n"
"    middleware=[create_test_middleware(0), create_test_middleware(1)],\n"
")\n"
"\n"
"\n"
"# run: /router/controller/handler"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:79
msgid "Middlewares and Exceptions"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:81
msgid ""
"When an exception is raised by a route handler or a :doc:`dependency </usage/"
"dependency-injection>` it will be transformed into a response by an "
"`exception handler <../../17-exceptions#exception-handling>`_. This response "
"will follow the normal \"flow\" of the application and therefore, "
"middlewares are still applied to it."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:86
msgid ""
"As with any good rule, there are exceptions to it. In this case they are two "
"exceptions raised by Starlite's ASGI router:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:90
msgid ""
":class:`NotFoundException <starlite.exceptions.http_exceptions."
"NotFoundException>`"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:91
msgid ""
":class:`MethodNotAllowedException <starlite.exceptions.http_exceptions."
"MethodNotAllowedException>`"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:93
msgid ""
"They are raised **before the middleware stack is called** and will only be "
"handled by exception handlers defined on the ``Starlite`` instance itself. "
"If you wish to modify error responses generated from these exception, you "
"will have to use an application layer exception handler."
msgstr ""
