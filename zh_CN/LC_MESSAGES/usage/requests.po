# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/requests.rst:2
msgid "Requests"
msgstr ""

#: ../../../usage/requests.rst:5
msgid "Request body"
msgstr ""

#: ../../../usage/requests.rst:7
msgid ""
"The body of HTTP requests can be accessed using the special ``data`` "
"parameter in a handler function."
msgstr ""

#: ../../../usage/requests.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/requests.rst:10
msgid ""
"from typing import Dict\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def index(data: Dict[str, str]) -> Dict[str, str]:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/requests.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/requests.rst:10
msgid ""
"from litestar import Litestar, post\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def index(data: dict[str, str]) -> dict[str, str]:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/requests.rst:13
msgid "The type of ``data`` can be any supported type, including"
msgstr ""

#: ../../../usage/requests.rst:16
msgid "Arbitrary stdlib types"
msgstr ""

#: ../../../usage/requests.rst:17
msgid ":class:`TypedDicts <typing.TypedDict>`"
msgstr ""

#: ../../../usage/requests.rst:18
msgid ":func:`dataclasses <dataclasses.dataclass>`"
msgstr ""

#: ../../../usage/requests.rst:19
msgid "Types supported via :doc:`plugins </usage/plugins/index>` ie."
msgstr ""

#: ../../../usage/requests.rst:20
msgid "`Msgspec Struct <https://jcristharif.com/msgspec/structs.html>`_"
msgstr ""

#: ../../../usage/requests.rst:21
msgid "`Pydantic models <https://docs.pydantic.dev/usage/models/>`_"
msgstr ""

#: ../../../usage/requests.rst:22
msgid "`Attrs classes <https://www.attrs.org/en/stable/>`_"
msgstr ""

#: ../../../usage/requests.rst:26
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def index(data: User) -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[index])"
msgstr ""

#: ../../../usage/requests.rst:30
msgid "Validation and customization of OpenAPI documentation"
msgstr ""

#: ../../../usage/requests.rst:32
msgid ""
"With the help of :class:`Body <litestar.params.Body>`, you have fine-grained "
"control over the validation of the request body, and can also customize the "
"OpenAPI documentation:"
msgstr ""

#: ../../../usage/requests.rst:0
msgid "example"
msgstr ""

#: ../../../usage/requests.rst:41
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_user(\n"
"    data: Annotated[User, Body(title=\"Create User\", description=\"Create a "
"new user.\")],\n"
") -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/requests.rst:41
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_user(\n"
"    data: Annotated[User, Body(title=\"Create User\", description=\"Create a "
"new user.\")],\n"
") -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/requests.rst:0
msgid "how to test"
msgstr ""

#: ../../../usage/requests.rst:46
msgid ""
"def test_request_data_3() -> None:\n"
"    with TestClient(app=app_3) as client:\n"
"        response = client.post(\"/\", json={\"id\": 1, \"name\": \"John\"})\n"
"        assert response.status_code == 201\n"
"        assert response.json() == {\"id\": 1, \"name\": \"John\"}\n"
"        schema = client.get(\"/schema/openapi.json\")\n"
"        assert \"Create a new user.\" in schema.json()[\"components\"]"
"[\"schemas\"][\"User\"][\"description\"]"
msgstr ""

#: ../../../usage/requests.rst:51
msgid "Content-type"
msgstr ""

#: ../../../usage/requests.rst:53
msgid ""
"By default, Litestar will try to parse the request body as JSON. While this "
"may be desired in most cases, you might want to specify a different type. "
"You can do so by passing a :class:`RequestEncodingType <litestar.enums."
"RequestEncodingType>` to ``Body``. This will also help to generate the "
"correct media-type in the OpenAPI schema."
msgstr ""

#: ../../../usage/requests.rst:59
msgid "URL Encoded Form Data"
msgstr ""

#: ../../../usage/requests.rst:61
msgid ""
"To access data sent as `url-encoded form data <https://developer.mozilla.org/"
"en-US/docs/Web/HTTP/Methods/POST>`_, i.e. ``application/x-www-form-"
"urlencoded`` Content-Type header, use :class:`Body <litestar.params.Body>` "
"and specify :class:`RequestEncodingType.URL_ENCODED <litestar.enums."
"RequestEncodingType>` as the ``media_type``:"
msgstr ""

#: ../../../usage/requests.rst:70
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_user(\n"
"    data: Annotated[User, Body(media_type=RequestEncodingType."
"URL_ENCODED)],\n"
") -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/requests.rst:70
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_user(\n"
"    data: Annotated[User, Body(media_type=RequestEncodingType."
"URL_ENCODED)],\n"
") -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/requests.rst:75
msgid ""
"def test_request_data_4() -> None:\n"
"    with TestClient(app=app_4) as client:\n"
"        response = client.post(\"/\", data={\"id\": 1, \"name\": \"John\"})\n"
"        assert response.status_code == 201\n"
"        assert response.json() == {\"id\": 1, \"name\": \"John\"}"
msgstr ""

#: ../../../usage/requests.rst:80
msgid ""
"URL encoded data is inherently less versatile than JSON data - for example, "
"it cannot handle complex dictionaries and deeply nested data. It should only "
"be used for simple data structures."
msgstr ""

#: ../../../usage/requests.rst:85
msgid "MultiPart Form Data"
msgstr ""

#: ../../../usage/requests.rst:87
msgid ""
"You can access data uploaded using a request with a `multipart/form-data "
"<https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST>`_ Content-"
"Type header by specifying it in the :class:`Body <litestar.params.Body>` "
"function:"
msgstr ""

#: ../../../usage/requests.rst:96
msgid ""
"from dataclasses import dataclass\n"
"from typing import Dict\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"    form_input_name: UploadFile\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_user(\n"
"    data: Annotated[User, Body(media_type=RequestEncodingType.MULTI_PART)],\n"
") -> Dict[str, str]:\n"
"    content = await data.form_input_name.read()\n"
"    filename = data.form_input_name.filename\n"
"    return {\"id\": data.id, \"name\": data.name, \"filename\": filename, "
"\"size\": len(content)}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/requests.rst:96
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: int\n"
"    name: str\n"
"    form_input_name: UploadFile\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_user(\n"
"    data: Annotated[User, Body(media_type=RequestEncodingType.MULTI_PART)],\n"
") -> dict[str, str]:\n"
"    content = await data.form_input_name.read()\n"
"    filename = data.form_input_name.filename\n"
"    return {\"id\": data.id, \"name\": data.name, \"filename\": filename, "
"\"size\": len(content)}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/requests.rst:101
msgid ""
"def test_request_data_5() -> None:\n"
"    with TestClient(app=app_5) as client:\n"
"        response = client.post(\n"
"            \"/\",\n"
"            files={\"form_input_name\": (\"filename\", BytesIO(b\"file "
"content\"))},\n"
"            data={\"id\": 1, \"name\": \"John\"},\n"
"        )\n"
"        assert response.status_code == 201\n"
"        assert response.json() == {\n"
"            \"id\": 1,\n"
"            \"name\": \"John\",\n"
"            \"filename\": \"filename\",\n"
"            \"size\": len(b\"file content\"),\n"
"        }"
msgstr ""

#: ../../../usage/requests.rst:106
msgid "File uploads"
msgstr ""

#: ../../../usage/requests.rst:108
msgid ""
"In case of files uploaded, Litestar transforms the results into an instance "
"of :class:`UploadFile <.datastructures.upload_file.UploadFile>` class, which "
"offer a convenient interface for working with files. Therefore, you need to "
"type your file uploads accordingly."
msgstr ""

#: ../../../usage/requests.rst:112
msgid ""
"To access a single file simply type ``data`` as :class:`UploadFile <."
"datastructures.upload_file.UploadFile>`:"
msgstr ""

#: ../../../usage/requests.rst:0
msgid "Async"
msgstr ""

#: ../../../usage/requests.rst:124
msgid ""
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, MediaType, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\", media_type=MediaType.TEXT)\n"
"async def handle_file_upload(\n"
"    data: Annotated[UploadFile, Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> str:\n"
"    content = await data.read()\n"
"    filename = data.filename\n"
"    return f\"{filename},length: {len(content)}\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:124
msgid ""
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, MediaType, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\", media_type=MediaType.TEXT)\n"
"async def handle_file_upload(\n"
"    data: Annotated[UploadFile, Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> str:\n"
"    content = await data.read()\n"
"    filename = data.filename\n"
"    return f\"{filename},length: {len(content)}\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:129
msgid ""
"def test_request_data_6() -> None:\n"
"    with TestClient(app=app_6) as client:\n"
"        response = client.post(\"/\", files={\"upload\": (\"hello\", "
"b\"world\")})\n"
"        assert response.status_code == 201\n"
"        assert response.text == f\"hello,length: {len(b'world')}\""
msgstr ""

#: ../../../usage/requests.rst:0
msgid "Sync"
msgstr ""

#: ../../../usage/requests.rst:139
msgid ""
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, MediaType, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\", media_type=MediaType.TEXT, sync_to_thread=False)\n"
"def handle_file_upload(\n"
"    data: Annotated[UploadFile, Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> str:\n"
"    content = data.file.read()\n"
"    filename = data.filename\n"
"    return f\"{filename},length: {len(content)}\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:139
msgid ""
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, MediaType, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\", media_type=MediaType.TEXT, sync_to_thread=False)\n"
"def handle_file_upload(\n"
"    data: Annotated[UploadFile, Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> str:\n"
"    content = data.file.read()\n"
"    filename = data.filename\n"
"    return f\"{filename},length: {len(content)}\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:144
msgid ""
"def test_request_data_7() -> None:\n"
"    with TestClient(app=app_7) as client:\n"
"        response = client.post(\"/\", files={\"upload\": (\"hello\", "
"b\"world\")})\n"
"        assert response.status_code == 201\n"
"        assert response.text == f\"hello,length: {len(b'world')}\""
msgstr ""

#: ../../../usage/requests.rst:147
msgid "Technical details"
msgstr ""

#: ../../../usage/requests.rst:150
msgid ""
":class:`UploadFile <.datastructures.UploadFile>` wraps :class:"
"`SpooledTemporaryFile <tempfile.SpooledTemporaryFile>` so it can be used "
"asynchronously. Inside a synchronous function we don't need this wrapper, so "
"we can use its :meth:`read <io.TextIOBase.read>` method directly."
msgstr ""

#: ../../../usage/requests.rst:157
msgid "Multiple files"
msgstr ""

#: ../../../usage/requests.rst:159
msgid ""
"To access multiple files with known filenames, you can use a pydantic model:"
msgstr ""

#: ../../../usage/requests.rst:167
msgid ""
"from typing import Dict\n"
"\n"
"from pydantic import BaseModel, ConfigDict\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"class FormData(BaseModel):\n"
"    model_config = ConfigDict(arbitrary_types_allowed=True)\n"
"    cv: UploadFile\n"
"    diploma: UploadFile\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def handle_file_upload(\n"
"    data: Annotated[FormData, Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> Dict[str, str]:\n"
"    cv_content = await data.cv.read()\n"
"    diploma_content = await data.diploma.read()\n"
"\n"
"    return {\"cv\": cv_content.decode(), \"diploma\": diploma_content."
"decode()}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:167
msgid ""
"from pydantic import BaseModel, ConfigDict\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"class FormData(BaseModel):\n"
"    model_config = ConfigDict(arbitrary_types_allowed=True)\n"
"    cv: UploadFile\n"
"    diploma: UploadFile\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def handle_file_upload(\n"
"    data: Annotated[FormData, Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> dict[str, str]:\n"
"    cv_content = await data.cv.read()\n"
"    diploma_content = await data.diploma.read()\n"
"\n"
"    return {\"cv\": cv_content.decode(), \"diploma\": diploma_content."
"decode()}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:172
msgid ""
"def test_request_data_8() -> None:\n"
"    with TestClient(app=app_8) as client:\n"
"        response = client.post(\n"
"            \"/\", files={\"cv\": (\"cv.odf\", b\"very impressive\"), "
"\"diploma\": (\"diploma.pdf\", b\"the best\")}\n"
"        )\n"
"        assert response.status_code == 201\n"
"        assert response.json() == {\"cv\": \"very impressive\", \"diploma\": "
"\"the best\"}"
msgstr ""

#: ../../../usage/requests.rst:177
msgid "Files as a dictionary"
msgstr ""

#: ../../../usage/requests.rst:179
msgid ""
"If you do not care about parsing and validation and only want to access the "
"form data as a dictionary, you can use a ``dict`` instead:"
msgstr ""

#: ../../../usage/requests.rst:186
msgid ""
"from typing import Dict\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def handle_file_upload(\n"
"    data: Annotated[Dict[str, UploadFile], "
"Body(media_type=RequestEncodingType.MULTI_PART)],\n"
") -> Dict[str, str]:\n"
"    file_contents = {}\n"
"    for name, file in data.items():\n"
"        content = await file.read()\n"
"        file_contents[file.filename] = len(content)\n"
"\n"
"    return file_contents\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:186
msgid ""
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def handle_file_upload(\n"
"    data: Annotated[dict[str, UploadFile], "
"Body(media_type=RequestEncodingType.MULTI_PART)],\n"
") -> dict[str, str]:\n"
"    file_contents = {}\n"
"    for name, file in data.items():\n"
"        content = await file.read()\n"
"        file_contents[file.filename] = len(content)\n"
"\n"
"    return file_contents\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:191
msgid ""
"def test_request_data_9() -> None:\n"
"    with TestClient(app=app_9) as client:\n"
"        response = client.post(\"/\", files={\"hello\": (\"filename\", "
"b\"there\"), \"i'm\": (\"another_filename\", \"steve\")})\n"
"        assert response.status_code == 201\n"
"        assert response.json() == {\n"
"            \"filename\": len(b\"there\"),\n"
"            \"another_filename\": len(b\"steve\"),\n"
"        }"
msgstr ""

#: ../../../usage/requests.rst:196
msgid "Files as a list"
msgstr ""

#: ../../../usage/requests.rst:198
msgid "Finally, you can also access the files as a list without the filenames:"
msgstr ""

#: ../../../usage/requests.rst:205
msgid ""
"from typing import Any, Dict, List, Tuple\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def handle_file_upload(\n"
"    data: Annotated[List[UploadFile], Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> Dict[str, Tuple[str, str, Any]]:\n"
"    result = {}\n"
"\n"
"    for file in data:\n"
"        content = await file.read()\n"
"        result[file.filename] = (len(content), file.content_type, file."
"headers)\n"
"\n"
"    return result\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:205
msgid ""
"from typing import Any\n"
"\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.datastructures import UploadFile\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def handle_file_upload(\n"
"    data: Annotated[list[UploadFile], Body(media_type=RequestEncodingType."
"MULTI_PART)],\n"
") -> dict[str, tuple[str, str, Any]]:\n"
"    result = {}\n"
"\n"
"    for file in data:\n"
"        content = await file.read()\n"
"        result[file.filename] = (len(content), file.content_type, file."
"headers)\n"
"\n"
"    return result\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handle_file_upload])"
msgstr ""

#: ../../../usage/requests.rst:210
msgid ""
"def test_request_data_10() -> None:\n"
"    with TestClient(app=app_10) as client:\n"
"        # if you pass a dict to the `files` parameter without specifying a "
"filename, it will default to `upload\n"
"        # so in this app it will be return the last one only...\n"
"        #     # file (or bytes)\n"
"        response = client.post(\n"
"            \"/\",\n"
"            files={\n"
"                \"will default to upload\": io.BytesIO(b\"hello world\"),\n"
"                \"will default to upload also\": io.BytesIO(b\"another\"),\n"
"            },\n"
"        )\n"
"        assert response.status_code == 201\n"
"        assert response.json().get(\"upload\")[0] != len(b\"hello world\")\n"
"        assert response.json().get(\"upload\")[0] == len(b\"another\")\n"
"\n"
"        # if you pass the filename explicitly, it will be used as the "
"filename\n"
"        #     # (filename, file (or bytes))\n"
"        response = client.post(\"/\", files={\"file\": (\"hello.txt\", io."
"BytesIO(b\"hello\"))})\n"
"        assert response.status_code == 201\n"
"        assert response.json().get(\"hello.txt\")[0] == len(b\"hello\")\n"
"\n"
"        # if you add the content type, it will be used as the content type\n"
"        #     # (filename, file (or bytes), content_type)\n"
"        response = client.post(\"/\", files={\"file\": (\"hello.txt\", io."
"BytesIO(b\"hello\"), \"application/x-bittorrent\")})\n"
"        assert response.status_code == 201\n"
"        assert response.json().get(\"hello.txt\")[0] == len(b\"hello\")\n"
"        assert response.json().get(\"hello.txt\")[1] == \"application/x-"
"bittorrent\"\n"
"\n"
"        # finally you can specify headers like so\n"
"        #     # (filename, file (or bytes), content_type, headers)\n"
"        response = client.post(\n"
"            \"/\", files={\"file\": (\"hello.txt\", io.BytesIO(b\"hello\"), "
"\"application/x-bittorrent\", {\"X-Foo\": \"bar\"})}\n"
"        )"
msgstr ""

#: ../../../usage/requests.rst:214
msgid "MessagePack data"
msgstr ""

#: ../../../usage/requests.rst:216
msgid ""
"To receive `MessagePack <https://msgpack.org/>`_ data, specify the "
"appropriate ``Content-Type`` for ``Body``\\ , by using :class:"
"`RequestEncodingType.MESSAGEPACK <.enums.RequestEncodingType>`:"
msgstr ""

#: ../../../usage/requests.rst:224
msgid ""
"from typing import Any, Dict\n"
"\n"
"from typing_extensions import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\", sync_to_thread=False)\n"
"def msgpack_handler(\n"
"    data: Annotated[Dict[str, Any], Body(media_type=RequestEncodingType."
"MESSAGEPACK)],\n"
") -> Dict[str, Any]:\n"
"    # This will try to parse the request body as `MessagePack` regardless of "
"the\n"
"    # `Content-Type`\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[msgpack_handler])"
msgstr ""

#: ../../../usage/requests.rst:224
msgid ""
"from typing import Any\n"
"\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.enums import RequestEncodingType\n"
"from litestar.params import Body\n"
"\n"
"\n"
"@post(path=\"/\", sync_to_thread=False)\n"
"def msgpack_handler(\n"
"    data: Annotated[dict[str, Any], Body(media_type=RequestEncodingType."
"MESSAGEPACK)],\n"
") -> dict[str, Any]:\n"
"    # This will try to parse the request body as `MessagePack` regardless of "
"the\n"
"    # `Content-Type`\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[msgpack_handler])"
msgstr ""

#: ../../../usage/requests.rst:229
msgid ""
"        assert response.json().get(\"hello.txt\")[1] == \"application/x-"
"bittorrent\"\n"
"        assert (\"X-Foo\", \"bar\") in response.json().get(\"hello.txt\")[2]."
"items()\n"
"\n"
"\n"
"def test_msgpack_app() -> None:\n"
"    test_data = {\"name\": \"Moishe Zuchmir\", \"age\": 30, \"programmer\": "
"True}"
msgstr ""

#: ../../../usage/requests.rst:233
msgid "Custom Request"
msgstr ""

#: ../../../usage/requests.rst:237
msgid ""
"Litestar supports custom ``request_class`` instances, which can be used to "
"further configure the default :class:`Request`. The example below "
"illustrates how to implement custom request class for the whole application."
msgstr ""

#: ../../../usage/requests.rst:0
msgid "Example of a custom request at the application level"
msgstr ""

#: ../../../usage/requests.rst:247
msgid ""
"from litestar import Litestar, Request, get\n"
"from litestar.connection.base import empty_receive, empty_send\n"
"from litestar.enums import HttpMethod\n"
"from litestar.types import Receive, Scope, Send\n"
"\n"
"KITTEN_NAMES_MAP = {\n"
"    HttpMethod.GET: \"Whiskers\",\n"
"}\n"
"\n"
"\n"
"class CustomRequest(Request):\n"
"    \"\"\"Enrich request with the kitten name.\"\"\"\n"
"\n"
"    __slots__ = (\"kitten_name\",)\n"
"\n"
"    def __init__(self, scope: Scope, receive: Receive = empty_receive, send: "
"Send = empty_send) -> None:\n"
"        \"\"\"Initialize CustomRequest class.\"\"\"\n"
"        super().__init__(scope=scope, receive=receive, send=send)\n"
"        self.kitten_name = KITTEN_NAMES_MAP.get(scope[\"method\"], "
"\"Mittens\")\n"
"\n"
"\n"
"@get(path=\"/kitten-name\", sync_to_thread=False)\n"
"def get_kitten_name(request: CustomRequest) -> str:\n"
"    \"\"\"Get kitten name based on the HTTP method.\"\"\"\n"
"    return request.kitten_name\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[get_kitten_name],\n"
"    request_class=CustomRequest,\n"
"    debug=True,\n"
")"
msgstr ""

#: ../../../usage/requests.rst:252
msgid ""
"        response = client.post(\"/\", content=encode_msgpack(test_data))\n"
"        assert response.json() == test_data"
msgstr ""

#: ../../../usage/requests.rst:255
msgid "Layered architecture"
msgstr ""

#: ../../../usage/requests.rst:257
msgid ""
"Request classes are part of Litestar's layered architecture, which means you "
"can set a request class on every layer of the application. If you have set a "
"request class on multiple layers, the layer closest to the route handler "
"will take precedence."
msgstr ""

#: ../../../usage/requests.rst:261
msgid ""
"You can read more about this in the :ref:`usage/applications:layered "
"architecture` section"
msgstr ""

#: ../../../usage/requests.rst:265
msgid "Limits"
msgstr ""

#: ../../../usage/requests.rst:268
msgid "Body size"
msgstr ""

#: ../../../usage/requests.rst:270
msgid ""
"A limit for the allowed request body size can be set on all layers via the "
"``request_max_body_size`` parameter and defaults to 10MB. If a request body "
"exceeds this limit, a ``413 - Request Entity Too Large`` response will be "
"returned. This limit applies to all methods of consuming the request body, "
"including requesting it via the ``body`` parameter in a route handler and "
"consuming it through a manually constructed :class:`~litestar.connection."
"Request` instance, e.g. in a middleware."
msgstr ""

#: ../../../usage/requests.rst:278
msgid ""
"To disable this limit for a specific handler / router / controller, it can "
"be set to :obj:`None`."
msgstr ""

#: ../../../usage/requests.rst:282
msgid ""
"Setting ``request_max_body_size=None`` is strongly discouraged as it exposes "
"the application to a denial of service (DoS) attack by sending arbitrarily "
"large request bodies to the affected endpoint. Because Litestar has to read "
"the whole body to perform certain actions, such as parsing JSON, it will "
"fill up all the available memory / swap until the application / server "
"crashes, should no outside limits be imposed."
msgstr ""

#: ../../../usage/requests.rst:289
msgid ""
"This is generally only recommended in environments where the application is "
"running behind a reverse proxy such as NGINX, where a size limit is already "
"set."
msgstr ""

#: ../../../usage/requests.rst:294
msgid ""
"Since ``request_max_body_size`` is handled on a per-request basis, it won't "
"affect middlewares or ASGI handlers when they try to access the request body "
"via the raw ASGI events. To avoid this, middlewares and ASGI handlers should "
"construct a :class:`~litestar.connection.Request` instance and use the "
"regular :meth:`~litestar.connection.Request.stream` / :meth:`~litestar."
"connection.Request.body` or content-appropriate method to consume the "
"request body in a safe manner."
msgstr ""

#: ../../../usage/requests.rst:304
msgid ""
"For requests that define a ``Content-Length`` header, Litestar will not "
"attempt to read the request body should the header value exceed the "
"``request_max_body_size``."
msgstr ""

#: ../../../usage/requests.rst:307
msgid ""
"If the header value is within the allowed bounds, Litestar will verify "
"during the streaming of the request body that it does not exceed the size "
"specified in the header. Should the request exceed this size, it will abort "
"the request with a ``400 - Bad Request``."
msgstr ""
