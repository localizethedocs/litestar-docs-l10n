# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/dto/1-abstract-dto.rst:2
msgid "AbstractDTO"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:4
msgid ""
"Litestar maintains a suite of DTO factory types that can be used to create "
"DTOs for use with popular data modelling libraries, such as ORMs. These take "
"a model type as a generic type argument, and create subtypes of :class:"
"`AbstractDTO <litestar.dto.base_dto.AbstractDTO>` that support conversion of "
"that model type to and from raw bytes."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:9
msgid "The following factories are currently available:"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:11
msgid ":class:`DataclassDTO <litestar.dto.dataclass_dto.DataclassDTO>`"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:12
msgid ":class:`MsgspecDTO <litestar.dto.msgspec_dto.MsgspecDTO>`"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:13
msgid ":class:`PydanticDTO <litestar.plugins.pydantic.PydanticDTO>`"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:14
msgid ""
":class:`SQLAlchemyDTO <advanced_alchemy.extensions.litestar.dto."
"SQLAlchemyDTO>`"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:17
msgid "Using DTO Factories"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:19
msgid ""
"DTO factories are used to create DTOs for use with a particular data "
"modelling library. The following example creates a DTO for use with a "
"SQLAlchemy model:"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:23
msgid "A SQLAlchemy model DTO"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:23
msgid ""
"from datetime import datetime\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, post\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    # `Base` defines `id` field as:\n"
"    # id: Mapped[UUID] = mapped_column(default=uuid4, primary_key=True)\n"
"    name: Mapped[str]\n"
"    password: Mapped[str]\n"
"    created_at: Mapped[datetime]\n"
"\n"
"\n"
"UserDTO = SQLAlchemyDTO[User]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def create_user(data: User) -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"name\":\"Litestar User\",\"password\":\"xyz\",\"created_at\":"
"\"2023-04-24T00:00:00Z\"}\n"
"{\"id\":\"52105f49-96cf-4de9-ba78-78885697d85e\",\"name\":\"Litestar User\","
"\"password\":\"xyz\",\"created_at\":\"2023-04-24T00:00:00Z\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:26
msgid ""
"Here we see that a SQLAlchemy model is used as both the ``data`` and return "
"annotation for the handler, and while Litestar does not natively support "
"encoding/decoding to/from SQLAlchemy models, through :class:`SQLAlchemyDTO "
"<advanced_alchemy.extensions.litestar.dto.SQLAlchemyDTO>` we can do this."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:30
msgid ""
"However, we do have some issues with the above example. Firstly, the user's "
"password has been returned to them in the response from the handler. "
"Secondly, the user is able to set the ``created_at`` field on the model, "
"which should only ever be set once, and defined internally."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:34
msgid "Let's explore how we can configure DTOs to manage scenarios like these."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:39
#: ../../../usage/dto/1-abstract-dto.rst:48
msgid "Marking fields"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:41
msgid ""
"The :func:`dto_field <litestar.dto.field.dto_field>` function can be used to "
"mark model attributes with DTO-based configuration."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:44
msgid ""
"Fields marked as ``\"private\"`` or ``\"read-only\"`` will not be parsed "
"from client data into the user model, and ``\"private\"`` fields are never "
"serialized into return data."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:48
msgid ""
"from datetime import datetime\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import dto_field\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    # `Base` defines `id` field as:\n"
"    # id: Mapped[UUID] = mapped_column(default=uuid4, primary_key=True)\n"
"    name: Mapped[str]\n"
"    password: Mapped[str] = mapped_column(info=dto_field(\"private\"))\n"
"    created_at: Mapped[datetime] = mapped_column(info=dto_field(\"read-"
"only\"))\n"
"\n"
"\n"
"UserDTO = SQLAlchemyDTO[User]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def create_user(data: User) -> User:\n"
"    # even though the client did not send the id field,\n"
"    # since it is a primary key it is autogenerated\n"
"    assert \"id\" in vars(data)\n"
"    # even though the client sent the password and created_at field, it is "
"not in the data object\n"
"    assert \"password\" not in vars(data)\n"
"    assert \"created_at\" not in vars(data)\n"
"    # normally the database would set the created_at timestamp\n"
"    data.created_at = datetime.min\n"
"    return data  # the response includes the created_at field\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"name\":\"Litestar User\",\"password\":\"xyz\",\"created_at\":"
"\"2023-04-24T00:00:00Z\"}\n"
"{\"created_at\":\"0001-01-01T00:00:00\",\"id\":\"c8faf3de-4dcb-4163-8172-"
"c1b5d1db3341\",\"name\":\"Litestar User\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:53
msgid ""
"Note that ``id`` field is the primary key and is handled specially by the "
"defined SQLAlchemy base."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:62
#: ../../../usage/dto/1-abstract-dto.rst:70
msgid "Excluding fields"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:64
msgid ""
"Fields can be explicitly excluded using :class:`DTOConfig <litestar.dto."
"config.DTOConfig>`."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:66
msgid ""
"The following example demonstrates excluding attributes from the serialized "
"response, including excluding fields from nested models."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:70
msgid ""
"from datetime import datetime\n"
"from typing import Annotated\n"
"from uuid import UUID\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy import ForeignKey\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DTOConfig, dto_field\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class Address(Base):\n"
"    street: Mapped[str]\n"
"    city: Mapped[str]\n"
"    state: Mapped[str]\n"
"    zip: Mapped[str]\n"
"\n"
"\n"
"class Pets(Base):\n"
"    name: Mapped[str]\n"
"    user_id: Mapped[UUID] = mapped_column(ForeignKey(\"user.id\"))\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str] = mapped_column(info=dto_field(\"private\"))\n"
"    created_at: Mapped[datetime] = mapped_column(info=dto_field(\"read-"
"only\"))\n"
"    address_id: Mapped[UUID] = mapped_column(ForeignKey(\"address.id\"), "
"info=dto_field(\"private\"))\n"
"    address: Mapped[Address] = relationship(info=dto_field(\"read-only\"))\n"
"    pets: Mapped[list[Pets]] = relationship(info=dto_field(\"read-only\"))\n"
"\n"
"\n"
"UserDTO = SQLAlchemyDTO[User]\n"
"config = DTOConfig(\n"
"    exclude={\n"
"        \"id\",\n"
"        \"address.id\",\n"
"        \"address.street\",\n"
"        \"pets.0.id\",\n"
"        \"pets.0.user_id\",\n"
"    }\n"
")\n"
"ReadUserDTO = SQLAlchemyDTO[Annotated[User, config]]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO, return_dto=ReadUserDTO, "
"sync_to_thread=False)\n"
"def create_user(data: User) -> User:\n"
"    data.created_at = datetime.min\n"
"    data.address = Address(street=\"123 Main St\", city=\"Anytown\", "
"state=\"NY\", zip=\"12345\")\n"
"    data.pets = [Pets(id=1, name=\"Fido\"), Pets(id=2, name=\"Spot\")]\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"name\":\"Litestar User\",\"password\":\"xyz\",\"created_at\":"
"\"2023-04-24T00:00:00Z\"}\n"
"{\"created_at\":\"0001-01-01T00:00:00\",\"address\":{\"city\":\"Anytown\","
"\"state\":\"NY\",\"zip\":\"12345\"},\"pets\":[{\"name\":\"Fido\"},{\"name\":"
"\"Spot\"}],\"name\":\"Litestar User\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:75
msgid ""
"Here, the config is created with the exclude parameter, which is a set of "
"strings. Each string represents the path to a field in the ``User`` object "
"that should be excluded from the output DTO."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:79
msgid ""
"config = DTOConfig(\n"
"    exclude={\n"
"        \"id\",\n"
"        \"address.id\",\n"
"        \"address.street\",\n"
"        \"pets.0.id\",\n"
"        \"pets.0.user_id\",\n"
"    }\n"
")"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:90
msgid ""
"In this example, ``\"id\"`` represents the id field of the ``User`` object, "
"``\"address.id\"`` and ``\"address.street\"`` represent fields of the "
"``Address`` object nested inside the ``User`` object, and ``\"pets.0.id\"`` "
"and ``\"pets.0.user_id\"`` represent fields of the ``Pets`` objects nested "
"within the list of ``User.pets``."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:96
msgid ""
"Given a generic type, with an arbitrary number of type parameters (e.g., "
"``GenericType[Type0, Type1, ..., TypeN]``), we use the index of the type "
"parameter to indicate which type the exclusion should refer to. For example, "
"``a.0.b``, excludes the ``b`` field from the first type parameter of ``a``, "
"``a.1.b`` excludes the ``b`` field from the second type parameter of ``a``, "
"and so on."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:102
#: ../../../usage/dto/1-abstract-dto.rst:108
#: ../../../usage/dto/1-abstract-dto.rst:116
msgid "Renaming fields"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:104
msgid ""
"Fields can be renamed using :class:`DTOConfig <litestar.dto.config."
"DTOConfig>`. The following example uses the name ``userName`` client-side, "
"and ``user`` internally."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:108
msgid ""
"from datetime import datetime\n"
"from typing import Annotated\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DTOConfig, dto_field\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str] = mapped_column(info=dto_field(\"private\"))\n"
"    created_at: Mapped[datetime] = mapped_column(info=dto_field(\"read-"
"only\"))\n"
"\n"
"\n"
"config = DTOConfig(rename_fields={\"name\": \"userName\"})\n"
"UserDTO = SQLAlchemyDTO[Annotated[User, config]]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def create_user(data: User) -> User:\n"
"    assert data.name == \"Litestar User\"\n"
"    data.created_at = datetime.min\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"userName\":\"Litestar User\",\"password\":\"xyz\",\"created_at\":"
"\"2023-04-24T00:00:00Z\"}\n"
"{\"created_at\":\"0001-01-01T00:00:00\",\"id\":"
"\"0d0fe35a-9acd-41a4-819d-422d48e8d301\",\"userName\":\"Litestar User\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:113
msgid ""
"Fields can also be renamed using a renaming strategy that will be applied to "
"all fields. The following example uses a pre-defined rename strategy that "
"will convert all field names to camel case on client-side."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:116
msgid ""
"from datetime import datetime\n"
"from typing import Annotated\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DTOConfig, dto_field\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    first_name: Mapped[str]\n"
"    password: Mapped[str] = mapped_column(info=dto_field(\"private\"))\n"
"    created_at: Mapped[datetime] = mapped_column(info=dto_field(\"read-"
"only\"))\n"
"\n"
"\n"
"config = DTOConfig(rename_strategy=\"camel\")\n"
"# another rename strategy with a custom callback:\n"
"# config = DTOConfig(rename_strategy=lambda x: f\"-{x}-\")\n"
"UserDTO = SQLAlchemyDTO[Annotated[User, config]]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def create_user(data: User) -> User:\n"
"    assert data.first_name == \"Litestar User\"\n"
"    data.created_at = datetime.min\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"firstName\":\"Litestar User\",\"password\":\"xyz\",\"createdAt\":"
"\"2023-04-24T00:00:00Z\"}\n"
"{\"createdAt\":\"0001-01-01T00:00:00\",\"id\":\"bf696f80-3247-4f15-809d-"
"e7d73269676c\",\"firstName\":\"Litestar User\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:121
msgid ""
"Fields that are directly renamed using `rename_fields` mapping will be "
"excluded from `rename_strategy`."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:123
msgid ""
"The rename strategy either accepts one of the pre-defined strategies: "
"\"camel\", \"pascal\", \"upper\", \"lower\", \"kebab\", or it can be "
"provided a callback that accepts the field name as a string argument and "
"should return a string."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:126
#: ../../../usage/dto/1-abstract-dto.rst:133
#: ../../../usage/dto/1-abstract-dto.rst:155
#: ../../../usage/dto/1-abstract-dto.rst:176
msgid "Type checking"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:128
msgid ""
"Factories check that the types to which they are assigned are a subclass of "
"the type provided as the generic type to the DTO factory. This means that if "
"you have a handler that accepts a ``User`` model, and you assign a "
"``UserDTO`` factory to it, the DTO will only accept ``User`` types for "
"\"data\" and return types."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:133
msgid ""
"from datetime import datetime\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped, mapped_column\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import dto_field\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str] = mapped_column(info=dto_field(\"private\"))\n"
"    created_at: Mapped[datetime] = mapped_column(info=dto_field(\"read-"
"only\"))\n"
"\n"
"\n"
"class Foo(Base):\n"
"    foo: Mapped[str]\n"
"\n"
"\n"
"UserDTO = SQLAlchemyDTO[User]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO)\n"
"def create_user(data: Foo) -> Foo:\n"
"    return data\n"
"\n"
"\n"
"# This will raise an exception at handler registration time.\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:138
msgid ""
"In the above example, the handler is declared to use ``UserDTO`` which has "
"been type-narrowed with the ``User`` type. However, we annotate the handler "
"with the ``Foo`` type. This will raise an error such as this at runtime:"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:141
msgid ""
"litestar.exceptions.dto.InvalidAnnotationException: DTO narrowed with "
"'<class 'docs.examples.data_transfer_objects.factory.type_checking.User'>', "
"handler type is '<class 'docs.examples.data_transfer_objects.factory."
"type_checking.Foo'>'"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:146
msgid "Nested fields"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:148
msgid ""
"The depth of related items parsed from client data and serialized into "
"return data can be controlled using the ``max_nested_depth`` parameter to :"
"class:`DTOConfig <litestar.dto.config.DTOConfig>`."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:151
msgid ""
"In this example, we set ``max_nested_depth=0`` for the DTO that handles "
"inbound client data, and leave it at the default of ``1`` for the return DTO."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:155
msgid ""
"from __future__ import annotations\n"
"\n"
"from typing import Annotated\n"
"from uuid import UUID\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy import ForeignKey\n"
"from sqlalchemy.orm import Mapped, mapped_column, relationship\n"
"\n"
"from litestar import Litestar, put\n"
"from litestar.dto import DTOConfig\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class A(Base):\n"
"    b_id: Mapped[UUID] = mapped_column(ForeignKey(\"b.id\"))\n"
"    b: Mapped[B] = relationship(back_populates=\"a\")\n"
"\n"
"\n"
"class B(Base):\n"
"    a: Mapped[A] = relationship(back_populates=\"b\")\n"
"\n"
"\n"
"data_config = DTOConfig(max_nested_depth=0)\n"
"DataDTO = SQLAlchemyDTO[Annotated[A, data_config]]\n"
"\n"
"# default config sets max_nested_depth to 1\n"
"ReturnDTO = SQLAlchemyDTO[A]\n"
"\n"
"\n"
"@put(\"/a\", dto=DataDTO, return_dto=ReturnDTO, sync_to_thread=False)\n"
"def update_a(data: A) -> A:\n"
"    # this shows that \"b\" was not parsed out of the inbound data\n"
"    assert \"b\" not in vars(data)\n"
"    # Now we'll create an instance of B and assign it\"\n"
"    # This includes a reference back to ``a`` which is not serialized in the "
"return data\n"
"    # because default ``max_nested_depth`` is set to 1\n"
"    data.b = B(id=data.b_id, a=data)\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[update_a])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/a -H Content-Type: application/json -X PUT -d "
"{\"id\": \"6955e63c-c2bc-4707-8fa4-2144d1764746\", \"b_id\": "
"\"9cf3518d-7e19-4215-9ec2-e056cac55bf7\", \"b\": {\"id\": "
"\"9cf3518d-7e19-4215-9ec2-e056cac55bf7\"}}\n"
"{\"b_id\":\"9cf3518d-7e19-4215-9ec2-e056cac55bf7\",\"b\":{\"id\":"
"\"9cf3518d-7e19-4215-9ec2-e056cac55bf7\"},\"id\":\"6955e63c-"
"c2bc-4707-8fa4-2144d1764746\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:160
msgid ""
"When the handler receives the client data, we can see that the ``b`` field "
"has not been parsed into the ``A`` model that is injected for our data "
"parameter (line 35)."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:163
msgid ""
"We then add a ``B`` instance to the data (line 39), which includes a "
"reference back to ``a``, and from inspection of the return data can see that "
"``b`` is included in the response data, however ``b.a`` is not, due to the "
"default ``max_nested_depth`` of ``1``."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:168
msgid "Handling unknown fields"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:170
msgid ""
"By default, DTOs will silently ignore unknown fields in the source data. "
"This behaviour can be configured using the ``forbid_unknown_fields`` "
"parameter of the :class:`DTOConfig <litestar.dto.config.DTOConfig>`. When "
"set to ``True`` a validation error response will be returned if the data "
"contains a field not defined on the model:"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:176
msgid ""
"from __future__ import annotations\n"
"\n"
"from dataclasses import dataclass\n"
"from typing import Annotated\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DataclassDTO, DTOConfig\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    id: str\n"
"\n"
"\n"
"UserDTO = DataclassDTO[Annotated[User, "
"DTOConfig(forbid_unknown_fields=True)]]\n"
"\n"
"\n"
"@post(\"/users\", dto=UserDTO)\n"
"async def create_user(data: User) -> User:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar([create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"id\": \"1\", \"name\": \"Peter\"}\n"
"{\"status_code\":400,\"detail\":\"Object contains unknown field `name`\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:182
msgid "DTO Data"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:184
msgid ""
"Sometimes we need to be able to access the data that has been parsed and "
"validated by the DTO, but not converted into an instance of our data model."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:187
msgid ""
"In the following example, we create a ``User`` model, that is a :func:"
"`dataclass <dataclasses.dataclass>` with 3 required fields: ``id``, "
"``name``, and ``age``."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:190
msgid ""
"We also create a DTO that doesn't allow clients to set the ``id`` field on "
"the ``User`` model and set it on the handler."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:194
msgid ""
"from __future__ import annotations\n"
"\n"
"from dataclasses import dataclass, field\n"
"from uuid import UUID, uuid4\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DataclassDTO, DTOConfig\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    name: str\n"
"    email: str\n"
"    age: int\n"
"    id: UUID = field(default_factory=uuid4)\n"
"\n"
"\n"
"class UserWriteDTO(DataclassDTO[User]):\n"
"    \"\"\"Don't allow client to set the id.\"\"\"\n"
"\n"
"    config = DTOConfig(exclude={\"id\"})\n"
"\n"
"\n"
"# We need a dto for the handler to parse the request data per the "
"configuration, however,\n"
"# we don't need a return DTO as we are returning a dataclass, and Litestar "
"already knows\n"
"# how to serialize dataclasses.\n"
"@post(\"/users\", dto=UserWriteDTO, return_dto=None, sync_to_thread=False)\n"
"def create_user(data: User) -> User:\n"
"    \"\"\"Create an user.\"\"\"\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"name\":\"Peter\",\"email\": \"peter@example.com\", \"age\":41}\n"
"{\"name\":\"Peter\",\"email\":\"peter@example.com\",\"age\":41,\"id\":"
"\"c75f6b81-f351-4562-9cf2-2a18b25f9761\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:198
msgid ""
"Notice that our `User` model has a model-level ``default_factory=uuid4`` for "
"``id`` field. That's why we can decode the client data into this model."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:201
msgid ""
"However, in some cases there's no clear way to provide a default this way."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:203
msgid ""
"One way to handle this is to create different models, e.g., we might create "
"a ``UserCreate`` model that has no ``id`` field, and decode the client data "
"into that. However, this method can become quite cumbersome when we have a "
"lot of variability in the data that we accept from clients, for example, "
"`PATCH <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH>`_ "
"requests."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:208
msgid ""
"This is where the :class:`DTOData <litestar.dto.data_structures.DTOData>` "
"class comes in. It is a generic class that accepts the type of the data that "
"it will contain, and provides useful methods for interacting with that data."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:212
msgid ""
"from dataclasses import dataclass\n"
"from uuid import UUID, uuid4\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DataclassDTO, DTOConfig, DTOData\n"
"\n"
"\n"
"@dataclass\n"
"class User:\n"
"    name: str\n"
"    email: str\n"
"    age: int\n"
"    id: UUID\n"
"\n"
"\n"
"class UserWriteDTO(DataclassDTO[User]):\n"
"    \"\"\"Don't allow client to set the id.\"\"\"\n"
"\n"
"    config = DTOConfig(exclude={\"id\"})\n"
"\n"
"\n"
"@post(\"/users\", dto=UserWriteDTO, return_dto=None, sync_to_thread=False)\n"
"def create_user(data: DTOData[User]) -> User:\n"
"    \"\"\"Create an user.\"\"\"\n"
"    return data.create_instance(id=uuid4())\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_user])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users -H Content-Type: application/json -d "
"{\"name\":\"Peter\", \"email\": \"peter@example.com\", \"age\":41}\n"
"{\"name\":\"Peter\",\"email\":\"peter@example.com\",\"age\":41,\"id\":"
"\"628cc350-c526-411f-9020-b29c8341af2e\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:216
msgid ""
"In the above example, we've injected an instance of :class:`DTOData "
"<litestar.dto.data_structures.DTOData>` into our handler, and have used that "
"to create our ``User`` instance, after augmenting the client data with a "
"server generated ``id`` value."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:220
msgid ""
"Consult the :class:`Reference Docs <litestar.dto.data_structures.DTOData>` "
"for more information on the methods available."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:225
msgid "Providing values for nested data"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:227
msgid ""
"To augment data used to instantiate our model instances, we can provide "
"keyword arguments to the :meth:`create_instance() <litestar.dto."
"data_structures.DTOData.create_instance>` method."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:230
msgid ""
"Sometimes we need to provide values for nested data, for example, when "
"creating a new instance of a model that has a nested model with excluded "
"fields."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:234
msgid ""
"from __future__ import annotations\n"
"\n"
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DataclassDTO, DTOConfig, DTOData\n"
"\n"
"\n"
"@dataclass\n"
"class Address:\n"
"    id: int\n"
"    street: str\n"
"\n"
"\n"
"@dataclass\n"
"class Person:\n"
"    id: int\n"
"    name: str\n"
"    age: int\n"
"    address: Address\n"
"\n"
"\n"
"class ReadDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig()\n"
"\n"
"\n"
"class WriteDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"id\", \"address.id\"})\n"
"\n"
"\n"
"@post(\"/person\", dto=WriteDTO, return_dto=ReadDTO, sync_to_thread=False)\n"
"def create_person(data: DTOData[Person]) -> Person:\n"
"    # Logic for persisting the person goes here\n"
"    return data.create_instance(id=1, address__id=2)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_person])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/person -H Content-Type: application/json -d "
"{\"name\":\"Peter\",\"age\":41, \"address\": {\"street\": \"Fake Street\"}}\n"
"{\"id\":1,\"name\":\"Peter\",\"age\":41,\"address\":{\"id\":2,\"street\":"
"\"Fake Street\"}}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:238
msgid ""
"The double-underscore syntax ``address__id`` passed as a keyword argument to "
"the :meth:`create_instance() <litestar.dto.data_structures.DTOData."
"create_instance>` method call is used to specify a value for a nested "
"attribute. In this case, it's used to provide a value for the ``id`` "
"attribute of the ``Address`` instance nested within the ``Person`` instance."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:243
msgid ""
"This is a common convention in Python for dealing with nested structures. "
"The double underscore can be interpreted as \"traverse through\", so "
"``address__id`` means \"traverse through address to get to its id\"."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:246
msgid ""
"In the context of this script, ``create_instance(id=1, address__id=2)`` is "
"saying \"create a new ``Person`` instance from the client data given an id "
"of ``1``, and supplement the client address data with an id of ``2``\"."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:250
msgid "DTO Factory and PATCH requests"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:252
msgid ""
"`PATCH <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH>`_ "
"requests are a special case when it comes to data transfer objects. The "
"reason for this is that we need to be able to accept and validate any subset "
"of the model attributes in the client payload, which requires some special "
"handling internally."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:257
msgid ""
"from __future__ import annotations\n"
"\n"
"from dataclasses import dataclass\n"
"from uuid import UUID\n"
"\n"
"from litestar import Litestar, patch\n"
"from litestar.dto import DataclassDTO, DTOConfig, DTOData\n"
"\n"
"\n"
"@dataclass\n"
"class Person:\n"
"    id: UUID\n"
"    name: str\n"
"    age: int\n"
"\n"
"\n"
"class PatchDTO(DataclassDTO[Person]):\n"
"    \"\"\"Don't allow client to set the id, and allow partial updates."
"\"\"\"\n"
"\n"
"    config = DTOConfig(exclude={\"id\"}, partial=True)\n"
"\n"
"\n"
"peter_uuid = UUID(\"f32ff2ce-e32f-4537-9dc0-26e7599f1380\")\n"
"database = {peter_uuid: Person(id=peter_uuid, name=\"Peter\", age=40)}\n"
"\n"
"\n"
"@patch(\"/person/{person_id:uuid}\", dto=PatchDTO, return_dto=None, "
"sync_to_thread=False)\n"
"def update_person(person_id: UUID, data: DTOData[Person]) -> Person:\n"
"    \"\"\"Partially update a person.\"\"\"\n"
"    return data.update_instance(database[person_id])\n"
"\n"
"\n"
"app = Litestar(route_handlers=[update_person])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/person/f32ff2ce-e32f-4537-9dc0-26e7599f1380 -X "
"PATCH -H Content-Type: application/json -d {\"name\":\"Peter Pan\"}\n"
"{\"id\":\"f32ff2ce-e32f-4537-9dc0-26e7599f1380\",\"name\":\"Peter Pan\","
"\"age\":40}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:261
msgid ""
"The ``PatchDTO`` class is defined for the ``Person`` class. The ``config`` "
"attribute of ``PatchDTO`` is set to exclude the ``id`` field, preventing "
"clients from setting it when updating a person, and the ``partial`` "
"attribute is set to ``True``, which allows the DTO to accept a subset of the "
"model attributes."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:265
msgid ""
"Inside the handler, the :meth:`DTOData.update_instance <litestar.dto."
"data_structures.DTOData.update_instance>` method is called to update the "
"instance of ``Person`` before returning it."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:268
msgid ""
"In our request, we update only the ``name`` property of the ``Person``, from "
"``\"Peter\"`` to ``\"Peter Pan\"`` and receive the full object - with the "
"modified name - back in the response."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:272
msgid "Implicit Private Fields"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:274
msgid ""
"Fields that are named with a leading underscore are considered \"private\" "
"by default. This means that they will not be parsed from client data, and "
"will not be serialized into return data."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:278
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DataclassDTO\n"
"\n"
"\n"
"@dataclass\n"
"class Foo:\n"
"    this_will: str\n"
"    _this_will: str = \"Mars\"\n"
"\n"
"\n"
"@post(\"/\", dto=DataclassDTO[Foo], sync_to_thread=False)\n"
"def handler(data: Foo) -> Foo:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/ -H Content-Type: application/json -d {\"bar\":"
"\"stay\",\"_baz\":\"go_away!\"}\n"
"{\"status_code\":400,\"detail\":\"Object missing required field "
"`this_will`\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:281
msgid ""
"This can be overridden by setting the :attr:`DTOConfig."
"leading_underscore_private <litestar.dto.config.DTOConfig."
"underscore_fields_private>` attribute to ``False``."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:286
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, post\n"
"from litestar.dto import DataclassDTO, DTOConfig\n"
"\n"
"\n"
"@dataclass\n"
"class Foo:\n"
"    this_will: str\n"
"    _this_will: str = \"not_go_away!\"\n"
"\n"
"\n"
"class DTO(DataclassDTO[Foo]):\n"
"    config = DTOConfig(underscore_fields_private=False)\n"
"\n"
"\n"
"@post(\"/\", dto=DTO, sync_to_thread=False)\n"
"def handler(data: Foo) -> Foo:\n"
"    return data\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/ -H Content-Type: application/json -d "
"{\"this_will\":\"stay\",\"_this_will\":\"not_go_away!\"}\n"
"{\"this_will\":\"stay\",\"_this_will\":\"not_go_away!\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:291
msgid "Wrapping Return Data"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:293
msgid ""
"Litestar's DTO Factory types are versatile enough to manage your data, even "
"when it's nested within generic wrappers."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:295
msgid ""
"The following example demonstrates a route handler that returns DTO managed "
"data wrapped in a generic type. The wrapper is used to deliver additional "
"metadata about the response - in this case, a count of the number of items "
"returned. Read on for an explanation of how to do this yourself."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:300
msgid "Enveloping Return Data"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:300
msgid ""
"from dataclasses import dataclass\n"
"from datetime import datetime\n"
"from typing import Generic, TypeVar\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.dto import DTOConfig\n"
"\n"
"from .my_lib import Base\n"
"\n"
"T = TypeVar(\"T\")\n"
"\n"
"\n"
"@dataclass\n"
"class WithCount(Generic[T]):\n"
"    count: int\n"
"    data: list[T]\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str]\n"
"    created_at: Mapped[datetime]\n"
"\n"
"\n"
"class UserDTO(SQLAlchemyDTO[User]):\n"
"    config = DTOConfig(exclude={\"password\", \"created_at\"})\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> WithCount[User]:\n"
"    return WithCount(\n"
"        count=1,\n"
"        data=[\n"
"            User(\n"
"                id=1,\n"
"                name=\"Litestar User\",\n"
"                password=\"xyz\",\n"
"                created_at=datetime.now(),\n"
"            ),\n"
"        ],\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_users])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:0
msgid "Python 3.12+"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:300
msgid ""
"from dataclasses import dataclass\n"
"from datetime import datetime\n"
"from typing import TypeVar\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.dto import DTOConfig\n"
"\n"
"from .my_lib import Base\n"
"\n"
"T = TypeVar(\"T\")\n"
"\n"
"\n"
"@dataclass\n"
"class WithCount[T]:\n"
"    count: int\n"
"    data: list[T]\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str]\n"
"    created_at: Mapped[datetime]\n"
"\n"
"\n"
"class UserDTO(SQLAlchemyDTO[User]):\n"
"    config = DTOConfig(exclude={\"password\", \"created_at\"})\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> WithCount[User]:\n"
"    return WithCount(\n"
"        count=1,\n"
"        data=[\n"
"            User(\n"
"                id=1,\n"
"                name=\"Litestar User\",\n"
"                password=\"xyz\",\n"
"                created_at=datetime.now(),\n"
"            ),\n"
"        ],\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_users])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users\n"
"{\"count\":1,\"data\":[{\"id\":1,\"name\":\"Litestar User\"}]}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:304
msgid ""
"First, create a generic dataclass to act as your wrapper. This type will "
"contain your data and any additional attributes you might need. In this "
"example, we have a ``WithCount`` dataclass which has a ``count`` attribute. "
"The wrapper must be a python generic type with one or more type parameters, "
"and at least one of those type parameters should describe an instance "
"attribute that will be populated with the data."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:310
msgid ""
"from dataclasses import dataclass\n"
"from typing import Generic, TypeVar\n"
"\n"
"T = TypeVar(\"T\")\n"
"\n"
"\n"
"@dataclass\n"
"class WithCount(Generic[T]):\n"
"    count: int\n"
"    data: List[T]"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:310
msgid ""
"from dataclasses import dataclass\n"
"from typing import TypeVar\n"
"\n"
"T = TypeVar(\"T\")\n"
"\n"
"\n"
"@dataclass\n"
"class WithCount[T]:\n"
"    count: int\n"
"    data: List[T]"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:323
msgid ""
"Now, create a DTO for your data object and configure it using ``DTOConfig``. "
"In this example, we're excluding ``password`` and ``created_at`` from the "
"final output."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:327
#: ../../../usage/dto/1-abstract-dto.rst:381
#: ../../../usage/dto/1-abstract-dto.rst:435
msgid ""
"from advanced_alchemy.dto import SQLAlchemyDTO\n"
"from litestar.dto import DTOConfig\n"
"\n"
"\n"
"class UserDTO(SQLAlchemyDTO[User]):\n"
"    config = DTOConfig(exclude={\"password\", \"created_at\"})"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:335
msgid ""
"Then, set up your route handler. This example sets up a ``/users`` endpoint, "
"where a list of ``User`` objects is returned, wrapped in the ``WithCount`` "
"dataclass."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:339
msgid ""
"from litestar import get\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> WithCount[User]:\n"
"    return WithCount(\n"
"        count=1,\n"
"        data=[\n"
"            User(\n"
"                id=1,\n"
"                name=\"Litestar User\",\n"
"                password=\"xyz\",\n"
"                created_at=datetime.now(),\n"
"            ),\n"
"        ],\n"
"    )"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:358
msgid ""
"This setup allows the DTO to manage the rendering of ``User`` objects into "
"the response. The DTO Factory type will find the attribute on the wrapper "
"type that holds the data and perform its serialization operations upon it."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:361
msgid "Returning enveloped data is subject to the following constraints:"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:363
msgid ""
"The type returned from the handler must be a type that Litestar can natively "
"encode."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:364
msgid ""
"There can be multiple type arguments to the generic wrapper type, but there "
"must be exactly one type argument to the generic wrapper that is a type "
"supported by the DTO."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:368
msgid "Working with Litestar's Pagination Types"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:370
msgid ""
"Litestar offers paginated response wrapper types, and DTO Factory types can "
"handle this out of the box."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:373
msgid "Paginated Return Data"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:373
msgid ""
"from datetime import datetime\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.dto import DTOConfig\n"
"from litestar.pagination import ClassicPagination\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str]\n"
"    created_at: Mapped[datetime]\n"
"\n"
"\n"
"class UserDTO(SQLAlchemyDTO[User]):\n"
"    config = DTOConfig(exclude={\"password\", \"created_at\"})\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> ClassicPagination[User]:\n"
"    return ClassicPagination(\n"
"        page_size=10,\n"
"        total_pages=1,\n"
"        current_page=1,\n"
"        items=[\n"
"            User(\n"
"                id=1,\n"
"                name=\"Litestar User\",\n"
"                password=\"xyz\",\n"
"                created_at=datetime.now(),\n"
"            ),\n"
"        ],\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_users])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users\n"
"{\"items\":[{\"id\":1,\"name\":\"Litestar User\"}],\"page_size\":10,"
"\"current_page\":1,\"total_pages\":1}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:377
msgid ""
"The DTO is defined and configured, in our example, we're excluding "
"``password`` and ``created_at`` fields from the final representation of our "
"users."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:389
msgid ""
"The example sets up a ``/users`` endpoint, where a paginated list of "
"``User`` objects is returned, wrapped in :class:`ClassicPagination <."
"pagination.ClassicPagination>`."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:393
msgid ""
"from litestar import get\n"
"from litestar.pagination import ClassicPagination\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> ClassicPagination[User]:\n"
"    return ClassicPagination(\n"
"        page_size=10,\n"
"        total_pages=1,\n"
"        current_page=1,\n"
"        items=[\n"
"            User(\n"
"                id=1,\n"
"                name=\"Litestar User\",\n"
"                password=\"xyz\",\n"
"                created_at=datetime.now(),\n"
"            ),\n"
"        ],\n"
"    )"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:414
msgid ""
"The :class:`ClassicPagination <.pagination.ClassicPagination>` class "
"contains ``page_size`` (number of items per page), ``total_pages`` (total "
"number of pages), ``current_page`` (current page number), and ``items`` "
"(items for the current page)."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:418
msgid ""
"The DTO operates on the data contained in the ``items`` attribute, and the "
"pagination wrapper is handled automatically by Litestar's serialization "
"process."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:422
msgid "Using Litestar's Response Type with DTO Factory"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:424
msgid ""
"Litestar's DTO (Data Transfer Object) Factory Types can handle data wrapped "
"in a ``Response`` type."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:427
msgid "Response Wrapped Return Data"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:427
msgid ""
"from datetime import datetime\n"
"\n"
"from advanced_alchemy.extensions.litestar import SQLAlchemyDTO\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import Litestar, Response, get\n"
"from litestar.dto import DTOConfig\n"
"\n"
"from .my_lib import Base\n"
"\n"
"\n"
"class User(Base):\n"
"    name: Mapped[str]\n"
"    password: Mapped[str]\n"
"    created_at: Mapped[datetime]\n"
"\n"
"\n"
"class UserDTO(SQLAlchemyDTO[User]):\n"
"    config = DTOConfig(exclude={\"password\", \"created_at\"})\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> Response[User]:\n"
"    return Response(\n"
"        content=User(\n"
"            id=1,\n"
"            name=\"Litestar User\",\n"
"            password=\"xyz\",\n"
"            created_at=datetime.now(),\n"
"        ),\n"
"        headers={\"X-Total-Count\": \"1\"},\n"
"    )\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_users])"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/users\n"
"{\"id\":1,\"name\":\"Litestar User\"}"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:431
msgid ""
"We create a DTO for the ``User`` type and configure it using ``DTOConfig`` "
"to exclude ``password`` and ``created_at`` from the serialized output."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:444
msgid ""
"The example sets up a ``/users`` endpoint where a ``User`` object is "
"returned wrapped in a ``Response`` type."
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:447
msgid ""
"from litestar import get, Response\n"
"\n"
"\n"
"@get(\"/users\", dto=UserDTO, sync_to_thread=False)\n"
"def get_users() -> Response[User]:\n"
"    return Response(\n"
"        content=User(\n"
"            id=1,\n"
"            name=\"Litestar User\",\n"
"            password=\"xyz\",\n"
"            created_at=datetime.now(),\n"
"        ),\n"
"        headers={\"X-Total-Count\": \"1\"},\n"
"    )"
msgstr ""

#: ../../../usage/dto/1-abstract-dto.rst:463
msgid ""
"The ``Response`` object encapsulates the ``User`` object in its ``content`` "
"attribute and allows us to configure the response received by the client. In "
"this case, we add a custom header."
msgstr ""
