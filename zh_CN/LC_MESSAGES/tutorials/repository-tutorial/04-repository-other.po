# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:2
msgid "Adding Additional Features to the Repository"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:4
msgid ""
"While most of the functionality you need is built into the repository, there "
"are still cases where you need to add in additional functionality. Let's "
"explore ways that we can add functionality on top of the repository pattern."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:8
msgid ""
"The full code for this tutorial can be found below in the :ref:`Full Code "
"<04-repo-full-code>` section."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:11
msgid "Slug Fields"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:14
#: ../../../tutorials/repository-tutorial/04-repository-other.rst:35
#: ../../../tutorials/repository-tutorial/04-repository-other.rst:45
#: ../../../tutorials/repository-tutorial/04-repository-other.rst:67
msgid "``app.py``"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:14
msgid ""
"from sqlalchemy.orm import Mapped, declarative_mixin, mapped_column\n"
"from sqlalchemy.types import String\n"
"\n"
"from litestar.plugins.sqlalchemy import (\n"
"    base,\n"
")\n"
"\n"
"\n"
"@declarative_mixin\n"
"class SlugKey:\n"
"    \"\"\"Slug unique Field Model Mixin.\"\"\"\n"
"\n"
"    __abstract__ = True\n"
"    slug: Mapped[str] = mapped_column(String(length=100), nullable=False, "
"unique=True, sort_order=-9)\n"
"\n"
"\n"
"class BlogPost(base.UUIDAuditBase, SlugKey):\n"
"    title: Mapped[str]\n"
"    content: Mapped[str]"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:19
msgid ""
"In this example, we are using a ``BlogPost`` model to hold blog post titles "
"and contents.  The primary key for this model is a ``UUID`` type. ``UUID`` "
"and ``int`` are good options for primary keys, but there are a number of "
"reasons you may not want to use them in your routes. For instance, it can be "
"a security problem to expose integer-based primary keys in the URL.  While "
"UUIDs don't have this same problem, they are not user-friendly or easy-to-"
"remember, and create complex URLs. One way to solve this is to add a user "
"friendly unique identifier to the table that can be used for urls.  This is "
"often called a \"slug\"."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:28
msgid ""
"First, we'll create a ``SlugKey`` field mixin that adds a text-based, URL-"
"friendly, unique column ``slug`` to the table. We want to ensure we create a "
"slug value based on the data passed to the ``title`` field.  To demonstrate "
"what we are trying to accomplish, we want a record that has a blog title of "
"\"Follow the Yellow Brick Road!\" to have the slugified value of \"follow-"
"the-yellow-brick-road\"."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:35
msgid ""
"from __future__ import annotations\n"
"\n"
"import random\n"
"import re\n"
"import string\n"
"import unicodedata\n"
"from typing import Any\n"
"\n"
"from litestar.plugins.sqlalchemy import (\n"
"    repository,\n"
")\n"
"\n"
"\n"
"class SQLAlchemyAsyncSlugRepository(repository."
"SQLAlchemyAsyncRepository[repository.ModelT]):\n"
"    \"\"\"Extends the repository to include slug model features..\"\"\"\n"
"\n"
"    async def get_available_slug(\n"
"        self,\n"
"        value_to_slugify: str,\n"
"        **kwargs: Any,\n"
"    ) -> str:\n"
"        \"\"\"Get a unique slug for the supplied value.\n"
"\n"
"        If the value is found to exist, a random 4 digit character is "
"appended to the end.\n"
"        There may be a better way to do this, but I wanted to limit the "
"number of\n"
"        additional database calls.\n"
"\n"
"        Args:\n"
"            value_to_slugify (str): A string that should be converted to a "
"unique slug.\n"
"            **kwargs: stuff\n"
"\n"
"        Returns:\n"
"            str: a unique slug for the supplied value. This is safe for URLs "
"and other\n"
"            unique identifiers.\n"
"        \"\"\"\n"
"        slug = self._slugify(value_to_slugify)\n"
"        if await self._is_slug_unique(slug):\n"
"            return slug\n"
"        # generate a random 4 digit alphanumeric string to make the slug "
"unique and\n"
"        # avoid another DB lookup.\n"
"        random_string = \"\".join(random.choices(string.ascii_lowercase + "
"string.digits, k=4))\n"
"        return f\"{slug}-{random_string}\"\n"
"\n"
"    @staticmethod\n"
"    def _slugify(value: str) -> str:\n"
"        \"\"\"slugify.\n"
"\n"
"        Convert to ASCII if 'allow_unicode' is False. Convert spaces or "
"repeated\n"
"        dashes to single dashes. Remove characters that aren't "
"alphanumerics,\n"
"        underscores, or hyphens. Convert to lowercase. Also strip leading "
"and\n"
"        trailing whitespace, dashes, and underscores.\n"
"\n"
"        Args:\n"
"            value (str): the string to slugify\n"
"\n"
"        Returns:\n"
"            str: a slugified string of the value parameter\n"
"        \"\"\"\n"
"        value = unicodedata.normalize(\"NFKD\", value).encode(\"ascii\", "
"\"ignore\").decode(\"ascii\")\n"
"        value = re.sub(r\"[^\\w\\s-]\", \"\", value.lower())\n"
"        return re.sub(r\"[-\\s]+\", \"-\", value).strip(\"-_\")\n"
"\n"
"    async def _is_slug_unique(\n"
"        self,\n"
"        slug: str,\n"
"        **kwargs: Any,\n"
"    ) -> bool:\n"
"        return await self.get_one_or_none(slug=slug) is None"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:40
msgid ""
"Since the ``BlogPost.title`` field is not marked as unique, this means that "
"we'll have to test the slug value for uniqueness before the insert.  If the "
"initial slug is found, a random set of digits are appended to the end of the "
"slug to make it unique."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:45
msgid ""
"from __future__ import annotations\n"
"\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel as _BaseModel\n"
"from sqlalchemy.orm import Mapped\n"
"\n"
"from litestar import post\n"
"from litestar.plugins.sqlalchemy import (\n"
"    base,\n"
")\n"
"\n"
"\n"
"class BaseModel(_BaseModel):\n"
"    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n"
"\n"
"    model_config = {\"from_attributes\": True}\n"
"\n"
"\n"
"class BlogPost(base.UUIDAuditBase, SlugKey):\n"
"    title: Mapped[str]\n"
"    content: Mapped[str]\n"
"\n"
"\n"
"class BlogPostRepository(SQLAlchemyAsyncSlugRepository[BlogPost]):\n"
"    \"\"\"Blog Post repository.\"\"\"\n"
"\n"
"    model_type = BlogPost\n"
"\n"
"\n"
"class BlogPostDTO(BaseModel):\n"
"    id: UUID | None\n"
"    slug: str\n"
"    title: str\n"
"    content: str\n"
"\n"
"\n"
"class BlogPostCreate(BaseModel):\n"
"    title: str\n"
"    content: str\n"
"@post(path=\"/\")\n"
"async def create_blog(\n"
"    blog_post_repo: BlogPostRepository,\n"
"    data: BlogPostCreate,\n"
") -> BlogPostDTO:\n"
"    \"\"\"Create a new blog post.\"\"\"\n"
"    _data = data.model_dump(exclude_unset=True, by_alias=False, "
"exclude_none=True)\n"
"    _data[\"slug\"] = await blog_post_repo."
"get_available_slug(_data[\"title\"])\n"
"    obj = await blog_post_repo.add(BlogPost(**_data))\n"
"    await blog_post_repo.session.commit()\n"
"    return BlogPostDTO.model_validate(obj)"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:50
msgid ""
"We are all set to use this in our routes now.  First, we'll convert our "
"incoming Pydantic model to a dictionary.  Next, we'll fetch a unique slug "
"for our text. Finally, we insert the model with the added slug."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:56
msgid ""
"Using this method does introduce an additional query on each insert. This "
"should be considered when determining which fields actually need this type "
"of functionality."
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:62
msgid "Full Code"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:0
msgid "Full Code (click to toggle)"
msgstr ""

#: ../../../tutorials/repository-tutorial/04-repository-other.rst:67
msgid ""
"from __future__ import annotations\n"
"\n"
"import random\n"
"import re\n"
"import string\n"
"import unicodedata\n"
"from typing import TYPE_CHECKING, Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel as _BaseModel\n"
"from pydantic import TypeAdapter\n"
"from sqlalchemy.orm import Mapped, declarative_mixin, mapped_column\n"
"from sqlalchemy.types import String\n"
"\n"
"from litestar import Litestar, get, post\n"
"from litestar.di import Provide\n"
"from litestar.plugins.sqlalchemy import (\n"
"    AsyncSessionConfig,\n"
"    SQLAlchemyAsyncConfig,\n"
"    SQLAlchemyInitPlugin,\n"
"    base,\n"
"    repository,\n"
")\n"
"\n"
"if TYPE_CHECKING:\n"
"    from sqlalchemy.ext.asyncio import AsyncSession\n"
"\n"
"\n"
"class BaseModel(_BaseModel):\n"
"    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n"
"\n"
"    model_config = {\"from_attributes\": True}\n"
"\n"
"\n"
"# we are going to add a simple \"slug\" to our model that is a URL safe "
"surrogate key to\n"
"# our database record.\n"
"@declarative_mixin\n"
"class SlugKey:\n"
"    \"\"\"Slug unique Field Model Mixin.\"\"\"\n"
"\n"
"    __abstract__ = True\n"
"    slug: Mapped[str] = mapped_column(String(length=100), nullable=False, "
"unique=True, sort_order=-9)\n"
"\n"
"\n"
"# this class can be re-used with any model that has the `SlugKey` Mixin\n"
"class SQLAlchemyAsyncSlugRepository(repository."
"SQLAlchemyAsyncRepository[repository.ModelT]):\n"
"    \"\"\"Extends the repository to include slug model features..\"\"\"\n"
"\n"
"    async def get_available_slug(\n"
"        self,\n"
"        value_to_slugify: str,\n"
"        **kwargs: Any,\n"
"    ) -> str:\n"
"        \"\"\"Get a unique slug for the supplied value.\n"
"\n"
"        If the value is found to exist, a random 4 digit character is "
"appended to the end.\n"
"        There may be a better way to do this, but I wanted to limit the "
"number of\n"
"        additional database calls.\n"
"\n"
"        Args:\n"
"            value_to_slugify (str): A string that should be converted to a "
"unique slug.\n"
"            **kwargs: stuff\n"
"\n"
"        Returns:\n"
"            str: a unique slug for the supplied value. This is safe for URLs "
"and other\n"
"            unique identifiers.\n"
"        \"\"\"\n"
"        slug = self._slugify(value_to_slugify)\n"
"        if await self._is_slug_unique(slug):\n"
"            return slug\n"
"        # generate a random 4 digit alphanumeric string to make the slug "
"unique and\n"
"        # avoid another DB lookup.\n"
"        random_string = \"\".join(random.choices(string.ascii_lowercase + "
"string.digits, k=4))\n"
"        return f\"{slug}-{random_string}\"\n"
"\n"
"    @staticmethod\n"
"    def _slugify(value: str) -> str:\n"
"        \"\"\"slugify.\n"
"\n"
"        Convert to ASCII if 'allow_unicode' is False. Convert spaces or "
"repeated\n"
"        dashes to single dashes. Remove characters that aren't "
"alphanumerics,\n"
"        underscores, or hyphens. Convert to lowercase. Also strip leading "
"and\n"
"        trailing whitespace, dashes, and underscores.\n"
"\n"
"        Args:\n"
"            value (str): the string to slugify\n"
"\n"
"        Returns:\n"
"            str: a slugified string of the value parameter\n"
"        \"\"\"\n"
"        value = unicodedata.normalize(\"NFKD\", value).encode(\"ascii\", "
"\"ignore\").decode(\"ascii\")\n"
"        value = re.sub(r\"[^\\w\\s-]\", \"\", value.lower())\n"
"        return re.sub(r\"[-\\s]+\", \"-\", value).strip(\"-_\")\n"
"\n"
"    async def _is_slug_unique(\n"
"        self,\n"
"        slug: str,\n"
"        **kwargs: Any,\n"
"    ) -> bool:\n"
"        return await self.get_one_or_none(slug=slug) is None\n"
"\n"
"\n"
"# The `UUIDAuditBase` class includes the same UUID` based primary key (`id`) "
"and 2\n"
"# additional columns: `created_at` and `updated_at`. `created_at` is a "
"timestamp of when the\n"
"# record created, and `updated_at` is the last time the record was "
"modified.\n"
"class BlogPost(base.UUIDAuditBase, SlugKey):\n"
"    title: Mapped[str]\n"
"    content: Mapped[str]\n"
"\n"
"\n"
"class BlogPostRepository(SQLAlchemyAsyncSlugRepository[BlogPost]):\n"
"    \"\"\"Blog Post repository.\"\"\"\n"
"\n"
"    model_type = BlogPost\n"
"\n"
"\n"
"class BlogPostDTO(BaseModel):\n"
"    id: UUID | None\n"
"    slug: str\n"
"    title: str\n"
"    content: str\n"
"\n"
"\n"
"class BlogPostCreate(BaseModel):\n"
"    title: str\n"
"    content: str\n"
"\n"
"\n"
"# we can optionally override the default `select` used for the repository to "
"pass in\n"
"# specific SQL options such as join details\n"
"async def provide_blog_post_repo(db_session: AsyncSession) -> "
"BlogPostRepository:\n"
"    \"\"\"This provides a simple example demonstrating how to override the "
"join options\n"
"    for the repository.\"\"\"\n"
"    return BlogPostRepository(session=db_session)\n"
"\n"
"\n"
"session_config = AsyncSessionConfig(expire_on_commit=False)\n"
"sqlalchemy_config = SQLAlchemyAsyncConfig(\n"
"    connection_string=\"sqlite+aiosqlite:///test.sqlite\", "
"session_config=session_config\n"
")  # Create 'async_session' dependency.\n"
"sqlalchemy_plugin = SQLAlchemyInitPlugin(config=sqlalchemy_config)\n"
"\n"
"\n"
"async def on_startup() -> None:\n"
"    \"\"\"Initializes the database.\"\"\"\n"
"    async with sqlalchemy_config.get_engine().begin() as conn:\n"
"        await conn.run_sync(base.UUIDAuditBase.metadata.create_all)\n"
"\n"
"\n"
"@get(path=\"/\")\n"
"async def get_blogs(\n"
"    blog_post_repo: BlogPostRepository,\n"
") -> list[BlogPostDTO]:\n"
"    \"\"\"Interact with SQLAlchemy engine and session.\"\"\"\n"
"    objs = await blog_post_repo.list()\n"
"    type_adapter = TypeAdapter(list[BlogPostDTO])\n"
"    return type_adapter.validate_python(objs)\n"
"\n"
"\n"
"@get(path=\"/{post_slug:str}\")\n"
"async def get_blog_details(\n"
"    post_slug: str,\n"
"    blog_post_repo: BlogPostRepository,\n"
") -> BlogPostDTO:\n"
"    \"\"\"Interact with SQLAlchemy engine and session.\"\"\"\n"
"    obj = await blog_post_repo.get_one(slug=post_slug)\n"
"    return BlogPostDTO.model_validate(obj)\n"
"\n"
"\n"
"@post(path=\"/\")\n"
"async def create_blog(\n"
"    blog_post_repo: BlogPostRepository,\n"
"    data: BlogPostCreate,\n"
") -> BlogPostDTO:\n"
"    \"\"\"Create a new blog post.\"\"\"\n"
"    _data = data.model_dump(exclude_unset=True, by_alias=False, "
"exclude_none=True)\n"
"    _data[\"slug\"] = await blog_post_repo."
"get_available_slug(_data[\"title\"])\n"
"    obj = await blog_post_repo.add(BlogPost(**_data))\n"
"    await blog_post_repo.session.commit()\n"
"    return BlogPostDTO.model_validate(obj)\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[create_blog, get_blogs, get_blog_details],\n"
"    dependencies={\"blog_post_repo\": Provide(provide_blog_post_repo, "
"sync_to_thread=False)},\n"
"    on_startup=[on_startup],\n"
"    plugins=[SQLAlchemyInitPlugin(config=sqlalchemy_config)],\n"
")"
msgstr ""
