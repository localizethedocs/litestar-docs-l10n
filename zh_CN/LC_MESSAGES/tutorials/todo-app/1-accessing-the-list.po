# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Litestar-Org
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:2
msgid "Accessing the list"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:5
msgid "Intro"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:7
msgid ""
"The first thing you'll be setting up for our app is a route handler that "
"returns a single TODO list. A TODO list in this case will be a list of "
"dictionaries representing the items on that TODO list."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:12
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:44
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:75
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:100
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:107
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:118
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:131
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:161
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:180
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:200
#: ../../../tutorials/todo-app/1-accessing-the-list.rst:230
msgid "``app.py``"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:12
msgid ""
"from typing import Dict, List, Union\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"TODO_LIST: List[Dict[str, Union[str, bool]]] = [\n"
"    {\"title\": \"Start writing TODO list\", \"done\": True},\n"
"    {\"title\": \"???\", \"done\": False},\n"
"    {\"title\": \"Profit\", \"done\": False},\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list() -> List[Dict[str, Union[str, bool]]]:\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:12
msgid ""
"from typing import Union\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"TODO_LIST: list[dict[str, Union[str, bool]]] = [\n"
"    {\"title\": \"Start writing TODO list\", \"done\": True},\n"
"    {\"title\": \"???\", \"done\": False},\n"
"    {\"title\": \"Profit\", \"done\": False},\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list() -> list[dict[str, Union[str, bool]]]:\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:12
msgid ""
"from litestar import Litestar, get\n"
"\n"
"TODO_LIST: list[dict[str, str | bool]] = [\n"
"    {\"title\": \"Start writing TODO list\", \"done\": True},\n"
"    {\"title\": \"???\", \"done\": False},\n"
"    {\"title\": \"Profit\", \"done\": False},\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list() -> list[dict[str, str | bool]]:\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:17
msgid ""
"If you run the app and visit http://127.0.0.1:8000/ in your browser you'll "
"see the following output:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:22
msgid "Suddenly, JSON"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:25
msgid ""
"Because the ``get_list`` function has been annotated  with ``List[Dict[str, "
"Union[str, bool]]]``, Litestar infers that you want the data returned from "
"it to be serialized as JSON:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:30
msgid "async def get_list() -> List[Dict[str, Union[str, bool]]]:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:36
msgid "Cleaning up the example with dataclasses"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:38
msgid ""
"To make your life a little easier, you can transform this example by using :"
"py:mod:`dataclasses` instead of plain dictionaries:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:40
msgid ""
"For an in-depth explanation of dataclasses, you can read this excellent Real "
"Python article: `Data Classes in Python 3.7+ <https://realpython.com/python-"
"data-classes/>`_"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:44
msgid ""
"from dataclasses import dataclass\n"
"from typing import List\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list() -> List[TodoItem]:\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:44
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list() -> list[TodoItem]:\n"
"    return TODO_LIST\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:49
msgid ""
"This looks a lot cleaner and has the added benefit of being able to work "
"with dataclasses instead of plain dictionaries. The result will still be the "
"same: Litestar knows how to turn these dataclasses into JSON and will do so "
"for you automatically."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:54
msgid ""
"In addition to dataclasses, Litestar supports many more types such as :class:"
"`TypedDict <typing.TypedDict>`, :class:`NamedTuple <typing.NamedTuple>`, "
"`Pydantic models <https://docs.pydantic.dev/usage/models/>`_, or `attrs "
"classes <https://www.attrs.org/en/stable/>`_."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:61
msgid "Filtering the list using query parameters"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:63
msgid ""
"Currently ``get_list`` will always return all items on the list, but what if "
"you are interested in only those items with a specific status, for example "
"all items that are not yet marked as *done*?"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:67
msgid ""
"For this you can employ query parameters; to define a query parameter, all "
"that's needed is to add an otherwise unused parameter to the function. "
"Litestar will recognize this and infer that it's going to be used as a query "
"parameter. When a request is being made, the query parameter will be "
"extracted from the URL, and passed to the function parameter of the same "
"name."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:75
msgid ""
"from dataclasses import dataclass\n"
"from typing import List\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: str) -> List[TodoItem]:\n"
"    if done == \"1\":\n"
"        return [item for item in TODO_LIST if item.done]\n"
"    return [item for item in TODO_LIST if not item.done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:75
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: str) -> list[TodoItem]:\n"
"    if done == \"1\":\n"
"        return [item for item in TODO_LIST if item.done]\n"
"    return [item for item in TODO_LIST if not item.done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:82
msgid ""
"Visiting http://127.0.0.1:8000?done=1 will give you all the TODOs that have "
"been marked as *done*"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:88
msgid "while http://127.0.0.1:8000?done=0 will return only those not yet done"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:91
msgid ""
"At first glance this seems to work just fine, but you might be able to spot "
"a problem: If you input anything other than ``?done=1``, it would still "
"return items not yet marked as done. For example, ``?done=john`` gives the "
"same result as ``?done=0``."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:95
msgid ""
"An easy solution for this would be to simply check if the query parameter is "
"either ``1`` or ``0``, and return a response with an HTTP status code that "
"indicates an error if it's something else:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:100
msgid ""
"from dataclasses import dataclass\n"
"from typing import List\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.exceptions import HTTPException\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: str) -> List[TodoItem]:\n"
"    if done == \"1\":\n"
"        return [item for item in TODO_LIST if item.done]\n"
"    if done == \"0\":\n"
"        return [item for item in TODO_LIST if not item.done]\n"
"    raise HTTPException(f\"Invalid query parameter value: {done!r}\", "
"status_code=400)\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:100
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.exceptions import HTTPException\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: str) -> list[TodoItem]:\n"
"    if done == \"1\":\n"
"        return [item for item in TODO_LIST if item.done]\n"
"    if done == \"0\":\n"
"        return [item for item in TODO_LIST if not item.done]\n"
"    raise HTTPException(f\"Invalid query parameter value: {done!r}\", "
"status_code=400)\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:104
msgid ""
"If the query parameter equals ``1``, return all items that have "
"``done=True``:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:107
msgid ""
"if done == \"1\":\n"
"    return [item for item in TODO_LIST if item.done]"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:115
msgid ""
"If the query parameter equals ``0``, return all items that have "
"``done=False``:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:118
msgid ""
"if done == \"0\":\n"
"    return [item for item in TODO_LIST if not item.done]"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:125
msgid ""
"Finally, if the query parameter has any other value, an :exc:`HTTPException` "
"will be raised. Raising an ``HTTPException`` tells Litestar that something "
"went wrong, and instead of returning a normal response, it will send a "
"response with the HTTP status code given (``400`` in this case) and the "
"error message supplied."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:131
msgid ""
"raise HTTPException(f\"Invalid query parameter value: {done!r}\", "
"status_code=400)"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:141
msgid ""
"Try to access http://127.0.0.1:8000?done=john now and you will get this "
"error message"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:144
msgid ""
"Now we've got that out of the way, but your code has grown to be quite "
"complex for such a simple task. You're probably thinking `\"there must be a "
"better way!\" <https://www.youtube.com/watch?t=566&v=p33CVV29OG8>`_, and "
"there is! Instead of doing these things manually, you can also just let "
"Litestar handle them for you!"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:152
msgid "Converting and validating query parameters"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:154
msgid ""
"As mentioned earlier, type annotations can be used for more than static type "
"checking in Litestar; they can also define and configure behaviour. In this "
"case, you can get Litestar to convert the query parameter to a boolean "
"value, matching the values of the ``TodoItem.done`` attribute, and in the "
"same step validate it, returning error responses for you should the supplied "
"value not be a valid boolean."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:161
msgid ""
"from dataclasses import dataclass\n"
"from typing import List\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: bool) -> List[TodoItem]:\n"
"    return [item for item in TODO_LIST if item.done == done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:161
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: bool) -> list[TodoItem]:\n"
"    return [item for item in TODO_LIST if item.done == done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:168
msgid ""
"Browse to http://127.0.0.1:8000?done=john from our earlier example, and you "
"will see it now results in this descriptive error message"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:172
msgid "**What's happening here?**"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:174
msgid ""
"Since :class:`bool` is being used as the type annotation for the ``done`` "
"parameter, Litestar will try to convert the value into a :class:`bool` "
"first. Since ``john`` (arguably) is not a representation of a boolean value, "
"it will return an error response instead."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:180
msgid "async def get_list(done: bool) -> List[TodoItem]:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:187
msgid ""
"It is important to note that this conversion is not the result of calling :"
"class:`bool` on the raw value. ``bool(\"john\")`` would be :obj:`True`, "
"since Python considers all non-empty strings to be truthy."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:191
msgid ""
"Litestar however supports customary boolean representation commonly used in "
"the HTTP world; ``true`` and ``1`` are both converted to :obj:`True`, while "
"``false`` and ``0`` are converted to be :obj:`False`."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:196
msgid ""
"If the conversion is successful however, ``done`` is now a :class:`bool`, "
"which can then be compared against the ``TodoItem.done`` attribute:"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:200
msgid "return [item for item in TODO_LIST if item.done == done]"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:210
msgid ""
":ref:`Routing - Parameters - Type coercion <usage/routing/parameters:type "
"coercion>`"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:214
msgid "Making the query parameter optional"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:216
msgid ""
"There is one problem left to solve though, and that is, what happens when "
"you want to get **all** items, done or not, and omit the query parameter?"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:221
msgid "Omitting the ``?done`` query parameter will result in an error"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:223
msgid ""
"Because the query parameter has been defined as ``done: bool`` without "
"giving it a default value, it will be treated as a required parameter - just "
"like a regular function parameter. If instead you want this to be optional, "
"a default value needs to be supplied."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:230
msgid ""
"from dataclasses import dataclass\n"
"from typing import List, Optional\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: List[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: Optional[bool] = None) -> List[TodoItem]:\n"
"    if done is None:\n"
"        return TODO_LIST\n"
"    return [item for item in TODO_LIST if item.done == done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:230
msgid ""
"from dataclasses import dataclass\n"
"from typing import Optional\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: Optional[bool] = None) -> list[TodoItem]:\n"
"    if done is None:\n"
"        return TODO_LIST\n"
"    return [item for item in TODO_LIST if item.done == done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:230
msgid ""
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, get\n"
"\n"
"\n"
"@dataclass\n"
"class TodoItem:\n"
"    title: str\n"
"    done: bool\n"
"\n"
"\n"
"TODO_LIST: list[TodoItem] = [\n"
"    TodoItem(title=\"Start writing TODO list\", done=True),\n"
"    TodoItem(title=\"???\", done=False),\n"
"    TodoItem(title=\"Profit\", done=False),\n"
"]\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def get_list(done: bool | None = None) -> list[TodoItem]:\n"
"    if done is None:\n"
"        return TODO_LIST\n"
"    return [item for item in TODO_LIST if item.done == done]\n"
"\n"
"\n"
"app = Litestar([get_list])"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:237
msgid ""
"Browsing to http://localhost:8000 once more, you will now see it does not "
"return an error if the query parameter is omitted"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:242
msgid ""
"In this instance, the default has been set to :obj:`None`, since we don't "
"want to do any filtering if no ``done`` status is specified. If instead you "
"wanted to only display not-done items by default, you could set the value "
"to :obj:`False` instead."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:249
msgid ""
":ref:`Routing - Parameters - Query Parameters <usage/routing/parameters:"
"query parameters>`"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:253
msgid "Interactive documentation"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:255
msgid ""
"So far we have explored our TODO application by navigating to it manually, "
"but there is another way: Litestar comes with interactive API documentation, "
"which is generated for you automatically. All you need to do is run your app "
"(``litestar run``) and visit http://127.0.0.1:8000/schema/swagger"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:262
msgid ""
"The route handler set up earlier will show up in the interactive "
"documentation"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:265
msgid ""
"This documentation not only gives an overview of the API you have "
"constructed, but also allows you to send requests to it."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:270
msgid "Executing the same requests we did earlier"
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:274
msgid ""
"This is made possible by `Swagger <https://swagger.io/>`_ and `OpenAPI "
"<https://www.openapis.org/>`_. Litestar generates an OpenAPI schema based on "
"the route handlers, which can then be used by Swagger to set up the "
"interactive documentation."
msgstr ""

#: ../../../tutorials/todo-app/1-accessing-the-list.rst:280
msgid ""
"In addition to Swagger, Litestar serves the documentation from the generated "
"OpenAPI schema with `ReDoc <https://redocly.com/>`_ and `Stoplight Elements "
"<https://stoplight.io/open-source/elements/>`_. You can browse to "
"http://127.0.0.1:8000/schema/redoc and http://127.0.0.1:8000/schema/elements "
"to view each, respectively."
msgstr ""
