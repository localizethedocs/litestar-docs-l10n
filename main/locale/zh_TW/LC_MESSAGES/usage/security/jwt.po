# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/security/jwt.rst:2
msgid "JWT Security Backends"
msgstr ""

#: ../../../usage/security/jwt.rst:4
msgid ""
"Litestar offers optional JWT based security backends. To use these make sure "
"to install the `pyjwt <https://pyjwt.readthedocs.io/en/stable/>`_ and "
"`cryptography <https://github.com/pyca/cryptography>`_ packages, or simply "
"install Litestar with the ``jwt`` `extra <https://packaging.python.org/en/"
"latest/specifications/dependency-specifiers/#extras>`_:"
msgstr ""

#: ../../../usage/security/jwt.rst:9
msgid "Install Litestar with JWT extra"
msgstr ""

#: ../../../usage/security/jwt.rst:9
msgid "pip install 'litestar[jwt]'"
msgstr ""

#: ../../../usage/security/jwt.rst:15
msgid ":class:`JWT Auth <.security.jwt.JWTAuth>` Backend"
msgstr ""

#: ../../../usage/security/jwt.rst:17
msgid ""
"This is the base JWT Auth backend. You can read about its particular API in "
"the :class:`~.security.jwt.JWTAuth`. It sends the JWT token using a header - "
"and it expects requests to send the JWT token using the same header key."
msgstr ""

#: ../../../usage/security/jwt.rst:0
msgid "Click to see the code"
msgstr ""

#: ../../../usage/security/jwt.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/security/jwt.rst:23
msgid "Using JWT Auth"
msgstr ""

#: ../../../usage/security/jwt.rst:23
msgid ""
"import secrets\n"
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import JWTAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"\n"
"\n"
"# JWTAuth requires a retrieve handler callable that receives the JWT token "
"model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", secrets.token_hex()),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTAuth' we can create a login handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(data: User) -> Response[User]:\n"
"    MOCK_DB[str(data.id)] = data\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return jwt_auth.login(identifier=str(data.id), token_extras={\"email\": "
"data.email}, response_body=data)\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False)\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_auth 'on_app_init' handler "
"to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/security/jwt.rst:23
msgid ""
"import secrets\n"
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import JWTAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"\n"
"\n"
"# JWTAuth requires a retrieve handler callable that receives the JWT token "
"model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", secrets.token_hex()),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTAuth' we can create a login handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(data: User) -> Response[User]:\n"
"    MOCK_DB[str(data.id)] = data\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return jwt_auth.login(identifier=str(data.id), token_extras={\"email\": "
"data.email}, response_body=data)\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False)\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_auth 'on_app_init' handler "
"to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:27
msgid ":class:`JWT Cookie Auth <.security.jwt.JWTCookieAuth>` Backend"
msgstr ""

#: ../../../usage/security/jwt.rst:29
msgid ""
"This backend inherits from the :class:`~.security.jwt.JWTAuth` backend, with "
"the difference being that instead of using a header for the JWT Token, it "
"uses a cookie."
msgstr ""

#: ../../../usage/security/jwt.rst:35
msgid "Using JWT Cookie Auth"
msgstr ""

#: ../../../usage/security/jwt.rst:35
msgid ""
"import secrets\n"
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import JWTCookieAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"\n"
"\n"
"# JWTCookieAuth requires a retrieve handler callable that receives the JWT "
"token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: \"Token\", connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"jwt_cookie_auth = JWTCookieAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", secrets.token_hex()),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
"    # Tip: We can optionally supply cookie options to the configuration.  "
"Here is an example of enabling the secure cookie option\n"
"    # secure=True,\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTCookieAuth' we can create a login handler "
"function:\n"
"@post(\"/login\")\n"
"async def login_handler(data: \"User\") -> \"Response[User]\":\n"
"    MOCK_DB[str(data.id)] = data\n"
"    return jwt_cookie_auth.login(identifier=str(data.id), "
"response_body=data)\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False)\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_cookie_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:35
msgid ""
"import secrets\n"
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import JWTCookieAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"\n"
"\n"
"# JWTCookieAuth requires a retrieve handler callable that receives the JWT "
"token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: \"Token\", connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"jwt_cookie_auth = JWTCookieAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", secrets.token_hex()),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
"    # Tip: We can optionally supply cookie options to the configuration.  "
"Here is an example of enabling the secure cookie option\n"
"    # secure=True,\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTCookieAuth' we can create a login handler "
"function:\n"
"@post(\"/login\")\n"
"async def login_handler(data: \"User\") -> \"Response[User]\":\n"
"    MOCK_DB[str(data.id)] = data\n"
"    return jwt_cookie_auth.login(identifier=str(data.id), "
"response_body=data)\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False)\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[jwt_cookie_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:39
msgid ""
":class:`OAuth2 Bearer <.security.jwt.auth.OAuth2PasswordBearerAuth>` "
"Password Flow"
msgstr ""

#: ../../../usage/security/jwt.rst:41
msgid ""
"The :class:`~.security.jwt.auth.OAuth2PasswordBearerAuth` backend inherits "
"from the :class:`~.security.jwt.JWTCookieAuth` backend. It works similarly "
"to the :class:`~.security.jwt.JWTCookieAuth` backend, but is meant to be "
"used for OAuth 2.0 Bearer password flows."
msgstr ""

#: ../../../usage/security/jwt.rst:48
msgid "Using OAUTH2 Bearer Password"
msgstr ""

#: ../../../usage/security/jwt.rst:48
msgid ""
"import secrets\n"
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import OAuth2Login, OAuth2PasswordBearerAuth, "
"Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"\n"
"\n"
"# OAuth2PasswordBearerAuth requires a retrieve handler callable that "
"receives the JWT token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: \"Token\", connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"oauth2_auth = OAuth2PasswordBearerAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", secrets.token_hex()),\n"
"    # we are specifying the URL for retrieving a JWT access token\n"
"    token_url=\"/login\",\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'OAuth2PasswordBearerAuth' we can create a login "
"handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any, Any]\", data: \"User\") "
"-> \"Response[OAuth2Login]\":\n"
"    MOCK_DB[str(data.id)] = data\n"
"    # if we do not define a response body, the login process will return a "
"standard OAuth2 login response.  Note the `Response[OAuth2Login]` return "
"type.\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return oauth2_auth.login(identifier=str(data.id))\n"
"\n"
"\n"
"@post(\"/login_custom\")\n"
"async def login_custom_response_handler(data: \"User\") -> "
"\"Response[User]\":\n"
"    MOCK_DB[str(data.id)] = data\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return oauth2_auth.login(identifier=str(data.id), response_body=data)\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False)\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the oauth2_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[oauth2_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:48
msgid ""
"import secrets\n"
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import OAuth2Login, OAuth2PasswordBearerAuth, "
"Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"\n"
"\n"
"# OAuth2PasswordBearerAuth requires a retrieve handler callable that "
"receives the JWT token model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: \"Token\", connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"oauth2_auth = OAuth2PasswordBearerAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", secrets.token_hex()),\n"
"    # we are specifying the URL for retrieving a JWT access token\n"
"    token_url=\"/login\",\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'OAuth2PasswordBearerAuth' we can create a login "
"handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(request: \"Request[Any, Any, Any]\", data: \"User\") "
"-> \"Response[OAuth2Login]\":\n"
"    MOCK_DB[str(data.id)] = data\n"
"    # if we do not define a response body, the login process will return a "
"standard OAuth2 login response.  Note the `Response[OAuth2Login]` return "
"type.\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return oauth2_auth.login(identifier=str(data.id))\n"
"\n"
"\n"
"@post(\"/login_custom\")\n"
"async def login_custom_response_handler(data: \"User\") -> "
"\"Response[User]\":\n"
"    MOCK_DB[str(data.id)] = data\n"
"\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return oauth2_auth.login(identifier=str(data.id), response_body=data)\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False)\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar_jwt.Token' created from the "
"data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the oauth2_auth 'on_app_init' "
"handler to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, some_route_handler],\n"
"    on_app_init=[oauth2_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:53
msgid "Using a custom token class"
msgstr ""

#: ../../../usage/security/jwt.rst:55
msgid ""
"The token class used can be customized with arbitrary fields, by creating a "
"subclass of :class:`~.security.jwt.Token`, and specifying it on the backend:"
msgstr ""

#: ../../../usage/security/jwt.rst:59
msgid "Using a custom token"
msgstr ""

#: ../../../usage/security/jwt.rst:59
msgid ""
"import dataclasses\n"
"import secrets\n"
"from typing import Any\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.security.jwt import JWTAuth, Token\n"
"\n"
"\n"
"@dataclasses.dataclass\n"
"class CustomToken(Token):\n"
"    token_flag: bool = False\n"
"\n"
"\n"
"@dataclasses.dataclass\n"
"class User:\n"
"    id: str\n"
"\n"
"\n"
"async def retrieve_user_handler(token: CustomToken, connection: "
"ASGIConnection) -> User:\n"
"    return User(id=token.sub)\n"
"\n"
"\n"
"TOKEN_SECRET = secrets.token_hex()\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    token_secret=TOKEN_SECRET,\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    token_cls=CustomToken,\n"
")\n"
"\n"
"\n"
"@get(\"/\")\n"
"def handler(request: Request[User, CustomToken, Any]) -> dict[str, Any]:\n"
"    return {\"id\": request.user.id, \"token_flag\": request.auth."
"token_flag}\n"
"\n"
"\n"
"app = Litestar(middleware=[jwt_auth.middleware])"
msgstr ""

#: ../../../usage/security/jwt.rst:63
msgid ""
"The token will be converted from JSON into the appropriate type, including "
"basic type conversions."
msgstr ""

#: ../../../usage/security/jwt.rst:67
msgid ""
"Complex type conversions, especially those including third libraries such as "
"Pydantic or attrs, as well as any custom ``type_decoders`` are not available "
"for converting the token. To support more complex conversions, the :meth:`~."
"security.jwt.Token.encode` and :meth:`~.security.jwt.Token.decode` methods "
"must be overwritten in the subclass."
msgstr ""

#: ../../../usage/security/jwt.rst:75 ../../../usage/security/jwt.rst:86
msgid "Verifying issuer and audience"
msgstr ""

#: ../../../usage/security/jwt.rst:77
msgid ""
"To verify the JWT ``iss`` (*issuer*) and ``aud`` (*audience*) claim, a list "
"of accepted issuers or audiences can bet set on the authentication backend. "
"When a JWT is decoded, the issuer or audience on the token is compared to "
"the list of accepted issuers / audiences. If the value in the token does not "
"match any value in the respective list, a :exc:`NotAuthorizedException` will "
"be raised, returning a response with a ``401 Unauthorized`` status."
msgstr ""

#: ../../../usage/security/jwt.rst:86
msgid ""
"import dataclasses\n"
"import secrets\n"
"from typing import Any\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.security.jwt import JWTAuth, Token\n"
"\n"
"\n"
"@dataclasses.dataclass\n"
"class User:\n"
"    id: str\n"
"\n"
"\n"
"async def retrieve_user_handler(token: Token, connection: ASGIConnection) -> "
"User:\n"
"    return User(id=token.sub)\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    token_secret=secrets.token_hex(),\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    accepted_audiences=[\"https://api.testserver.local\"],\n"
"    accepted_issuers=[\"https://auth.testserver.local\"],\n"
")\n"
"\n"
"\n"
"@get(\"/\")\n"
"def handler(request: Request[User, Token, Any]) -> dict[str, Any]:\n"
"    return {\"id\": request.user.id}\n"
"\n"
"\n"
"app = Litestar([handler], middleware=[jwt_auth.middleware])"
msgstr ""

#: ../../../usage/security/jwt.rst:91
msgid "Customizing token validation"
msgstr ""

#: ../../../usage/security/jwt.rst:93
msgid ""
"Token decoding / validation can be further customized by overriding the :"
"meth:`~.security.jwt.Token.decode_payload` method. It will be called by :"
"meth:`~.security.jwt.Token.decode` with the encoded token string, and must "
"return a dictionary representing the decoded payload, which will then used "
"by :meth:`~.security.jwt.Token.decode` to construct an instance of the token "
"class."
msgstr ""

#: ../../../usage/security/jwt.rst:101
msgid "Customizing payload decoding"
msgstr ""

#: ../../../usage/security/jwt.rst:101
msgid ""
"import dataclasses\n"
"from collections.abc import Sequence\n"
"from typing import Any, Optional, Union\n"
"\n"
"from litestar.security.jwt.token import JWTDecodeOptions, Token\n"
"\n"
"\n"
"@dataclasses.dataclass\n"
"class CustomToken(Token):\n"
"    @classmethod\n"
"    def decode_payload(\n"
"        cls,\n"
"        encoded_token: str,\n"
"        secret: str,\n"
"        algorithms: list[str],\n"
"        issuer: Optional[list[str]] = None,\n"
"        audience: Union[str, Sequence[str], None] = None,\n"
"        options: Optional[JWTDecodeOptions] = None,\n"
"    ) -> Any:\n"
"        payload = super().decode_payload(\n"
"            encoded_token=encoded_token,\n"
"            secret=secret,\n"
"            algorithms=algorithms,\n"
"            issuer=issuer,\n"
"            audience=audience,\n"
"            options=options,\n"
"        )\n"
"        payload[\"sub\"] = payload[\"sub\"].split(\"@\", maxsplit=1)[1]\n"
"        return payload"
msgstr ""

#: ../../../usage/security/jwt.rst:101
msgid ""
"import dataclasses\n"
"from collections.abc import Sequence\n"
"from typing import Any\n"
"\n"
"from litestar.security.jwt.token import JWTDecodeOptions, Token\n"
"\n"
"\n"
"@dataclasses.dataclass\n"
"class CustomToken(Token):\n"
"    @classmethod\n"
"    def decode_payload(\n"
"        cls,\n"
"        encoded_token: str,\n"
"        secret: str,\n"
"        algorithms: list[str],\n"
"        issuer: list[str] | None = None,\n"
"        audience: str | Sequence[str] | None = None,\n"
"        options: JWTDecodeOptions | None = None,\n"
"    ) -> Any:\n"
"        payload = super().decode_payload(\n"
"            encoded_token=encoded_token,\n"
"            secret=secret,\n"
"            algorithms=algorithms,\n"
"            issuer=issuer,\n"
"            audience=audience,\n"
"            options=options,\n"
"        )\n"
"        payload[\"sub\"] = payload[\"sub\"].split(\"@\", maxsplit=1)[1]\n"
"        return payload"
msgstr ""

#: ../../../usage/security/jwt.rst:106
msgid "Using token revocation"
msgstr ""

#: ../../../usage/security/jwt.rst:107
msgid ""
"Token revocation can be implemented by maintaining a list of revoked tokens "
"and checking against this list during authentication. When a token is "
"revoked, it should be added to the list, and any subsequent requests with "
"that token should be denied."
msgstr ""

#: ../../../usage/security/jwt.rst:113
msgid "Implementing token revocation"
msgstr ""

#: ../../../usage/security/jwt.rst:113
msgid ""
"from os import environ\n"
"from typing import Any, Optional\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import JWTAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"BLOCKLIST: dict[str, str] = {}\n"
"\n"
"\n"
"# JWTAuth requires a retrieve handler callable that receives the JWT token "
"model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> Optional[User]:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"# If you want to use JWTAuth with revoking tokens, you have to define a "
"handler of revoked tokens\n"
"# with your custom logic.\n"
"async def revoked_token_handler(token: Token, connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> bool:\n"
"    jti = token.jti  # Unique token identifier (JWT ID)\n"
"    if jti:\n"
"        # Check if the token is already revoked in the BLOCKLIST\n"
"        revoked = BLOCKLIST.get(jti)\n"
"        if revoked:\n"
"            return True\n"
"    return False\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    revoked_token_handler=revoked_token_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTAuth' we can create a login handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(data: User) -> Response[User]:\n"
"    MOCK_DB[str(data.id)] = data\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return jwt_auth.login(\n"
"        identifier=str(data.id),\n"
"        token_unique_jwt_id=uuid4().hex,\n"
"        token_extras={\"email\": data.email},\n"
"        response_body=data,\n"
"    )\n"
"\n"
"\n"
"# Also we can create a logout\n"
"@post(\"/logout\")\n"
"async def logout_handler(request: Request[\"User\", Token, Any]) -> "
"dict[str, str]:\n"
"    # Your custom logic here\n"
"    # For example\n"
"    jti = request.auth.jti\n"
"    if jti:\n"
"        BLOCKLIST[jti] = \"revoked\"\n"
"        return {\"message\": \"Token has been revoked.\"}\n"
"    return {\"message\": \"No valid token found.\"}\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False, middleware=[jwt_auth."
"middleware])\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar.security.jwt.Token' created "
"from the data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_auth 'on_app_init' handler "
"to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, logout_handler, some_route_handler],\n"
"    on_app_init=[jwt_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""

#: ../../../usage/security/jwt.rst:113
msgid ""
"from os import environ\n"
"from typing import Any\n"
"from uuid import UUID, uuid4\n"
"\n"
"from pydantic import BaseModel, EmailStr\n"
"\n"
"from litestar import Litestar, Request, Response, get, post\n"
"from litestar.connection import ASGIConnection\n"
"from litestar.openapi.config import OpenAPIConfig\n"
"from litestar.security.jwt import JWTAuth, Token\n"
"\n"
"\n"
"# Let's assume we have a User model that is a pydantic model.\n"
"# This though is not required - we need some sort of user class -\n"
"# but it can be any arbitrary value, e.g. an SQLAlchemy model, a "
"representation of a MongoDB  etc.\n"
"class User(BaseModel):\n"
"    id: UUID\n"
"    name: str\n"
"    email: EmailStr\n"
"\n"
"\n"
"MOCK_DB: dict[str, User] = {}\n"
"BLOCKLIST: dict[str, str] = {}\n"
"\n"
"\n"
"# JWTAuth requires a retrieve handler callable that receives the JWT token "
"model and the ASGI connection\n"
"# and returns the 'User' instance correlating to it.\n"
"#\n"
"# Notes:\n"
"# - 'User' can be any arbitrary value you decide upon.\n"
"# - The callable can be either sync or async - both will work.\n"
"async def retrieve_user_handler(token: Token, connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> User | None:\n"
"    # logic here to retrieve the user instance\n"
"    return MOCK_DB.get(token.sub)\n"
"\n"
"\n"
"# If you want to use JWTAuth with revoking tokens, you have to define a "
"handler of revoked tokens\n"
"# with your custom logic.\n"
"async def revoked_token_handler(token: Token, connection: "
"\"ASGIConnection[Any, Any, Any, Any]\") -> bool:\n"
"    jti = token.jti  # Unique token identifier (JWT ID)\n"
"    if jti:\n"
"        # Check if the token is already revoked in the BLOCKLIST\n"
"        revoked = BLOCKLIST.get(jti)\n"
"        if revoked:\n"
"            return True\n"
"    return False\n"
"\n"
"\n"
"jwt_auth = JWTAuth[User](\n"
"    retrieve_user_handler=retrieve_user_handler,\n"
"    revoked_token_handler=revoked_token_handler,\n"
"    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n"
"    # we are specifying which endpoints should be excluded from "
"authentication. In this case the login endpoint\n"
"    # and our openAPI docs.\n"
"    exclude=[\"/login\", \"/schema\"],\n"
")\n"
"\n"
"\n"
"# Given an instance of 'JWTAuth' we can create a login handler function:\n"
"@post(\"/login\")\n"
"async def login_handler(data: User) -> Response[User]:\n"
"    MOCK_DB[str(data.id)] = data\n"
"    # you can do whatever you want to update the response instance here\n"
"    # e.g. response.set_cookie(...)\n"
"    return jwt_auth.login(\n"
"        identifier=str(data.id),\n"
"        token_unique_jwt_id=uuid4().hex,\n"
"        token_extras={\"email\": data.email},\n"
"        response_body=data,\n"
"    )\n"
"\n"
"\n"
"# Also we can create a logout\n"
"@post(\"/logout\")\n"
"async def logout_handler(request: Request[\"User\", Token, Any]) -> "
"dict[str, str]:\n"
"    # Your custom logic here\n"
"    # For example\n"
"    jti = request.auth.jti\n"
"    if jti:\n"
"        BLOCKLIST[jti] = \"revoked\"\n"
"        return {\"message\": \"Token has been revoked.\"}\n"
"    return {\"message\": \"No valid token found.\"}\n"
"\n"
"\n"
"# We also have some other routes, for example:\n"
"@get(\"/some-path\", sync_to_thread=False, middleware=[jwt_auth."
"middleware])\n"
"def some_route_handler(request: \"Request[User, Token, Any]\") -> Any:\n"
"    # request.user is set to the instance of user returned by the "
"middleware\n"
"    assert isinstance(request.user, User)\n"
"    # request.auth is the instance of 'litestar.security.jwt.Token' created "
"from the data encoded in the auth header\n"
"    assert isinstance(request.auth, Token)\n"
"    # do stuff ...\n"
"\n"
"\n"
"# We create our OpenAPIConfig as usual - the JWT security scheme will be "
"injected into it.\n"
"openapi_config = OpenAPIConfig(\n"
"    title=\"My API\",\n"
"    version=\"1.0.0\",\n"
")\n"
"\n"
"# We initialize the app instance and pass the jwt_auth 'on_app_init' handler "
"to the constructor.\n"
"# The hook handler will inject the JWT middleware and openapi configuration "
"into the app.\n"
"app = Litestar(\n"
"    route_handlers=[login_handler, logout_handler, some_route_handler],\n"
"    on_app_init=[jwt_auth.on_app_init],\n"
"    openapi_config=openapi_config,\n"
")"
msgstr ""
