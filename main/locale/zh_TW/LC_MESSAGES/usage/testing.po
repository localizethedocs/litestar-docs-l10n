# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/testing.rst:2
msgid "Testing"
msgstr ""

#: ../../../usage/testing.rst:4
msgid ""
"Testing a Litestar application is made simple by the testing utilities "
"provided out of the box. Based on `httpx <https://www.python-httpx.org/>`_, "
"they come with a familiar interface and integrate seamlessly into "
"synchronous or asynchronous tests."
msgstr ""

#: ../../../usage/testing.rst:10
msgid "Test Clients"
msgstr ""

#: ../../../usage/testing.rst:12
msgid "Litestar provides 2 test clients:"
msgstr ""

#: ../../../usage/testing.rst:14
msgid ""
":class:`~litestar.testing.AsyncTestClient`: An asynchronous test client to "
"be used in asynchronous environments. It runs the application and client on "
"an externally managed event loop. Ideal for testing asynchronous behaviour, "
"or when dealing with asynchronous resources"
msgstr ""

#: ../../../usage/testing.rst:17
msgid ""
":class:`~litestar.testing.TestClient`: A synchronous test client. It runs "
"the application in a newly created event loop within a separate thread. "
"Ideal when no async behaviour needs to be tested, and no external event loop "
"is provided by the testing library"
msgstr ""

#: ../../../usage/testing.rst:22
msgid "Let's say we have a very simple app with a health check endpoint:"
msgstr ""

#: ../../../usage/testing.rst:25
msgid "``my_app/main.py``"
msgstr ""

#: ../../../usage/testing.rst:25
msgid ""
"from litestar import Litestar, MediaType, get\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check])"
msgstr ""

#: ../../../usage/testing.rst:38
msgid "We would then test it using the test client like so:"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Sync"
msgstr ""

#: ../../../usage/testing.rst:46 ../../../usage/testing.rst:66
#: ../../../usage/testing.rst:148 ../../../usage/testing.rst:156
msgid "``tests/test_health_check.py``"
msgstr ""

#: ../../../usage/testing.rst:46
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import TestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"def test_health_check():\n"
"    with TestClient(app=app) as client:\n"
"        response = client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Async"
msgstr ""

#: ../../../usage/testing.rst:66
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"async def test_health_check():\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        response = await client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:83
msgid ""
"Since we would probably need to use the client in multiple places, it's "
"better to make it into a pytest fixture:"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/testing.rst:92 ../../../usage/testing.rst:118
msgid "``tests/conftest.py``"
msgstr ""

#: ../../../usage/testing.rst:92
msgid ""
"from typing import TYPE_CHECKING, Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import TestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:0
msgid "Python 3.9+"
msgstr ""

#: ../../../usage/testing.rst:92
msgid ""
"from typing import TYPE_CHECKING\n"
"from collections.abc import Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import TestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:118
msgid ""
"from typing import TYPE_CHECKING, AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:118
msgid ""
"from typing import TYPE_CHECKING\n"
"from collections.abc import AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"from my_app.main import app\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar import Litestar\n"
"\n"
"app.debug = True\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:140
msgid "We would then be able to rewrite our test like so:"
msgstr ""

#: ../../../usage/testing.rst:148
msgid ""
"from collections.abc import Iterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar import Litestar, MediaType, get\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import TestClient\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT, "
"sync_to_thread=False)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check], debug=True)\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"def test_client() -> Iterator[TestClient[Litestar]]:\n"
"    with TestClient(app=app) as client:\n"
"        yield client\n"
"\n"
"\n"
"def test_health_check_with_fixture(test_client: TestClient[Litestar]) -> "
"None:\n"
"    response = test_client.get(\"/health-check\")\n"
"    assert response.status_code == HTTP_200_OK\n"
"    assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:156
msgid ""
"from collections.abc import AsyncIterator\n"
"\n"
"import pytest\n"
"\n"
"from litestar import Litestar, MediaType, get\n"
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"\n"
"@get(path=\"/health-check\", media_type=MediaType.TEXT, "
"sync_to_thread=False)\n"
"def health_check() -> str:\n"
"    return \"healthy\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[health_check], debug=True)\n"
"\n"
"\n"
"@pytest.fixture(scope=\"function\")\n"
"async def test_client() -> AsyncIterator[AsyncTestClient[Litestar]]:\n"
"    async with AsyncTestClient(app=app) as client:\n"
"        yield client\n"
"\n"
"\n"
"@pytest.mark.skip(reason=\"pytest-asyncio issue: https://github.com/pytest-"
"dev/pytest-asyncio/issues/1191\")\n"
"async def test_health_check_with_fixture(test_client: "
"AsyncTestClient[Litestar]) -> None:\n"
"    response = await test_client.get(\"/health-check\")\n"
"    assert response.status_code == HTTP_200_OK\n"
"    assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:161
msgid "Deciding which test client to use"
msgstr ""

#: ../../../usage/testing.rst:163
msgid ""
"In most situations, it doesn't make a functional difference, and just comes "
"down to preference, as both clients offer the same API and capabilities. "
"However, there are some situations where the way the clients run and "
"interact with the application are important, specifically when testing in an "
"asynchronous context."
msgstr ""

#: ../../../usage/testing.rst:167
msgid ""
"A common issue when using `anyio's pytest plugin <https://anyio.readthedocs."
"io/en/stable/testing.html>`_ or `pytest-asyncio <https://github.com/pytest-"
"dev/pytest-asyncio>`_ to run asynchronous tests or fixtures, using the "
"synchronous :class:`~litestar.testing.TestClient` means that the application "
"will run in a *different event loop* than the test or fixture. In practice, "
"this can result in some difficult to debug and solve situations, especially "
"when setting up async resources outside the application, for example when "
"using the factory pattern."
msgstr ""

#: ../../../usage/testing.rst:173
msgid ""
"The following example uses a shared instance of an ``httpx.AsyncClient``. It "
"uses the common factory function, which allows to customise the client for "
"tests, for example to add authentication headers."
msgstr ""

#: ../../../usage/testing.rst:177
msgid ""
"from collections.abc import AsyncIterable\n"
"\n"
"import httpx\n"
"import pytest\n"
"import pytest_asyncio\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.testing import TestClient\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def handler(http_client: httpx.AsyncClient) -> dict[str, int]:\n"
"    response = await http_client.get(\"https://example.org\")\n"
"    return {\"status\": response.status_code}\n"
"\n"
"\n"
"def create_app(http_client: httpx.AsyncClient) -> Litestar:\n"
"    async def provide_http_client() -> httpx.AsyncClient:\n"
"        return http_client\n"
"\n"
"    return Litestar([handler], dependencies={\"http_client\": "
"provide_http_client})\n"
"\n"
"\n"
"@pytest_asyncio.fixture()\n"
"async def http_test_client() -> AsyncIterable[httpx.AsyncClient]:\n"
"    client = httpx.AsyncClient(headers={\"Authorization\": \"something\"})\n"
"    yield client\n"
"    await client.aclose()\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def app(http_test_client: httpx.AsyncClient) -> Litestar:\n"
"    return create_app(http_client=http_test_client)\n"
"\n"
"\n"
"def test_handler(app: Litestar) -> None:\n"
"    with TestClient(app) as client:\n"
"        response = client.get(\"/\")\n"
"        assert response.json() == {\"status\": 200}"
msgstr ""

#: ../../../usage/testing.rst:179
msgid ""
"Running this test will fail with a ``RuntimeError: Event loop is closed``, "
"when trying to close the ``AsyncClient`` instance. This is happening because:"
msgstr ""

#: ../../../usage/testing.rst:182
msgid "The ``http_test_client`` fixture sets up the client in *event loop A*"
msgstr ""

#: ../../../usage/testing.rst:183
msgid ""
"The ``TestClient`` instance created within the ``test_handler`` test sets up "
"*event loop B* and runs the application in it"
msgstr ""

#: ../../../usage/testing.rst:185
msgid ""
"A call to ``http_client.get``, the ``httpx.AsyncClient`` instance creates a "
"new connection within *loop B* and attaches it to the client instance"
msgstr ""

#: ../../../usage/testing.rst:187
msgid "The ``TestClient`` instance closes *event loop B*"
msgstr ""

#: ../../../usage/testing.rst:188
msgid ""
"The cleanup step of the ``http_test_client`` fixture calls ``httpx."
"AsyncClient.aclose()`` instance within *loop A*, which internally tries to "
"close the connection made in the previous step. That connection however is "
"still attached to *loop B* that was owned by the ``TestClient`` instance, "
"and is now closed"
msgstr ""

#: ../../../usage/testing.rst:193
msgid ""
"This can easily fixed by switching the test from :class:`~litestar.testing."
"TestClient` to :class:`~litestar.testing.AsyncTestClient`:"
msgstr ""

#: ../../../usage/testing.rst:197
msgid ""
"from collections.abc import AsyncIterable\n"
"\n"
"import httpx\n"
"import pytest\n"
"import pytest_asyncio\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def handler(http_client: httpx.AsyncClient) -> dict[str, int]:\n"
"    response = await http_client.get(\"https://example.org\")\n"
"    return {\"status\": response.status_code}\n"
"\n"
"\n"
"def create_app(http_client: httpx.AsyncClient) -> Litestar:\n"
"    async def provide_http_client() -> httpx.AsyncClient:\n"
"        return http_client\n"
"\n"
"    return Litestar([handler], dependencies={\"http_client\": "
"provide_http_client})\n"
"\n"
"\n"
"@pytest_asyncio.fixture()\n"
"async def http_test_client() -> AsyncIterable[httpx.AsyncClient]:\n"
"    client = httpx.AsyncClient(headers={\"Authorization\": \"something\"})\n"
"    yield client\n"
"    await client.aclose()\n"
"\n"
"\n"
"@pytest.fixture()\n"
"def app(http_test_client: httpx.AsyncClient) -> Litestar:\n"
"    return create_app(http_client=http_test_client)\n"
"\n"
"\n"
"async def test_handler(app: Litestar) -> None:\n"
"    async with AsyncTestClient(app) as client:\n"
"        response = await client.get(\"/\")\n"
"        assert response.json() == {\"status\": 200}"
msgstr ""

#: ../../../usage/testing.rst:199
msgid ""
"Now the fixture, test and application code are all running within the same "
"event loop, ensuring that all resources can be cleaned up properly without "
"issues."
msgstr ""

#: ../../../usage/testing.rst:203
msgid "Showcasing the different running event loops when using ``TestClient``"
msgstr ""

#: ../../../usage/testing.rst:203
msgid ""
"import asyncio\n"
"\n"
"import pytest_asyncio\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.testing import AsyncTestClient, TestClient\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def handler() -> dict[str, int]:\n"
"    return {\"loop_id\": id(asyncio.get_running_loop())}\n"
"\n"
"\n"
"@pytest_asyncio.fixture()\n"
"async def fixture_loop_id() -> int:\n"
"    return id(asyncio.get_running_loop())\n"
"\n"
"\n"
"def test_handler(fixture_loop_id: int) -> None:\n"
"    app = Litestar([handler])\n"
"\n"
"    with TestClient(app) as client:\n"
"        response = client.get(\"/\")\n"
"        assert response.json() == {\"loop_id\": fixture_loop_id}\n"
"\n"
"\n"
"async def test_handler_async(fixture_loop_id: int) -> None:\n"
"    app = Litestar([handler])\n"
"\n"
"    async with AsyncTestClient(app) as client:\n"
"        response = await client.get(\"/\")\n"
"        assert response.json() == {\"loop_id\": fixture_loop_id}"
msgstr ""

#: ../../../usage/testing.rst:208
msgid "Testing websockets"
msgstr ""

#: ../../../usage/testing.rst:210
msgid ""
"Litestar's test client enhances the httpx client to support websockets. To "
"test a websocket endpoint, you can use the :meth:`websocket_connect "
"<litestar.testing.TestClient.websocket_connect>` method on the test client. "
"The method returns a websocket connection object that you can use to send "
"and receive messages, see an example below for json:"
msgstr ""

#: ../../../usage/testing.rst:214
msgid ""
"For more information, see also the :class:`WebSocket <litestar.connection."
"WebSocket>` class in the API documentation and the :ref:`websocket <usage/"
"websockets:websockets>` documentation."
msgstr ""

#: ../../../usage/testing.rst:224
msgid ""
"from typing import Any\n"
"\n"
"from litestar import WebSocket, websocket\n"
"from litestar.testing import create_test_client\n"
"\n"
"\n"
"def test_websocket() -> None:\n"
"    @websocket(path=\"/ws\")\n"
"    async def websocket_handler(socket: WebSocket[Any, Any, Any]) -> None:\n"
"        await socket.accept()\n"
"        recv = await socket.receive_json()\n"
"        await socket.send_json({\"message\": recv})\n"
"        await socket.close()\n"
"\n"
"    with create_test_client(route_handlers=[websocket_handler]) as client, "
"client.websocket_connect(\"/ws\") as ws:\n"
"        ws.send_json({\"hello\": \"world\"})\n"
"        data = ws.receive_json()\n"
"        assert data == {\"message\": {\"hello\": \"world\"}}"
msgstr ""

#: ../../../usage/testing.rst:230
msgid ""
"from typing import Any\n"
"\n"
"from litestar import WebSocket, websocket\n"
"from litestar.testing import create_async_test_client\n"
"\n"
"\n"
"async def test_websocket() -> None:\n"
"    @websocket(path=\"/ws\")\n"
"    async def websocket_handler(socket: WebSocket[Any, Any, Any]) -> None:\n"
"        await socket.accept()\n"
"        recv = await socket.receive_json()\n"
"        await socket.send_json({\"message\": recv})\n"
"        await socket.close()\n"
"\n"
"    async with (\n"
"        create_async_test_client(route_handlers=[websocket_handler]) as "
"client,\n"
"        await client.websocket_connect(\"/ws\") as ws,\n"
"    ):\n"
"        await ws.send_json({\"hello\": \"world\"})\n"
"        data = await ws.receive_json()\n"
"        assert data == {\"message\": {\"hello\": \"world\"}}"
msgstr ""

#: ../../../usage/testing.rst:234
msgid "Using sessions"
msgstr ""

#: ../../../usage/testing.rst:236
msgid ""
"If you are using :ref:`session middleware <usage/middleware/builtin-"
"middleware:session middleware>` for session persistence across requests, "
"then you might want to inject or inspect session data outside a request. For "
"this, :class:`TestClient <.testing.TestClient>` provides two methods:"
msgstr ""

#: ../../../usage/testing.rst:240
msgid ":meth:`set_session_data <litestar.testing.TestClient.set_session_data>`"
msgstr ""

#: ../../../usage/testing.rst:241
msgid ":meth:`get_session_data <litestar.testing.TestClient.get_session_data>`"
msgstr ""

#: ../../../usage/testing.rst:250 ../../../usage/testing.rst:262
msgid "Setting session data"
msgstr ""

#: ../../../usage/testing.rst:250
msgid ""
"from typing import Any\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import TestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@get(path=\"/test\", sync_to_thread=False)\n"
"def get_session_data(request: Request) -> dict[str, Any]:\n"
"    return request.session\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"def test_get_session_data() -> None:\n"
"    with TestClient(app=app, session_config=session_config) as client:\n"
"        client.set_session_data({\"foo\": \"bar\"})\n"
"        assert client.get(\"/test\").json() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:255 ../../../usage/testing.rst:267
msgid "Getting session data"
msgstr ""

#: ../../../usage/testing.rst:255
msgid ""
"from litestar import Litestar, Request, post\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import TestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@post(path=\"/test\", sync_to_thread=False)\n"
"def set_session_data(request: Request) -> None:\n"
"    request.session[\"foo\"] = \"bar\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[set_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"with TestClient(app=app, session_config=session_config) as client:\n"
"    client.post(\"/test\").json()\n"
"    assert client.get_session_data() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:262
msgid ""
"from typing import Any\n"
"\n"
"from litestar import Litestar, Request, get\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@get(path=\"/test\", sync_to_thread=False)\n"
"def get_session_data(request: Request) -> dict[str, Any]:\n"
"    return request.session\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"async def test_get_session_data() -> None:\n"
"    async with AsyncTestClient(app=app, session_config=session_config) as "
"client:\n"
"        await client.set_session_data({\"foo\": \"bar\"})\n"
"        res = await client.get(\"/test\")\n"
"        assert res.json() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:267
msgid ""
"from litestar import Litestar, Request, post\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.testing import AsyncTestClient\n"
"\n"
"session_config = ServerSideSessionConfig()\n"
"\n"
"\n"
"@post(path=\"/test\", sync_to_thread=False)\n"
"def set_session_data(request: Request) -> None:\n"
"    request.session[\"foo\"] = \"bar\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[set_session_data], middleware=[session_config."
"middleware], debug=True)\n"
"\n"
"\n"
"async def test_set_session_data() -> None:\n"
"    async with AsyncTestClient(app=app, session_config=session_config) as "
"client:\n"
"        await client.post(\"/test\")\n"
"        assert await client.get_session_data() == {\"foo\": \"bar\"}"
msgstr ""

#: ../../../usage/testing.rst:272
msgid "Running async functions on TestClient"
msgstr ""

#: ../../../usage/testing.rst:274
msgid ""
"When using the synchronous :class:`TestClient <.testing.TestClient>`, it "
"runs the application in a separate thread, which provides the event loop. "
"For this, it makes use of :class:`anyio.BlockingPortal <anyio.abc."
"BlockingPortal>`."
msgstr ""

#: ../../../usage/testing.rst:277
msgid ""
"``TestClient`` makes this portal public, so it can be used to run arbitrary "
"asynchronous code in the same event loop as the application:"
msgstr ""

#: ../../../usage/testing.rst:281
msgid "Using a blocking portal"
msgstr ""

#: ../../../usage/testing.rst:281
msgid ""
"from concurrent.futures import Future, wait\n"
"\n"
"import anyio\n"
"\n"
"from litestar.testing import create_test_client\n"
"\n"
"\n"
"def test_with_portal() -> None:\n"
"    \"\"\"This example shows how to manage asynchronous tasks using a "
"portal.\n"
"\n"
"    The test function itself is not async. Asynchronous functions are "
"executed and awaited using the portal.\n"
"    \"\"\"\n"
"\n"
"    async def get_float(value: float) -> float:\n"
"        await anyio.sleep(value)\n"
"        return value\n"
"\n"
"    with create_test_client(route_handlers=[]) as test_client:\n"
"        # start a background task with the portal\n"
"        future: Future[float] = test_client.blocking_portal."
"start_task_soon(get_float, 0.25)\n"
"        # do other work\n"
"        assert test_client.blocking_portal.call(get_float, 0.1) == 0.1\n"
"        # wait for the background task to complete\n"
"        wait([future])\n"
"        assert future.done()\n"
"        assert future.result() == 0.25"
msgstr ""

#: ../../../usage/testing.rst:286
msgid "Creating a test app"
msgstr ""

#: ../../../usage/testing.rst:288
msgid ""
"Litestar also offers a helper function called :func:`create_test_client "
"<litestar.testing.create_test_client>` which first creates an instance of "
"Litestar and then a test client using it. There are multiple use cases for "
"this helper - when you need to check generic logic that is decoupled from a "
"specific Litestar app, or when you want to test endpoints in isolation."
msgstr ""

#: ../../../usage/testing.rst:294
msgid "``my_app/tests/test_health_check.py``"
msgstr ""

#: ../../../usage/testing.rst:294
msgid ""
"from litestar.status_codes import HTTP_200_OK\n"
"from litestar.testing import create_test_client\n"
"\n"
"from my_app.main import health_check\n"
"\n"
"def test_health_check():\n"
"    with create_test_client([health_check]) as client:\n"
"        response = client.get(\"/health-check\")\n"
"        assert response.status_code == HTTP_200_OK\n"
"        assert response.text == \"healthy\""
msgstr ""

#: ../../../usage/testing.rst:309
msgid "Running a live server"
msgstr ""

#: ../../../usage/testing.rst:311
msgid ""
"The test clients make use of HTTPX's ability to directly call into an ASGI "
"app, without having to run an actual server. In most cases this is "
"sufficient but there are some exceptions where this won't work, due to the "
"limitations of the emulated client-server communication."
msgstr ""

#: ../../../usage/testing.rst:316
msgid ""
"For example, when using server-sent events with an infinite generator, it "
"will lock up the test client, since HTTPX tries to consume the full response "
"before returning a request."
msgstr ""

#: ../../../usage/testing.rst:320
msgid ""
"Litestar offers two helper functions, :func:`litestar.testing."
"subprocess_sync_client` and :func:`litestar.testing.subprocess_async_client` "
"that will launch a Litestar instance with in a subprocess and set up an "
"httpx client for running tests. You can either load your actual app file or "
"create subsets from it as you would with the regular test client setup:"
msgstr ""

#: ../../../usage/testing.rst:328
msgid ""
"\"\"\"\n"
"Assemble components into an app that shall be tested\n"
"\"\"\"\n"
"\n"
"from collections.abc import AsyncGenerator\n"
"\n"
"from litestar import Litestar, get\n"
"from litestar.response import ServerSentEvent\n"
"from litestar.types import SSEData\n"
"\n"
"\n"
"async def generator(topic: str) -> AsyncGenerator[SSEData, None]:\n"
"    count = 0\n"
"    while count < 2:\n"
"        yield topic\n"
"        count += 1\n"
"\n"
"\n"
"@get(\"/notify/{topic:str}\")\n"
"async def get_notified(topic: str) -> ServerSentEvent:\n"
"    return ServerSentEvent(generator(topic), event_type=\"Notifier\")\n"
"\n"
"\n"
"app = Litestar(route_handlers=[get_notified])"
msgstr ""

#: ../../../usage/testing.rst:331
msgid ""
"\"\"\"\n"
"Test the app running in a subprocess\n"
"\"\"\"\n"
"\n"
"import asyncio\n"
"import pathlib\n"
"import sys\n"
"from collections.abc import AsyncIterator\n"
"\n"
"import httpx\n"
"import httpx_sse\n"
"import pytest\n"
"\n"
"from litestar.testing import subprocess_async_client\n"
"\n"
"if sys.platform == \"win32\":\n"
"    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n"
"\n"
"\n"
"ROOT = pathlib.Path(__file__).parent\n"
"\n"
"\n"
"@pytest.fixture(name=\"async_client\")\n"
"async def fx_async_client() -> AsyncIterator[httpx.AsyncClient]:\n"
"    async with subprocess_async_client(workdir=ROOT, "
"app=\"subprocess_sse_app:app\") as client:\n"
"        yield client\n"
"\n"
"\n"
"async def test_subprocess_async_client(async_client: httpx.AsyncClient) -> "
"None:\n"
"    \"\"\"Demonstrates functionality of the async client with an infinite "
"SSE source that cannot be tested with the\n"
"    regular async test client.\n"
"    \"\"\"\n"
"    topic = \"demo\"\n"
"\n"
"    async with httpx_sse.aconnect_sse(async_client, \"GET\", f\"/notify/"
"{topic}\") as event_source:\n"
"        async for event in event_source.aiter_sse():\n"
"            assert event.data == topic\n"
"            break"
msgstr ""

#: ../../../usage/testing.rst:333
msgid ""
"By default, the subprocess client will capture all output from the litestar "
"instance. To discard output in the main (testing) process, set the "
"``capture_output`` argument to ``False`` when creating the client:"
msgstr ""

#: ../../../usage/testing.rst:336
msgid ""
"@pytest.fixture(name=\"async_client\")\n"
"async def fx_async_client() -> AsyncIterator[httpx.AsyncClient]:\n"
"    async with subprocess_async_client(workdir=ROOT, "
"app=\"subprocess_sse_app:app\", capture_output=False) as client:\n"
"        yield client"
msgstr ""

#: ../../../usage/testing.rst:344
msgid "RequestFactory"
msgstr ""

#: ../../../usage/testing.rst:346
msgid ""
"Another helper is the :class:`RequestFactory <litestar.testing."
"RequestFactory>` class, which creates instances of :class:`litestar."
"connection.request.Request <litestar.connection.request.Request>`. The use "
"case for this helper is when you need to test logic that expects to receive "
"a request object."
msgstr ""

#: ../../../usage/testing.rst:350
msgid ""
"For example, lets say we wanted to unit test a *guard* function in "
"isolation, to which end we'll reuse the examples from the :doc:`route guards "
"</usage/security/guards>` documentation:"
msgstr ""

#: ../../../usage/testing.rst:355
msgid "``my_app/guards.py``"
msgstr ""

#: ../../../usage/testing.rst:355
msgid ""
"from litestar import Request\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.handlers.base import BaseRouteHandler\n"
"\n"
"\n"
"def secret_token_guard(request: Request, route_handler: BaseRouteHandler) -> "
"None:\n"
"    if (\n"
"        route_handler.opt.get(\"secret\")\n"
"        and not request.headers.get(\"Secret-Header\", \"\") == "
"route_handler.opt[\"secret\"]\n"
"    ):\n"
"        raise NotAuthorizedException()"
msgstr ""

#: ../../../usage/testing.rst:369
msgid "We already have our route handler in place:"
msgstr ""

#: ../../../usage/testing.rst:372
msgid "``my_app/secret.py``"
msgstr ""

#: ../../../usage/testing.rst:372
msgid ""
"from os import environ\n"
"\n"
"from litestar import get\n"
"\n"
"from my_app.guards import secret_token_guard\n"
"\n"
"\n"
"@get(path=\"/secret\", guards=[secret_token_guard], opt={\"secret\": environ."
"get(\"SECRET\")})\n"
"def secret_endpoint() -> None: ..."
msgstr ""

#: ../../../usage/testing.rst:384
msgid "We could thus test the guard function like so:"
msgstr ""

#: ../../../usage/testing.rst:387
msgid "``tests/guards/test_secret_token_guard.py``"
msgstr ""

#: ../../../usage/testing.rst:387
msgid ""
"import pytest\n"
"\n"
"from litestar.exceptions import NotAuthorizedException\n"
"from litestar.testing import RequestFactory\n"
"\n"
"from my_app.guards import secret_token_guard\n"
"from my_app.secret import secret_endpoint\n"
"\n"
"request = RequestFactory().get(\"/\")\n"
"\n"
"\n"
"def test_secret_token_guard_failure_scenario():\n"
"    copied_endpoint_handler = secret_endpoint.copy()\n"
"    copied_endpoint_handler.opt[\"secret\"] = None\n"
"    with pytest.raises(NotAuthorizedException):\n"
"        secret_token_guard(request=request, "
"route_handler=copied_endpoint_handler)\n"
"\n"
"\n"
"def test_secret_token_guard_success_scenario():\n"
"    copied_endpoint_handler = secret_endpoint.copy()\n"
"    copied_endpoint_handler.opt[\"secret\"] = \"super-secret\"\n"
"    secret_token_guard(request=request, "
"route_handler=copied_endpoint_handler)"
msgstr ""
