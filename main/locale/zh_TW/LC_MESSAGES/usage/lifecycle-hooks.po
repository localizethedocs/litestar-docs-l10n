# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/lifecycle-hooks.rst:2
msgid "Life Cycle Hooks"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:4
msgid ""
"Life cycle hooks allow the execution of a callable at a certain point during "
"the request-response cycle. The hooks available are:"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:8
msgid "Name"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:8
msgid "Runs"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:10
msgid "`before_request`_"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:10
msgid "Before the router handler function"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:12
msgid "`after_request`_"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:12
msgid "After the route handler function"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:14
msgid "`after_response`_"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:14
msgid "After the response has been sent"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:20
msgid "Before Request"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:22
msgid ""
"The ``before_request`` hook runs immediately before calling the route "
"handler function. It can be any callable accepting a :class:`~litestar."
"connection.Request` as its first parameter and returns either ``None`` or a "
"value that can be used in a response. If a value is returned, the router "
"handler for this request will be bypassed."
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:0
msgid "Python 3.8+"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:28
msgid ""
"from typing import Optional\n"
"\n"
"from litestar import Litestar, Request, get\n"
"\n"
"\n"
"async def before_request_handler(request: Request) -> Optional[dict[str, "
"str]]:\n"
"    name = request.query_params[\"name\"]\n"
"    if name == \"Ben\":\n"
"        return {\"message\": \"These are not the bytes you are looking "
"for\"}\n"
"    request.state[\"message\"] = f\"Use the handler, {name}\"\n"
"    return None\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def handler(request: Request, name: str) -> dict[str, str]:\n"
"    message: str = request.state[\"message\"]\n"
"    return {\"message\": message}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler], "
"before_request=before_request_handler)"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:0
msgid "Python 3.10+"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:28
msgid ""
"from litestar import Litestar, Request, get\n"
"\n"
"\n"
"async def before_request_handler(request: Request) -> dict[str, str] | "
"None:\n"
"    name = request.query_params[\"name\"]\n"
"    if name == \"Ben\":\n"
"        return {\"message\": \"These are not the bytes you are looking "
"for\"}\n"
"    request.state[\"message\"] = f\"Use the handler, {name}\"\n"
"    return None\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def handler(request: Request, name: str) -> dict[str, str]:\n"
"    message: str = request.state[\"message\"]\n"
"    return {\"message\": message}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler], "
"before_request=before_request_handler)"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/?name=Luke\n"
"{\"message\":\"Use the handler, Luke\"}\n"
"> curl http://127.0.0.1:8000/?name=Ben\n"
"{\"message\":\"These are not the bytes you are looking for\"}"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:34
msgid "After Request"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:36
msgid ""
"The ``after_request`` hook runs after the route handler returned and the "
"response object has been resolved. It can be any callable which takes a :"
"class:`~litestar.response.Response` instance as its first parameter, and "
"returns a ``Response`` instance. The ``Response`` instance returned does not "
"necessarily have to be the one that was received."
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:42
msgid ""
"from litestar import Litestar, MediaType, Response, get\n"
"\n"
"\n"
"async def after_request(response: Response) -> Response:\n"
"    if response.media_type == MediaType.TEXT:\n"
"        return Response({\"message\": response.content})\n"
"    return response\n"
"\n"
"\n"
"@get(\"/hello\")\n"
"async def hello() -> str:\n"
"    return \"Hello, world\"\n"
"\n"
"\n"
"@get(\"/goodbye\")\n"
"async def goodbye() -> dict[str, str]:\n"
"    return {\"message\": \"Goodbye\"}\n"
"\n"
"\n"
"app = Litestar(route_handlers=[hello, goodbye], after_request=after_request)"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/hello\n"
"{\"message\":\"Hello, world\"}\n"
"> curl http://127.0.0.1:8000/goodbye\n"
"{\"message\":\"Goodbye\"}"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:48
msgid "After Response"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:50
msgid ""
"The ``after_response`` hook runs after the response has been returned by the "
"server. It can be any callable accepting a :class:`~litestar.connection."
"Request` as its first parameter and does not return any value."
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:54
msgid ""
"This hook is meant for data post-processing, transmission of data to third "
"party services, gathering of metrics, etc."
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:58
msgid ""
"from collections import defaultdict\n"
"\n"
"from litestar import Litestar, Request, get\n"
"\n"
"COUNTER: dict[str, int] = defaultdict(int)\n"
"\n"
"\n"
"async def after_response(request: Request) -> None:\n"
"    COUNTER[request.url.path] += 1\n"
"\n"
"\n"
"@get(\"/hello\")\n"
"async def hello() -> dict[str, int]:\n"
"    return COUNTER\n"
"\n"
"\n"
"app = Litestar(route_handlers=[hello], after_response=after_response)"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/hello\n"
"{}\n"
"> curl http://127.0.0.1:8000/hello\n"
"{\"/hello\":1}"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:63
msgid ""
"Since the request has already been returned by the time the "
"``after_response`` is called, the updated state of ``COUNTER`` is not "
"reflected in the response."
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:68
msgid "Layered hooks"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:70
msgid "Layered architecture"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:72
msgid ""
"Life cycle hooks are part of Litestar's layered architecture, which means "
"you can set them on every layer of the application. If you set hooks on "
"multiple layers, the layer closest to the route handler will take precedence."
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:76
msgid ""
"You can read more about this here: :ref:`Layered architecture <usage/"
"applications:layered architecture>`"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:81
msgid ""
"from litestar import Litestar, Response, get\n"
"\n"
"\n"
"def after_request_app(response: Response) -> Response:\n"
"    return Response(content=b\"app after request\")\n"
"\n"
"\n"
"def after_request_handler(response: Response) -> Response:\n"
"    return Response(content=b\"handler after request\")\n"
"\n"
"\n"
"@get(\"/\")\n"
"async def handler() -> str:\n"
"    return \"hello, world\"\n"
"\n"
"\n"
"@get(\"/override\", after_request=after_request_handler)\n"
"async def handler_with_override() -> str:\n"
"    return \"hello, world\"\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[handler, handler_with_override],\n"
"    after_request=after_request_app,\n"
")"
msgstr ""

#: ../../../usage/lifecycle-hooks.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/\n"
"app after request\n"
"> curl http://127.0.0.1:8000/override\n"
"handler after request"
msgstr ""
