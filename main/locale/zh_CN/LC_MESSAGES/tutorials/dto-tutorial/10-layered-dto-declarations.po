# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:2
msgid "Declaring DTOs on app layers"
msgstr ""

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:4
msgid ""
"So far we've seen DTO declared per handler. Let's have a look at a script "
"that declares multiple handlers - something more typical of a real "
"application."
msgstr ""

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:8
msgid ""
"from __future__ import annotations\n"
"\n"
"from dataclasses import dataclass\n"
"\n"
"from litestar import Litestar, patch, post, put\n"
"from litestar.dto import DataclassDTO, DTOConfig, DTOData\n"
"\n"
"\n"
"@dataclass\n"
"class Person:\n"
"    name: str\n"
"    age: int\n"
"    email: str\n"
"    id: int\n"
"\n"
"\n"
"class ReadDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"email\"})\n"
"\n"
"\n"
"class WriteDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"id\"})\n"
"\n"
"\n"
"class PatchDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"id\"}, partial=True)\n"
"\n"
"\n"
"@post(\"/person\", dto=WriteDTO, return_dto=ReadDTO, sync_to_thread=False)\n"
"def create_person(data: DTOData[Person]) -> Person:\n"
"    # Logic for persisting the person goes here\n"
"    return data.create_instance(id=1)\n"
"\n"
"\n"
"@put(\"/person/{person_id:int}\", dto=WriteDTO, return_dto=ReadDTO, "
"sync_to_thread=False)\n"
"def update_person(person_id: int, data: DTOData[Person]) -> Person:\n"
"    # Usually the Person would be retrieved from a database\n"
"    person = Person(id=person_id, name=\"John\", age=50, "
"email=\"email_of_john@example.com\")\n"
"    return data.update_instance(person)\n"
"\n"
"\n"
"@patch(\"/person/{person_id:int}\", dto=PatchDTO, return_dto=ReadDTO, "
"sync_to_thread=False)\n"
"def patch_person(person_id: int, data: DTOData[Person]) -> Person:\n"
"    # Usually the Person would be retrieved from a database\n"
"    person = Person(id=person_id, name=\"John\", age=50, "
"email=\"email_of_john@example.com\")\n"
"    return data.update_instance(person)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[create_person, update_person, patch_person])"
msgstr ""

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:11
msgid ""
"DTOs can be defined on any :ref:`layer <layered-architecture>` of the "
"application which gives us a chance to tidy up our code a bit. Let's move "
"the handlers into a controller and define the DTOs there."
msgstr ""

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:15
msgid ""
"from __future__ import annotations\n"
"\n"
"from dataclasses import dataclass\n"
"\n"
"from litestar import Controller, Litestar, patch, post, put\n"
"from litestar.dto import DataclassDTO, DTOConfig, DTOData\n"
"\n"
"\n"
"@dataclass\n"
"class Person:\n"
"    name: str\n"
"    age: int\n"
"    email: str\n"
"    id: int\n"
"\n"
"\n"
"class ReadDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"email\"})\n"
"\n"
"\n"
"class WriteDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"id\"})\n"
"\n"
"\n"
"class PatchDTO(DataclassDTO[Person]):\n"
"    config = DTOConfig(exclude={\"id\"}, partial=True)\n"
"\n"
"\n"
"class PersonController(Controller):\n"
"    dto = WriteDTO\n"
"    return_dto = ReadDTO\n"
"\n"
"    @post(\"/person\", sync_to_thread=False)\n"
"    def create_person(self, data: DTOData[Person]) -> Person:\n"
"        # Logic for persisting the person goes here\n"
"        return data.create_instance(id=1)\n"
"\n"
"    @put(\"/person/{person_id:int}\", sync_to_thread=False)\n"
"    def update_person(self, person_id: int, data: DTOData[Person]) -> "
"Person:\n"
"        # Usually the Person would be retrieved from a database\n"
"        person = Person(id=person_id, name=\"John\", age=50, "
"email=\"email_of_john@example.com\")\n"
"        return data.update_instance(person)\n"
"\n"
"    @patch(\"/person/{person_id:int}\", dto=PatchDTO, sync_to_thread=False)\n"
"    def patch_person(self, person_id: int, data: DTOData[Person]) -> "
"Person:\n"
"        # Usually the Person would be retrieved from a database\n"
"        person = Person(id=person_id, name=\"John\", age=50, "
"email=\"email_of_john@example.com\")\n"
"        return data.update_instance(person)\n"
"\n"
"\n"
"app = Litestar(route_handlers=[PersonController])"
msgstr ""

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:19
msgid ""
"The previous script had separate handler functions for each route, whereas "
"the new script organizes these into a ``PersonController`` class, allowing "
"us to move common configuration to the controller layer."
msgstr ""

#: ../../../tutorials/dto-tutorial/10-layered-dto-declarations.rst:22
msgid ""
"We have defined both ``dto=WriteDTO`` and ``return_dto=ReadDTO`` on the "
"``PersonController`` class, removing the need to define these on each "
"handler. We still define ``PatchDTO`` directly on the ``patch_person`` "
"handler, to override the controller level ``dto`` setting for that handler."
msgstr ""
