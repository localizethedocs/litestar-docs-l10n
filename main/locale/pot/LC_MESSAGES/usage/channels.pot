# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/channels.rst:4
msgid "Channels"
msgstr ""

#: ../../../usage/channels.rst:6
msgid ""
"**Channels** are a group of related functionalities, built to facilitate the "
"routing of event streams, which for example can be used to broadcast "
"messages to WebSocket clients."
msgstr ""

#: ../../../usage/channels.rst:10
msgid "Channels provide:"
msgstr ""

#: ../../../usage/channels.rst:12
msgid ""
"Independent :term:`broker` backends, optionally handling inter-process "
"communication and data persistence on demand"
msgstr ""

#: ../../../usage/channels.rst:14
msgid "\"Channel\" based :term:`subscription` management"
msgstr ""

#: ../../../usage/channels.rst:15
msgid ""
"Subscriber objects as an abstraction over an individualized :term:`event "
"stream`, providing background workers and managed subscriptions"
msgstr ""

#: ../../../usage/channels.rst:17
msgid "Synchronous and asynchronous data publishing"
msgstr ""

#: ../../../usage/channels.rst:18
msgid "Optional :term:`history` management on a per-:term:`channel` basis"
msgstr ""

#: ../../../usage/channels.rst:19
msgid ""
":doc:`WebSocket </usage/websockets>` integration, generating WebSocket route "
"handlers for an application, to handle the :term:`subscription` and "
"publishing of incoming events to the connected client"
msgstr ""

#: ../../../usage/channels.rst:25
msgid "Basic concepts"
msgstr ""

#: ../../../usage/channels.rst:27
msgid ""
"Utilizing Channels involves a few moving parts. To better familiarize with "
"the concepts, terminology, and the flow of data, the following glossary and "
"flowcharts are provided"
msgstr ""

#: ../../../usage/channels.rst:31
msgid "Glossary"
msgstr ""

#: ../../../usage/channels.rst:0
msgid "Click to toggle the glossary"
msgstr ""

#: ../../../usage/channels.rst:36
msgid "event"
msgstr ""

#: ../../../usage/channels.rst:38
msgid ""
"A single piece of data published to, or received from a :term:`backend` "
"bound to the :term:`channel` it was originally published to"
msgstr ""

#: ../../../usage/channels.rst:40
msgid "event stream"
msgstr ""

#: ../../../usage/channels.rst:42
msgid ""
"A stream of :term:`events <event>`, consisting of events from all the "
"channels a :term:`Subscriber` has previously subscribed to"
msgstr ""

#: ../../../usage/channels.rst:44
msgid "subscriber"
msgstr ""

#: ../../../usage/channels.rst:46
msgid ""
"A :class:`Subscriber <.subscriber.Subscriber>`: An object wrapping an :term:"
"`event stream` and providing access to it through various methods"
msgstr ""

#: ../../../usage/channels.rst:48
msgid "backend"
msgstr ""

#: ../../../usage/channels.rst:50
msgid ""
"A :class:`ChannelsBackend <.backends.base.ChannelsBackend>`. This object "
"manages communication between the plugin and the :term:`broker`, publishing "
"messages to and receiving messages from it. Each plugin instance is "
"associated with exactly one backend."
msgstr ""

#: ../../../usage/channels.rst:54
msgid "broker"
msgstr ""

#: ../../../usage/channels.rst:56
msgid ""
"Responsible for receiving and publishing messages to all connected :term:"
"`backends <backend>`; All backends sharing the same broker will have access "
"to the same messages, allowing for inter-process communication. This is "
"typically handled by a separate entity like `Redis <https://redis.io/>`_"
msgstr ""

#: ../../../usage/channels.rst:60
msgid "plugin"
msgstr ""

#: ../../../usage/channels.rst:62
msgid ""
"The :class:`~.plugin.ChannelsPlugin`, a central instance managing :term:"
"`subscribers <subscriber>`, reading messages from the :term:`backend`, "
"putting them in the appropriate :term:`event stream`, and publishing data to "
"the backend"
msgstr ""

#: ../../../usage/channels.rst:66
msgid "channel"
msgstr ""

#: ../../../usage/channels.rst:68
msgid ""
"A named group of subscribers, to which data can be published. Subscribers "
"can subscribe to multiple channels, and channels can have multiple "
"subscribers"
msgstr ""

#: ../../../usage/channels.rst:70
msgid "subscription"
msgstr ""

#: ../../../usage/channels.rst:72
msgid ""
"A connection between a :term:`subscriber` and a :term:`channel`, allowing "
"the subscriber to receive events from the channel"
msgstr ""

#: ../../../usage/channels.rst:74
msgid "backpressure"
msgstr ""

#: ../../../usage/channels.rst:76
msgid ""
"A mechanism to prevent the backlog of a :term:`subscriber` from growing "
"indefinitely, by either dropping new messages or evicting old ones"
msgstr ""

#: ../../../usage/channels.rst:78
msgid "history"
msgstr ""

#: ../../../usage/channels.rst:80
msgid ""
"A set of previously published :term:`events <event>`, stored by the :term:"
"`backend` and available to be pushed to a :term:`subscriber`"
msgstr ""

#: ../../../usage/channels.rst:82
msgid "fanout"
msgstr ""

#: ../../../usage/channels.rst:84
msgid "The process of sending a message to all subscribers of a channel"
msgstr ""

#: ../../../usage/channels.rst:85
msgid "eviction"
msgstr ""

#: ../../../usage/channels.rst:87
msgid ""
"A :term:`backpressure` strategy, dropping the oldest message in the backlog "
"when a new one is added while the backlog is full"
msgstr ""

#: ../../../usage/channels.rst:89
msgid "backoff"
msgstr ""

#: ../../../usage/channels.rst:91
msgid ""
"A :term:`backpressure` strategy, dropping newly incoming messages as long as "
"the backlog is full"
msgstr ""

#: ../../../usage/channels.rst:95
msgid "Flowcharts"
msgstr ""

#: ../../../usage/channels.rst:0
msgid "Click to toggle flowcharts"
msgstr ""

#: ../../../usage/channels.rst:132
msgid "The :class:`ChannelsPlugin`"
msgstr ""

#: ../../../usage/channels.rst:136
msgid ""
"The :class:`ChannelsPlugin` acts as the central entity for managing channels "
"and subscribers. It is used to publish messages, control how data is stored, "
"and manage :term:`subscribers <subscriber>`, route handlers, and "
"configuration."
msgstr ""

#: ../../../usage/channels.rst:140
msgid ""
"The plugin makes itself available as a dependency under the :paramref:"
"`~ChannelsPlugin.channels` key, which means it is not necessary to import it "
"and instead, it can be used from within route handlers or other callables "
"within the dependency tree directly"
msgstr ""

#: ../../../usage/channels.rst:145
msgid "Configuring the :term:`channels <channel>`"
msgstr ""

#: ../../../usage/channels.rst:147
msgid ""
"The :term:`channels <channel>` managed by the plugin can be either defined "
"upfront, passing them to the :paramref:`~ChannelsPlugin.channels` parameter, "
"or created \"on the fly\" (i.e., on the first :term:`subscription` to a "
"channel) by setting :paramref:`~ChannelsPlugin.arbitrary_channels_allowed` "
"to ``True``."
msgstr ""

#: ../../../usage/channels.rst:153
msgid "Passing channels explicitly"
msgstr ""

#: ../../../usage/channels.rst:153
msgid ""
"from litestar.channels import ChannelsPlugin\n"
"\n"
"channels_plugin = ChannelsPlugin(..., channels=[\"foo\", \"bar\"])"
msgstr ""

#: ../../../usage/channels.rst:160
msgid "Allowing arbitrary channels"
msgstr ""

#: ../../../usage/channels.rst:160
msgid ""
"from litestar.channels import ChannelsPlugin\n"
"\n"
"channels_plugin = ChannelsPlugin(..., arbitrary_channels_allowed=True)"
msgstr ""

#: ../../../usage/channels.rst:166
msgid ""
"If :paramref:`~ChannelsPlugin.arbitrary_channels_allowed` is not ``True``, "
"trying to publish or subscribe to a :term:`channel` not passed to :paramref:"
"`~ChannelsPlugin.channels` will raise a :exc:`ChannelsException`."
msgstr ""

#: ../../../usage/channels.rst:170
msgid "Publishing data"
msgstr ""

#: ../../../usage/channels.rst:172
msgid ""
"One of the core aspects of the plugin is publishing data, which is done "
"through its :meth:`~ChannelsPlugin.publish` method:"
msgstr ""

#: ../../../usage/channels.rst:176
msgid "Publishing data to a channel with :meth:`~ChannelsPlugin.publish`"
msgstr ""

#: ../../../usage/channels.rst:176
msgid "channels.publish({\"message\": \"Hello\"}, \"general\")"
msgstr ""

#: ../../../usage/channels.rst:180
msgid ""
"The above example will publish the data to the channel ``general``, "
"subsequently putting it into all subscriber's :term:`event stream` to be "
"consumed."
msgstr ""

#: ../../../usage/channels.rst:183
msgid ""
"This method is non-blocking, even though channels and the associated :term:"
"`backends <backend>` are fundamentally asynchronous."
msgstr ""

#: ../../../usage/channels.rst:186
msgid ""
"Calling :meth:`~ChannelsPlugin.publish` effectively enqueues a message to be "
"sent to the backend, from which follows that there is no guarantee that an "
"event will be available in the backend immediately after this call."
msgstr ""

#: ../../../usage/channels.rst:189
msgid ""
"Alternatively, the asynchronous :meth:`~ChannelsPlugin.wait_published` "
"method can be used, which skips the internal message queue, publishing the "
"data to the backend directly."
msgstr ""

#: ../../../usage/channels.rst:193
msgid ""
"While calling :meth:`~ChannelsPlugin.publish` does not guarantee the message "
"is sent to the backend immediately, it will be sent there *eventually*; On "
"shutdown, the plugin will wait for all queues to empty"
msgstr ""

#: ../../../usage/channels.rst:198
msgid "Managing :term:`subscriptions <subscription>`"
msgstr ""

#: ../../../usage/channels.rst:200
msgid ""
"Another core functionality of the plugin is managing :term:`subscriptions "
"<subscription>`, for which two different approaches exist:"
msgstr ""

#: ../../../usage/channels.rst:203
msgid ""
"Manually through the :meth:`~ChannelsPlugin.subscribe` and :meth:"
"`~ChannelsPlugin.unsubscribe` methods"
msgstr ""

#: ../../../usage/channels.rst:204
msgid "By using the :meth:`~ChannelsPlugin.start_subscription` context manager"
msgstr ""

#: ../../../usage/channels.rst:206
msgid ""
"Both :meth:`~ChannelsPlugin.subscribe` and :meth:`~ChannelsPlugin."
"start_subscription` produce a :class:`Subscriber`, which can be used to "
"interact with the streams of events subscribed to."
msgstr ""

#: ../../../usage/channels.rst:209
msgid ""
"The context manager should be preferred, since it ensures that channels are "
"being unsubscribed. Using the :meth:`~ChannelsPlugin.subscribe` and :meth:"
"`~ChannelsPlugin.unsubscribe` methods directly should only be one when a :"
"term:`context manager <asynchronous context manager>` cannot be used, e.g., "
"when the :term:`subscription` would span different contexts."
msgstr ""

#: ../../../usage/channels.rst:215
msgid "Calling the :term:`subscription` methods manually"
msgstr ""

#: ../../../usage/channels.rst:215
msgid ""
"subscriber = await channels.subscribe([\"foo\", \"bar\"])\n"
"try:\n"
"    ...  # do some stuff here\n"
"finally:\n"
"    await channels.unsubscribe(subscriber)"
msgstr ""

#: ../../../usage/channels.rst:224
msgid "Using the :term:`async context manager <asynchronous context manager>`"
msgstr ""

#: ../../../usage/channels.rst:224
msgid ""
"async with channels.start_subscription([\"foo\", \"bar\"]) as subscriber:\n"
"    ...  # do some stuff here"
msgstr ""

#: ../../../usage/channels.rst:229
msgid ""
"It is also possible to unsubscribe from individual :term:`channels "
"<channel>`, which may be desirable if :term:`subscriptions <subscription>` "
"need to be managed dynamically."
msgstr ""

#: ../../../usage/channels.rst:233
msgid "Unsubscribing from a channel manually"
msgstr ""

#: ../../../usage/channels.rst:233
msgid ""
"subscriber = await channels.subscribe([\"foo\", \"bar\"])\n"
"try:\n"
"    ...  # do some stuff here\n"
"finally:\n"
"    await channels.unsubscribe(subscriber, [\"foo\"])"
msgstr ""

#: ../../../usage/channels.rst:242
msgid "Or, using the context manager"
msgstr ""

#: ../../../usage/channels.rst:245
msgid ""
"Using the :term:`async context manager <asynchronous context manager>` to "
"unsubscribe from a :term:`channel`"
msgstr ""

#: ../../../usage/channels.rst:245
msgid ""
"async with channels.start_subscription([\"foo\", \"bar\"]) as subscriber:\n"
"    ...  # do some stuff here\n"
"    await channels.unsubscribe(subscriber, [\"foo\"])"
msgstr ""

#: ../../../usage/channels.rst:253
msgid "Managing :term:`history`"
msgstr ""

#: ../../../usage/channels.rst:255
msgid ""
"Some backends support per-:term:`channel` :term:`history`, keeping a certain "
"amount of :term:`events <event>` in storage. This :term:`history` can then "
"be pushed to a :term:`subscriber`."
msgstr ""

#: ../../../usage/channels.rst:258
msgid ""
"The plugin's :meth:`put_subscriber_history <ChannelsPlugin."
"put_subscriber_history>` can be used to fetch this :term:`history` and put "
"it into a subscriber's :term:`event stream`."
msgstr ""

#: ../../../usage/channels.rst:261
msgid ""
"Retrieving :term:`channel` :term:`history` for a :term:`subscriber` and "
"putting it into the :term:`stream <event stream>`"
msgstr ""

#: ../../../usage/channels.rst:261
msgid ""
"from litestar import Litestar, WebSocket, websocket\n"
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.backends.memory import MemoryChannelsBackend\n"
"\n"
"\n"
"@websocket(\"/ws\")\n"
"async def handler(socket: WebSocket, channels: ChannelsPlugin) -> None:\n"
"    await socket.accept()\n"
"\n"
"    async with channels.start_subscription([\"some_channel\"]) as "
"subscriber:\n"
"        await channels.put_subscriber_history(subscriber, "
"[\"some_channel\"], limit=10)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [handler],\n"
"    plugins=[ChannelsPlugin(backend=MemoryChannelsBackend(history=20))],\n"
")\n"
msgstr ""

#: ../../../usage/channels.rst:266
msgid ""
"The publication of the :term:`history` happens sequentially, one :term:"
"`channel` and one :term:`event` at a time. This is done to ensure the "
"correct ordering of events and to avoid filling up a :term:`subscriber`'s "
"backlog, which would result in dropped :term:`history` entries. Should the "
"amount of entries exceed the maximum backlog size, the execution will wait "
"until previous events have been processed."
msgstr ""

#: ../../../usage/channels.rst:272
msgid "Read more: `Managing backpressure`_"
msgstr ""

#: ../../../usage/channels.rst:275
msgid "The :class:`Subscriber`"
msgstr ""

#: ../../../usage/channels.rst:279
msgid ""
"The :class:`Subscriber` manages an individual :term:`event stream`, provided "
"to it by the plugin, representing the sum of events from all :term:`channels "
"<channel>` the subscriber has subscribed to."
msgstr ""

#: ../../../usage/channels.rst:282
msgid ""
"It can be considered the endpoint of all :term:`events <event>`, while the "
"backends act as the source, and the plugin as a router, being responsible "
"for supplying events gathered from the backend into the appropriate "
"subscriber's streams."
msgstr ""

#: ../../../usage/channels.rst:286
msgid ""
"In addition to being an abstraction of an :term:`event stream`, the :class:"
"`Subscriber` provides two methods to handle this stream:"
msgstr ""

#: ../../../usage/channels.rst:289
msgid ":meth:`iter_events <Subscriber.iter_events>`"
msgstr ""

#: ../../../usage/channels.rst:290
msgid ""
"An :term:`asynchronous generator`, producing one event from the stream at a "
"time, waiting until the next one becomes available"
msgstr ""

#: ../../../usage/channels.rst:293
msgid ":meth:`run_in_background <Subscriber.run_in_background>`"
msgstr ""

#: ../../../usage/channels.rst:294
msgid ""
"A :term:`context manager <asynchronous context manager>`, wrapping an :class:"
"`asyncio.Task`, consuming events yielded by :meth:`iter_events <Subscriber."
"iter_events>`, invoking a provided :term:`callback` for each of them. Upon "
"exit, it will attempt a graceful shutdown of the running task, waiting for "
"all currently enqueued events in the stream to be processed. If the context "
"exits with an error, the task will be cancelled instead."
msgstr ""

#: ../../../usage/channels.rst:300
msgid ""
"It is possible to force the task to stop immediately, by setting :paramref:"
"`~Subscriber.run_in_background.join` to ``False`` in :meth:"
"`run_in_background <Subscriber.run_in_background>`, which will lead to the "
"cancellation of the task. By default this only happens when the context is "
"left with an exception."
msgstr ""

#: ../../../usage/channels.rst:305
msgid ""
"The :term:`events <event>` in the :term:`event streams <event stream>` are "
"always bytes; When calling :meth:`ChannelsPlugin.publish`, data will be "
"serialized before being sent to the backend."
msgstr ""

#: ../../../usage/channels.rst:310
msgid "Consuming the :term:`event stream`"
msgstr ""

#: ../../../usage/channels.rst:312
msgid "There are two general methods of consuming the :term:`event stream`:"
msgstr ""

#: ../../../usage/channels.rst:314
msgid ""
"By iterating over it directly, using :meth:`iter_events <Subscriber."
"iter_events>`"
msgstr ""

#: ../../../usage/channels.rst:315
msgid ""
"By using the :meth:`run_in_background <Subscriber.run_in_background>` "
"context manager, which starts a background task, iterating over the stream, "
"invoking a provided callback for every :term:`event` received"
msgstr ""

#: ../../../usage/channels.rst:319
msgid ""
"Iterating over the :term:`stream <event stream>` directly is mostly useful "
"if processing the events is the only concern, since :meth:`iter_events "
"<Subscriber.iter_events>` is effectively an infinite loop. For all other "
"applications, using the context manager is preferable, since it allows to "
"easily run other code concurrently."
msgstr ""

#: ../../../usage/channels.rst:324
msgid "Iterating over the :term:`event stream` to send data to a WebSocket"
msgstr ""

#: ../../../usage/channels.rst:324
msgid ""
"from litestar import Litestar, WebSocket, websocket\n"
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.backends.memory import MemoryChannelsBackend\n"
"\n"
"\n"
"@websocket(\"/ws\")\n"
"async def handler(socket: WebSocket, channels: ChannelsPlugin) -> None:\n"
"    await socket.accept()\n"
"\n"
"    async with channels.start_subscription([\"some_channel\"]) as "
"subscriber:\n"
"        async for message in subscriber.iter_events():\n"
"            await socket.send_text(message)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [handler],\n"
"    plugins=[ChannelsPlugin(backend=MemoryChannelsBackend())],\n"
")\n"
msgstr ""

#: ../../../usage/channels.rst:327
msgid ""
"In the above example, the stream is used to send data to a :class:`WebSocket "
"<litestar.connection.WebSocket>`."
msgstr ""

#: ../../../usage/channels.rst:330
msgid ""
"The same can be achieve by passing :meth:`Websocket.send_text() <litestar."
"connection.WebSocket.send_text>` as the callback to :meth:`~Subscriber."
"run_in_background`. This will cause the WebSocket's method to be invoked "
"every time a new :term:`event` becomes available in the :term:`stream <event "
"stream>`, but gives control back to the application, providing an "
"opportunity to perform other tasks, such as receiving incoming data from the "
"socket."
msgstr ""

#: ../../../usage/channels.rst:335
msgid ""
"Using :meth:`~Subscriber.run_in_background` to process events concurrently"
msgstr ""

#: ../../../usage/channels.rst:335
msgid ""
"from litestar import Litestar, WebSocket, websocket\n"
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.backends.memory import MemoryChannelsBackend\n"
"\n"
"\n"
"@websocket(\"/ws\")\n"
"async def handler(socket: WebSocket, channels: ChannelsPlugin) -> None:\n"
"    await socket.accept()\n"
"\n"
"    async with (\n"
"        channels.start_subscription([\"some_channel\"]) as subscriber,\n"
"        subscriber.run_in_background(socket.send_text),\n"
"    ):\n"
"        while True:\n"
"            response = await socket.receive_text()\n"
"            await socket.send_text(response)\n"
"\n"
"\n"
"app = Litestar(\n"
"    [handler],\n"
"    plugins=[ChannelsPlugin(backend=MemoryChannelsBackend(), "
"channels=[\"some_channel\"])],\n"
")\n"
msgstr ""

#: ../../../usage/channels.rst:338
msgid ""
"Iterating over :meth:`~Subscriber.iter_events` should be approached with "
"caution when being used together with WebSockets."
msgstr ""

#: ../../../usage/channels.rst:341
msgid ""
"Since :exc:`WebSocketDisconnect` is only raised after the corresponding ASGI "
"event has been *received*, it can result in an indefinitely suspended "
"coroutine. This can happen if for example the client disconnects, but no "
"further events are received. The generator will then wait for new events, "
"but since it will never receive any, no ``send`` call on the WebSocket will "
"be made, which in turn means no exception will be raised to break the loop."
msgstr ""

#: ../../../usage/channels.rst:349
msgid "Managing :term:`backpressure`"
msgstr ""

#: ../../../usage/channels.rst:351
msgid ""
"Each subscriber manages its own backlog: A queue of unprocessed :term:"
"`events <event>`. By default, this backlog is unlimited in size, allowing it "
"to grow indefinitely. For most applications, this should be no issue, but "
"when the recipient consistently can not process messages faster than they "
"come in, an application might opt to handle this case."
msgstr ""

#: ../../../usage/channels.rst:356
msgid ""
"The channels plugin provides two different strategies for managing this :"
"term:`backpressure`:"
msgstr ""

#: ../../../usage/channels.rst:358
msgid ""
"A :term:`backoff` strategy, dropping newly incoming messages as long as the "
"backlog is full"
msgstr ""

#: ../../../usage/channels.rst:359
msgid ""
"An :term:`eviction` strategy, dropping the oldest message in the backlog "
"when a new one is added while the backlog is full"
msgstr ""

#: ../../../usage/channels.rst:363
msgid "Backoff strategy"
msgstr ""

#: ../../../usage/channels.rst:363
msgid ""
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.memory import MemoryChannelsBackend\n"
"\n"
"channels = ChannelsPlugin(\n"
"    backend=MemoryChannelsBackend(),\n"
"    max_backlog=1000,\n"
"    backlog_strategy=\"backoff\",\n"
")"
msgstr ""

#: ../../../usage/channels.rst:375
msgid ":term:`Eviction <eviction>` strategy"
msgstr ""

#: ../../../usage/channels.rst:375
msgid ""
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.memory import MemoryChannelsBackend\n"
"\n"
"channels = ChannelsPlugin(\n"
"    backend=MemoryChannelsBackend(),\n"
"    max_backlog=1000,\n"
"    backlog_strategy=\"dropleft\",\n"
")"
msgstr ""

#: ../../../usage/channels.rst:387
msgid "Backends"
msgstr ""

#: ../../../usage/channels.rst:389
msgid ""
"The storing and :term:`fanout` of messages is handled by a :class:"
"`ChannelsBackend <litestar.channels.backends.base.ChannelsBackend>`."
msgstr ""

#: ../../../usage/channels.rst:392
msgid "The following backends are currently implemented:"
msgstr ""

#: ../../../usage/channels.rst:394
msgid ":class:`MemoryChannelsBacked <.memory.MemoryChannelsBackend>`"
msgstr ""

#: ../../../usage/channels.rst:395
msgid ""
"A basic in-memory backend, mostly useful for testing and local development, "
"but still fully capable. Since it stores all data in-process, it can achieve "
"the highest performance of all the backends, but at the same time is not "
"suitable for applications running on multiple processes."
msgstr ""

#: ../../../usage/channels.rst:400
msgid ":class:`RedisChannelsPubSubBackend <.redis.RedisChannelsPubSubBackend>`"
msgstr ""

#: ../../../usage/channels.rst:401
msgid ""
"A Redis based backend, using `Pub/Sub <https://redis.io/docs/manual/pubsub/"
">`_ to delivery messages. This Redis backend has a low latency and overhead "
"and is generally recommended if :term:`history` is not needed"
msgstr ""

#: ../../../usage/channels.rst:405
msgid ":class:`RedisChannelsStreamBackend <.redis.RedisChannelsStreamBackend>`"
msgstr ""

#: ../../../usage/channels.rst:406
msgid ""
"A redis based backend, using `streams <https://redis.io/docs/data-types/"
"streams/>`_ to deliver messages. It has a slightly higher latency when "
"publishing than the Pub/Sub backend, but achieves the same throughput in "
"message :term:`fanout`. Recommended when :term:`history` is needed"
msgstr ""

#: ../../../usage/channels.rst:411
msgid ":class:`AsyncPgChannelsBackend <.asyncpg.AsyncPgChannelsBackend>`"
msgstr ""

#: ../../../usage/channels.rst:412
msgid ""
"A postgres backend using the `asyncpg <https://magicstack.github.io/asyncpg/"
"current/>`_ driver"
msgstr ""

#: ../../../usage/channels.rst:414
msgid ":class:`PsycoPgChannelsBackend <.psycopg.PsycoPgChannelsBackend>`"
msgstr ""

#: ../../../usage/channels.rst:415
msgid ""
"A postgres backend using the `psycopg3 <https://www.psycopg.org/psycopg3/"
"docs/>`_ async driver"
msgstr ""

#: ../../../usage/channels.rst:418
msgid "Integrating with websocket handlers"
msgstr ""

#: ../../../usage/channels.rst:421
msgid "Generating route handlers"
msgstr ""

#: ../../../usage/channels.rst:423
msgid ""
"A common pattern is to create a route handler per :term:`channel`, sending "
"data to the connected client from that channel. This can be fully automated, "
"using the plugin to create these route handlers."
msgstr ""

#: ../../../usage/channels.rst:427
msgid ""
"Setting ``create_ws_route_handlers=True`` will create route handlers for all "
"``channels``"
msgstr ""

#: ../../../usage/channels.rst:427
msgid ""
"from litestar import Litestar\n"
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.backends.memory import MemoryChannelsBackend\n"
"\n"
"channels_plugin = ChannelsPlugin(\n"
"    backend=MemoryChannelsBackend(),\n"
"    channels=[\"foo\", \"bar\"],\n"
"    create_ws_route_handlers=True,\n"
")\n"
"\n"
"app = Litestar(plugins=[channels_plugin])"
msgstr ""

#: ../../../usage/channels.rst:430
msgid ""
"The generated route handlers can optionally be configured to send the :term:"
"`channel`'s :term:`history` after a client has connected:"
msgstr ""

#: ../../../usage/channels.rst:433
msgid "Sending the first 10 :term:`history` entries after a client connects"
msgstr ""

#: ../../../usage/channels.rst:433
msgid ""
"from litestar import Litestar\n"
"from litestar.channels import ChannelsPlugin\n"
"from litestar.channels.backends.memory import MemoryChannelsBackend\n"
"\n"
"channels_plugin = ChannelsPlugin(\n"
"    backend=MemoryChannelsBackend(history=10),  # set the amount of messages "
"per channel\n"
"    # to keep in the backend\n"
"    channels=[\"foo\", \"bar\"],\n"
"    create_ws_route_handlers=True,\n"
"    ws_handler_send_history=10,  # send 10 entries of the history by "
"default\n"
")\n"
"\n"
"app = Litestar(plugins=[channels_plugin])\n"
msgstr ""

#: ../../../usage/channels.rst:436
msgid ""
"When using the :paramref:`~litestar.channels.plugin.ChannelsPlugin."
"arbitrary_channels_allowed` parameter on the :class:`ChannelsPlugin`, a "
"single route handler will be generated instead, using a :ref:`path parameter "
"<usage/routing/parameters:path parameters>` to specify the channel name"
msgstr ""
