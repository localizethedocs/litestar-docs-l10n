# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/middleware/using-middleware.rst:4
msgid "Using Middleware"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:6
msgid ""
"A middleware in Litestar is any callable that receives at least one kwarg "
"called ``app`` and returns an :class:`ASGIApp <litestar.types.ASGIApp>`. An "
"``ASGIApp`` is nothing but an async function that receives the ASGI "
"primitives ``scope`` , ``receive`` and ``send`` , and either calls the next "
"``ASGIApp`` or returns a response / handles the websocket connection."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:11
msgid ""
"For example, the following function can be used as a middleware because it "
"receives the ``app`` kwarg and returns an ``ASGIApp``:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:15
msgid ""
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:27
msgid ""
"We can then pass this middleware to the :class:`Litestar <.app.Litestar>` "
"instance, where it will be called on every request:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:31
msgid ""
"from litestar.types import ASGIApp, Scope, Receive, Send\n"
"from litestar import Litestar\n"
"\n"
"\n"
"def middleware_factory(app: ASGIApp) -> ASGIApp:\n"
"    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> "
"None:\n"
"        # do something here\n"
"        ...\n"
"        await app(scope, receive, send)\n"
"\n"
"    return my_middleware\n"
"\n"
"\n"
"app = Litestar(route_handlers=[...], middleware=[middleware_factory])"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:47
msgid ""
"In the above example, Litestar will call the ``middleware_factory`` function "
"and pass to it ``app``. It's important to understand that this kwarg does "
"not designate the Litestar application but rather the next ``ASGIApp`` in "
"the stack. It will then insert the returned ``my_middleware`` function into "
"the stack of every route in the application - because we declared it on the "
"application level."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:52
msgid "Layered architecture"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:55
msgid ""
"Middlewares are part of Litestar's layered architecture* which means you can "
"set them on every layer of the application."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:58
msgid ""
"You can read more about this here: :ref:`usage/applications:layered "
"architecture`"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:62
msgid "Middleware Call Order"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:64
msgid ""
"due to the way we're traversing over the app layers, the middleware stack is "
"constructed in 'application > handler' order, which is the order we want the "
"middleware to be called in."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:68
msgid ""
"using this order however, since each middleware wraps the next callable, the "
"*first* middleware in the stack would up being the *innermost* wrapper, i.e. "
"the last one to receive the request and the first one to see the response."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:72
msgid ""
"to achieve the intended call order, we perform the wrapping in reverse "
"('handler -> application')."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:100
msgid ""
"from typing import TYPE_CHECKING\n"
"\n"
"from litestar import Controller, Litestar, Router, get\n"
"from litestar.datastructures import State\n"
"from litestar.middleware import MiddlewareProtocol\n"
"\n"
"if TYPE_CHECKING:\n"
"    from litestar.types import ASGIApp, Receive, Scope, Send\n"
"\n"
"\n"
"def create_test_middleware(middleware_id: int) -> type[MiddlewareProtocol]:\n"
"    class TestMiddleware(MiddlewareProtocol):\n"
"        def __init__(self, app: \"ASGIApp\") -> None:\n"
"            self.app = app\n"
"\n"
"        async def __call__(self, scope: \"Scope\", receive: \"Receive\", "
"send: \"Send\") -> None:\n"
"            litestar_app = scope[\"app\"]\n"
"            litestar_app.state.setdefault(\"middleware_calls\", [])\n"
"            litestar_app.state[\"middleware_calls\"].append(middleware_id)\n"
"            await self.app(scope, receive, send)\n"
"\n"
"    return TestMiddleware\n"
"\n"
"\n"
"class MyController(Controller):\n"
"    path = \"/controller\"\n"
"    middleware = [create_test_middleware(4), create_test_middleware(5)]\n"
"\n"
"    @get(\n"
"        \"/handler\",\n"
"        middleware=[create_test_middleware(6), create_test_middleware(7)],\n"
"    )\n"
"    async def my_handler(self, state: State) -> list[int]:\n"
"        return state[\"middleware_calls\"]\n"
"\n"
"\n"
"router = Router(\n"
"    path=\"/router\",\n"
"    route_handlers=[MyController],\n"
"    middleware=[create_test_middleware(2), create_test_middleware(3)],\n"
")\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[router],\n"
"    middleware=[create_test_middleware(0), create_test_middleware(1)],\n"
")"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:-1
msgid ""
"> curl http://127.0.0.1:8000/router/controller/handler\n"
"[0,1,2,3,4,5,6,7]"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:105
msgid "Middlewares and Exceptions"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:107
msgid ""
"When an exception is raised by a route handler or a :doc:`dependency </usage/"
"dependency-injection>` it will be transformed into a response by an :ref:"
"`exception handler <usage/exceptions:exception handling>`. This response "
"will follow the normal \"flow\" of the application and therefore, "
"middlewares are still applied to it."
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:112
msgid ""
"As with any good rule, there are exceptions to it. In this case they are two "
"exceptions raised by Litestar's ASGI router:"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:116
msgid ""
":class:`NotFoundException <litestar.exceptions.http_exceptions."
"NotFoundException>`"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:117
msgid ""
":class:`MethodNotAllowedException <litestar.exceptions.http_exceptions."
"MethodNotAllowedException>`"
msgstr ""

#: ../../../usage/middleware/using-middleware.rst:119
msgid ""
"They are raised **before the middleware stack is called** and will only be "
"handled by exception handlers defined on the ``Litestar`` instance itself. "
"If you wish to modify error responses generated from these exception, you "
"will have to use an application layer exception handler."
msgstr ""
