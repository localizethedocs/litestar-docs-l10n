# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, Litestar Organization
# This file is distributed under the same license as the Litestar package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Litestar main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20 02:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/middleware/builtin-middleware.rst:2
msgid "Built-in middleware"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:5
msgid "CORS"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:7
msgid ""
"`CORS (Cross-Origin Resource Sharing) <https://developer.mozilla.org/en-US/"
"docs/Web/HTTP/CORS>`_ is a common security mechanism that is often "
"implemented using middleware. To enable CORS in a litestar application "
"simply pass an instance of :class:`~litestar.config.cors.CORSConfig` to :"
"class:`~litestar.app.Litestar`:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:12
msgid ""
"from litestar import Litestar\n"
"from litestar.config.cors import CORSConfig\n"
"\n"
"cors_config = CORSConfig(allow_origins=[\"https://www.example.com\"])\n"
"\n"
"app = Litestar(route_handlers=[...], cors_config=cors_config)"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:22
msgid "CSRF"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:24
msgid ""
"`CSRF (Cross-site request forgery) <https://owasp.org/www-community/attacks/"
"csrf>`_ is a type of attack where unauthorized commands are submitted from a "
"user that the web application trusts. This attack often uses social "
"engineering that tricks the victim into clicking a URL that contains a "
"maliciously crafted, unauthorized request for a particular Web application. "
"The userâ€™s browser then sends this maliciously crafted request to the "
"targeted Web application. If the user is in an active session with the Web "
"application, the application treats this new request as an authorized "
"request submitted by the user. Thus, the attacker can force the user to "
"perform an action the user didn't intend, for example:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:32
msgid ""
"POST /send-money HTTP/1.1\n"
"Host: target.web.app\n"
"Content-Type: application/x-www-form-urlencoded\n"
"\n"
"amount=1000usd&to=attacker@evil.com"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:41
msgid "This middleware prevents CSRF attacks by doing the following:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:43
msgid ""
"On the first \"safe\" request (e.g GET) - set a cookie with a special token "
"created by the server"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:44
msgid ""
"On each subsequent \"unsafe\" request (e.g POST) - make sure the request "
"contains either a"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:45
msgid ""
"form field or an additional header that has this token (more on this below)"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:47
msgid ""
"To enable CSRF protection in a Litestar application simply pass an instance "
"of :class:`~litestar.config.csrf.CSRFConfig` to the Litestar constructor:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:51
msgid ""
"from litestar import Litestar, get, post\n"
"from litestar.config.csrf import CSRFConfig\n"
"\n"
"\n"
"@get()\n"
"async def get_resource() -> str:\n"
"    # GET is one of the safe methods\n"
"    return \"some_resource\"\n"
"\n"
"@post(\"{id:int}\")\n"
"async def create_resource(id: int) -> bool:\n"
"    # POST is one of the unsafe methods\n"
"    return True\n"
"\n"
"csrf_config = CSRFConfig(secret=\"my-secret\")\n"
"\n"
"app = Litestar([get_resource, create_resource], csrf_config=csrf_config)"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:71
msgid ""
"The following snippet demonstrates how to change the cookie name to ``\"some-"
"cookie-name\"`` and header name to ``\"some-header-name\"``."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:74
msgid ""
"csrf_config = CSRFConfig(secret=\"my-secret\", cookie_name='some-cookie-"
"name', header_name='some-header-name')"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:78
msgid ""
"A CSRF protected route can be accessed by any client that can make a request "
"with either the header or form-data key."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:83
msgid ""
"The form-data key can not be currently configured. It should only be passed "
"via the key ``\"_csrf_token\"``"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:85
msgid ""
"In Python, any client such as `requests <https://github.com/psf/requests>`_ "
"or `httpx <https://github.com/encode/httpx>`_ can be used. The usage of "
"clients or sessions is recommended due to the cookie persistence it offers "
"across requests. The following is an example using `httpx.Client <https://"
"www.python-httpx.org/api/#client>`_."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:90
msgid ""
"import httpx\n"
"\n"
"\n"
"with httpx.Client() as client:\n"
"    get_response = client.get(\"http://localhost:8000/\")\n"
"\n"
"    # \"csrftoken\" is the default cookie name\n"
"    csrf = get_response.cookies[\"csrftoken\"]\n"
"\n"
"    # \"x-csrftoken\" is the default header name\n"
"    post_response_using_header = client.post(\"http://localhost:8000/1\", "
"headers={\"x-csrftoken\": csrf})\n"
"    assert post_response_using_header.status_code == 201\n"
"\n"
"    # \"_csrf_token\" is the default *non* configurable form-data key\n"
"    post_response_using_form_data = client.post(\"http://localhost:8000/1\", "
"data={\"_csrf_token\": csrf})\n"
"    assert post_response_using_form_data.status_code == 201\n"
"\n"
"    # despite the header being passed, this request will fail as it does not "
"have a cookie in its session\n"
"    # note the usage of ``httpx.post`` instead of ``client.post``\n"
"    post_response_with_no_persisted_cookie = httpx.post(\"http://"
"localhost:8000/1\", headers={\"x-csrftoken\": csrf})\n"
"    assert post_response_with_no_persisted_cookie.status_code == 403\n"
"    assert \"CSRF token verification failed\" in "
"post_response_with_no_persisted_cookie.text"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:114
msgid ""
"Routes can be marked as being exempt from the protection offered by this "
"middleware via :ref:`handler opts <handler_opts>`"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:118
msgid ""
"@post(\"/post\", exclude_from_csrf=True)\n"
"def handler() -> None: ..."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:123
msgid ""
"If you need to exempt many routes at once you might want to consider using "
"the :attr:`~litestar.config.csrf.CSRFConfig.exclude` kwarg which accepts "
"list of path patterns to skip in the middleware."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:129
msgid ""
"`Safe and Unsafe (HTTP Methods) <https://developer.mozilla.org/en-US/docs/"
"Glossary/Safe/HTTP>`_"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:130
msgid "`HTTPX Clients <https://www.python-httpx.org/advanced/clients>`_"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:131
msgid ""
"`Requests Session <https://requests.readthedocs.io/en/latest/user/advanced>`_"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:135
msgid "Allowed Hosts"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:137
msgid ""
"Another common security mechanism is to require that each incoming request "
"has a ``\"Host\"`` or ``\"X-Forwarded-Host\"`` header, and then to restrict "
"hosts to a specific set of domains - what's called \"allowed hosts\"."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:140
msgid ""
"Litestar includes an :class:`~litestar.middleware.allowed_hosts."
"AllowedHostsMiddleware` class that can be easily enabled by either passing "
"an instance of :class:`~litestar.config.allowed_hosts.AllowedHostsConfig` or "
"a list of domains to :class:`~litestar.app.Litestar`:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:145
msgid ""
"from litestar import Litestar\n"
"from litestar.config.allowed_hosts import AllowedHostsConfig\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[...],\n"
"    allowed_hosts=AllowedHostsConfig(\n"
"        allowed_hosts=[\"*.example.com\", \"www.wikipedia.org\"]\n"
"    ),\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:158
msgid ""
"You can use wildcard prefixes (``*.``) in the beginning of a domain to match "
"any combination of subdomains. Thus, ``*.example.com`` will match ``www."
"example.com`` but also ``x.y.z.example.com`` etc. You can also simply put "
"``*`` in trusted hosts, which means allow all. This is akin to turning the "
"middleware off, so in this case it may be better to not enable it in the "
"first place. You should note that a wildcard can only be used in the prefix "
"of a domain name, not in the middle or end. Doing so will result in a "
"validation exception being raised."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:166
msgid "Compression"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:168
msgid ""
"HTTP responses can optionally be compressed. Litestar has support for gzip, "
"brotli, and zstd. Gzip is supported by Litestar out of the box, while Brotli "
"support can be added by installing the ``brotli`` extra, and Zstd support "
"can be added by installing the ``zstd`` extra."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:171
msgid ""
"You can enable any one of these backends by passing an instance of :class:"
"`~litestar.config.compression.CompressionConfig` to ``compression_config`` "
"of :class:`~litestar.app.Litestar`."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:176
msgid "GZIP"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:178
msgid ""
"You can enable gzip compression of responses by passing an instance of :"
"class:`~litestar.config.compression.CompressionConfig` with the ``backend`` "
"parameter set to ``\"gzip\"``."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:181
msgid "You can configure the following additional gzip-specific values:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:184
#: ../../../usage/middleware/builtin-middleware.rst:211
msgid ""
"``minimum_size``: the minimum threshold for response size to enable "
"compression. Smaller responses will not be"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:185
msgid "compressed. Default is ``500``, i.e. half a kilobyte."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:186
msgid ""
"``gzip_compress_level``: a range between 0-9, see the `official python docs "
"<https://docs.python.org/3/library/gzip.html>`_."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:187
msgid "Defaults to ``9``, which is the maximum value."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:190
msgid ""
"from litestar import Litestar\n"
"from litestar.config.compression import CompressionConfig\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[...],\n"
"    compression_config=CompressionConfig(backend=\"gzip\", "
"gzip_compress_level=9),\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:200
msgid "Brotli"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:202
msgid ""
"The `Brotli <https://pypi.org/project/Brotli>`_ package is required to run "
"this middleware. It is available as an extras to litestar with the "
"``brotli`` extra (``pip install 'litestar[brotli]'``)."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:205
msgid ""
"You can enable brotli compression of responses by passing an instance of :"
"class:`~litestar.config.compression.CompressionConfig` with the ``backend`` "
"parameter set to ``\"brotli\"``."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:208
msgid "You can configure the following additional brotli-specific values:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:212
msgid "compressed. Default is 500, i.e. half a kilobyte"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:213
msgid ""
"``brotli_quality``: Range [0-11], Controls the compression-speed vs "
"compression-density tradeoff. The higher the"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:214
msgid "quality, the slower the compression. Defaults to 5"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:215
msgid ""
"``brotli_mode``: The compression mode can be ``\"generic\"`` (for mixed "
"content), ``\"text\"`` (for UTF-8 format text input), or"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:216
msgid "``\"font\"`` (for WOFF 2.0). Defaults to ``\"text\"``"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:217
msgid ""
"``brotli_lgwin``: Base 2 logarithm of size. Range [10-24]. Defaults to 22."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:218
msgid ""
"``brotli_lgblock``: Base 2 logarithm of the maximum input block size. Range "
"[16-24]. If set to 0, the value will"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:219
msgid "be set based on the quality. Defaults to 0"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:220
msgid ""
"``brotli_gzip_fallback``: a boolean to indicate if gzip should be used if "
"brotli is not supported"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:223
msgid ""
"from litestar import Litestar\n"
"from litestar.config.compression import CompressionConfig\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[...],\n"
"    compression_config=CompressionConfig(backend=\"brotli\", "
"brotli_gzip_fallback=True),\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:233
msgid "Zstd"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:235
msgid ""
"The `zstandard <https://pypi.org/project/zstandard>`_ package is required to "
"run this middleware. It is available as an extra for Litestar via the "
"``zstd`` extra: (``pip install 'litestar[zstd]'``)."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:237
msgid ""
"You can enable zstd compression of responses by passing an instance of :"
"class:`~litestar.config.compression.CompressionConfig` with the ``backend`` "
"parameter set to ``\"zstd\"``."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:240
msgid "You can configure the following additional zstd-specific values:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:242
msgid ""
"``minimum_size``: the minimum threshold for response size to enable "
"compression. Smaller responses will not be compressed. Default is 500, i.e. "
"half a kilobyte."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:243
msgid ""
"``zstd_compress_level``: Range [0-22], Controls the compression level. "
"Higher values increase compression ratio but are slower. Default is 3."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:244
msgid ""
"``zstd_gzip_fallback``: Boolean indicating whether to fall back to gzip if "
"Zstd is not supported. Default is True."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:247
msgid ""
"from litestar import Litestar\n"
"from litestar.config.compression import CompressionConfig\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[...],\n"
"    compression_config=CompressionConfig(backend=\"zstd\", "
"zstd_gzip_fallback=True),\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:257
msgid "Rate-Limit Middleware"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:259
msgid ""
"Litestar includes an optional :class:`~litestar.middleware.rate_limit."
"RateLimitMiddleware` that follows the `IETF RateLimit draft specification "
"<https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/>`_."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:262
msgid ""
"To use the rate limit middleware, use the :class:`~litestar.middleware."
"rate_limit.RateLimitConfig`:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:265
msgid ""
"from litestar import Litestar, MediaType, get\n"
"from litestar.middleware.rate_limit import RateLimitConfig\n"
"\n"
"rate_limit_config = RateLimitConfig(rate_limit=(\"minute\", 1), exclude=[\"/"
"schema\"])\n"
"\n"
"\n"
"@get(\"/\", media_type=MediaType.TEXT, sync_to_thread=False)\n"
"def handler() -> str:\n"
"    \"\"\"Handler which should not be accessed more than once per minute."
"\"\"\"\n"
"    return \"ok\"\n"
"\n"
"\n"
"app = Litestar(route_handlers=[handler], middleware=[rate_limit_config."
"middleware])"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:267
msgid ""
"The only required configuration kwarg is ``rate_limit``, which expects a "
"tuple containing a time-unit (``\"second\"``, ``\"minute\"``, ``\"hour\"``, "
"``\"day\"``\\ ) and a value for the request quota (integer)."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:272
msgid "Using behind a proxy"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:274
msgid ""
"The default mode for uniquely identifiying client uses the client's address. "
"When an application is running behind a proxy, that address will be the "
"proxy's, not the \"real\" address of the end-user."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:278
msgid ""
"While there are special headers set by proxies to retrieve the remote "
"client's actual address (``X-FORWARDED-FOR``), their values should not "
"implicitly be trusted, as any client is free to set them to whatever value "
"they want. A rate-limit could easily be circumvented by spoofing these, and "
"simply attaching a new, random address to each request."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:284
msgid ""
"The best way to handle applications running behind a proxy is to use a "
"middleware that updates the client's address in a secure way, such as "
"uvicorn's `ProxyHeaderMiddleware <https://github.com/encode/uvicorn/blob/"
"master/uvicorn/middleware/proxy_headers.py>`_ or hypercon's "
"`ProxyFixMiddleware <https://hypercorn.readthedocs.io/en/latest/"
"how_to_guides/proxy_fix.html>`_ ."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:291
msgid "Logging Middleware"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:293
msgid ""
"Litestar ships with a robust logging middleware that allows logging HTTP "
"request and responses while building on the Litestar's :ref:`logging "
"configuration <logging-usage>`:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:297
msgid ""
"from litestar import Litestar, get\n"
"from litestar.logging.config import LoggingConfig\n"
"from litestar.middleware.logging import LoggingMiddlewareConfig\n"
"\n"
"logging_middleware_config = LoggingMiddlewareConfig()\n"
"\n"
"\n"
"@get(\"/\", sync_to_thread=False)\n"
"def my_handler() -> dict[str, str]:\n"
"    return {\"hello\": \"world\"}\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[my_handler],\n"
"    logging_config=LoggingConfig(),\n"
"    middleware=[logging_middleware_config.middleware],\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:300
msgid ""
"The logging middleware uses the logger configuration defined on the "
"application level, which allows for using any supported logging tool, "
"depending on the configuration used (see :ref:`logging configuration "
"<logging-usage>` for more details)."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:304
msgid "Obfuscating Logging Output"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:306
msgid ""
"Sometimes certain data, e.g. request or response headers, needs to be "
"obfuscated. This is supported by the middleware configuration:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:310
msgid ""
"from litestar.middleware.logging import LoggingMiddlewareConfig\n"
"\n"
"logging_middleware_config = LoggingMiddlewareConfig(\n"
"    request_cookies_to_obfuscate={\"my-custom-session-key\"},\n"
"    response_cookies_to_obfuscate={\"my-custom-session-key\"},\n"
"    request_headers_to_obfuscate={\"my-custom-header\"},\n"
"    response_headers_to_obfuscate={\"my-custom-header\"},\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:320
msgid ""
"The middleware will obfuscate the headers ``Authorization`` and ``X-API-"
"KEY`` , and the cookie ``session`` by default."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:324
msgid "Compression and Logging of Response Body"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:326
msgid ""
"If both :class:`~litestar.config.compression.CompressionConfig` and :class:"
"`~litestar.middleware.logging.LoggingMiddleware` have been defined for the "
"application, the response body will be omitted from response logging if it "
"has been compressed, even if ``\"body\"`` has been included in :class:"
"`~litestar.middleware.logging.LoggingMiddlewareConfig.response_log_fields`. "
"To force the body of compressed responses to be logged, set :attr:`~litestar."
"middleware.logging.LoggingMiddlewareConfig.include_compressed_body` to "
"``True`` , in addition to including ``\"body\"`` in ``response_log_fields``."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:335
msgid "Session Middleware"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:337
msgid ""
"Litestar includes a :class:`~litestar.middleware.session.base."
"SessionMiddleware`, offering client- and server-side sessions. Server-side "
"sessions are backed by Litestar's :doc:`stores </usage/stores>`, which offer "
"support for:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:341
msgid "In memory sessions"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:342
msgid "File based sessions"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:343
msgid "Redis based sessions"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:344
msgid "Valkey based sessions"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:345
msgid ""
"Database based :ref:`advanced-alchemy:usage/frameworks/litestar:Session "
"Middleware`"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:348
msgid "Setting up the middleware"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:350
msgid ""
"To start using sessions in your application all you have to do is create an "
"instance of a :class:`configuration <litestar.middleware.session.base."
"BaseBackendConfig>` object and add its middleware to your application's "
"middleware stack:"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:355
msgid "Hello World"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:355
msgid ""
"from os import urandom\n"
"\n"
"from litestar import Litestar, Request, delete, get, post\n"
"from litestar.middleware.session.client_side import CookieBackendConfig\n"
"\n"
"# we initialize to config with a 16 byte key, i.e. 128 a bit key.\n"
"# in real world usage we should inject the secret from the environment\n"
"session_config = CookieBackendConfig(secret=urandom(16))  # type: ignore[arg-"
"type]\n"
"\n"
"\n"
"@get(\"/session\", sync_to_thread=False)\n"
"def check_session_handler(request: Request) -> dict[str, bool]:\n"
"    \"\"\"Handler function that accesses request.session.\"\"\"\n"
"    return {\"has_session\": request.session != {}}\n"
"\n"
"\n"
"@post(\"/session\", sync_to_thread=False)\n"
"def create_session_handler(request: Request) -> None:\n"
"    \"\"\"Handler to set the session.\"\"\"\n"
"    if not request.session:\n"
"        # value can be a dictionary or pydantic model\n"
"        request.set_session({\"username\": \"moishezuchmir\"})\n"
"\n"
"\n"
"@delete(\"/session\", sync_to_thread=False)\n"
"def delete_session_handler(request: Request) -> None:\n"
"    \"\"\"Handler to clear the session.\"\"\"\n"
"    if request.session:\n"
"        request.clear_session()\n"
"\n"
"\n"
"app = Litestar(\n"
"    route_handlers=[check_session_handler, create_session_handler, "
"delete_session_handler],\n"
"    middleware=[session_config.middleware],\n"
")"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:361
msgid ""
"Since both client- and server-side sessions rely on cookies (one for storing "
"the actual session data, the other for storing the session ID), they share "
"most of the cookie configuration. A complete reference of the cookie "
"configuration can be found at :class:`~litestar.middleware.session.base."
"BaseBackendConfig`."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:366
msgid "Client-side sessions"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:368
msgid ""
"Client side sessions are available through the :class:`~litestar.middleware."
"session.client_side.ClientSideSessionBackend`, which offers strong AES-CGM "
"encryption security best practices while support cookie splitting."
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:373
msgid ""
"``ClientSideSessionBackend`` requires the `cryptography <https://"
"cryptography.io/en/latest/>`_ library, which can be installed together with "
"litestar as an extra using ``pip install 'litestar[cryptography]'``"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:377
msgid "``cookie_backend.py``"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:377
msgid ""
"from os import urandom\n"
"\n"
"from litestar import Litestar\n"
"from litestar.middleware.session.client_side import CookieBackendConfig\n"
"\n"
"session_config = CookieBackendConfig(secret=urandom(16))  # type: ignore\n"
"\n"
"app = Litestar(middleware=[session_config.middleware])"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:383
msgid ":class:`~litestar.middleware.session.client_side.CookieBackendConfig`"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:387
msgid "Server-side sessions"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:389
msgid ""
"Server side session store data - as the name suggests - on the server "
"instead of the client. They use a cookie containing a session ID which is a "
"randomly generated string to identify a client and load the appropriate data "
"from the store"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:393
msgid ""
"from pathlib import Path\n"
"\n"
"from litestar import Litestar\n"
"from litestar.middleware.session.server_side import ServerSideSessionConfig\n"
"from litestar.stores.file import FileStore\n"
"\n"
"app = Litestar(\n"
"    middleware=[ServerSideSessionConfig().middleware],\n"
"    stores={\"sessions\": FileStore(path=Path(\"session_data\"))},\n"
")\n"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:398
msgid ":doc:`/usage/stores`"
msgstr ""

#: ../../../usage/middleware/builtin-middleware.rst:399
msgid ""
":class:`~litestar.middleware.session.server_side.ServerSideSessionConfig`"
msgstr ""
